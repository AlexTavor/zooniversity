import React, { useRef } from 'react';
import { IRefPhaserGame, PhaserGame } from './game/PhaserGame';
import {UISwitcher} from "./ui/ui_switcher/UISwitcher.tsx"; 

export function App() {
    const phaserRef = useRef<IRefPhaserGame | null>(null);

    return (
        <div id="app">
            <div id="game-wrapper">
                <PhaserGame ref={phaserRef} />
                <UISwitcher/>
            </div>
        </div>
    );
}


// ---

/**
 * An entity is just an ID. This is used to look up its associated
 * Components.
 */
export type Entity = number

/**
 * A Component is a bundle of state. Each instance of a Component is
 * associated with a single Entity.
 *
 * Components have no API to fulfill.
 */
export abstract class Component { }

/**
 * A System cares about a set of Components. It will run on every Entity
 * that has that set of Components.
 *
 * A System must specify two things:
 *
 *  (1) The immutable set of Components it needs at compile time. (Its
 *      immutability isn't enforced by anything but my wrath.) We use the
 *      type `Function` to refer to a Component's class; i.e., `Position`
 *      (class) rather than `new Position()` (instance).
 *
 *  (2) An update() method for what to do every frame (if anything).
 */
export abstract class System {

    /**
     * Set of Component classes, ALL of which are required before the
     * system is run on an entity.
     *
     * This should be defined at compile time and should never change.
     */
    public abstract componentsRequired: Set<Function>

    /**
     * update() is called on the System every frame.
     */
    public abstract update(entities: Set<Entity>, delta: number): void

    /**
     * The ECS is given to all Systems. Systems contain most of the game
     * code, so they need to be able to create, mutate, and destroy
     * Entities and Components.
     */
    public ecs: ECS
}

/**
 * This type is so functions like the ComponentContainer's get(...) will
 * automatically tell TypeScript the type of the Component returned. In
 * other words, we can say get(Position) and TypeScript will know that an
 * instance of Position was returned. This is amazingly helpful.
 */
type ComponentClass<T extends Component> = new (...args: any[]) => T

/**
 * This custom container is so that calling code can provide the
 * Component *instance* when adding (e.g., add(new Position(...))), and
 * provide the Component *class* otherwise (e.g., get(Position),
 * has(Position), delete(Position)).
 *
 * We also use two different types to refer to the Component's class:
 * `Function` and `ComponentClass<T>`. We use `Function` in most cases
 * because it is simpler to write. We use `ComponentClass<T>` in the
 * `get()` method, when we want TypeScript to know the type of the
 * instance that is returned. Just think of these both as referring to
 * the same thing: the underlying class of the Component.
 *
 * You might notice a footgun here: code that gets this object can
 * directly modify the Components inside (with add(...) and delete(...)).
 * This would screw up our ECS bookkeeping of mapping Systems to
 * Entities! We'll fix this later by only returning callers a view onto
 * the Components that can't change them.
 */
class ComponentContainer {
    private map = new Map<Function, Component>()

    public add(component: Component): void {
        this.map.set(component.constructor, component);
    }

    public get<T extends Component>(
        componentClass: ComponentClass<T>
    ): T {
        return this.map.get(componentClass) as T;
    }

    public has(componentClass: Function): boolean {
        return this.map.has(componentClass);
    }

    public hasAll(componentClasses: Iterable<Function>): boolean {
        for (let cls of componentClasses) {
            if (!this.map.has(cls)) {
                return false;
            }
        }
        return true;
    }

    public delete(componentClass: Function): void {
        this.map.delete(componentClass);
    }
}

/**
 * The ECS is the main driver; it's the backbone of the engine that
 * coordinates Entities, Components, and Systems. You could have a single
 * one for your game, or make a different one for every level, or have
 * multiple for different purposes.
 */
export class ECS {
    // Main state
    private entities = new Map<Entity, ComponentContainer>();
    private components = new Map<Function, Entity[]>(); // Key must be a Component class
    private systems = new Map<System, Set<Entity>>();

    // Bookkeeping for entities.
    private nextEntityID = 1
    private entitiesToDestroy = new Array<Entity>()

    // API: Entities

    public addEntity(): Entity {
        let entity = this.nextEntityID;
        this.nextEntityID++;
        this.entities.set(entity, new ComponentContainer());
        return entity;
    }

    /**
     * Marks `entity` for removal. The actual removal happens at the end
     * of the next `update()`. This way we avoid subtle bugs where an
     * Entity is removed mid-`update()`, with some Systems seeing it and
     * others not.
     */
    public removeEntity(entity: Entity): void {
        this.entitiesToDestroy.push(entity);
    }

    // API: Components

    public addComponent(entity: Entity, component: Component): void {
        this.components.has(component.constructor) ?
            this.components.get(component.constructor)!.push(entity) :
            this.components.set(component.constructor, [entity]);
        this.entities.get(entity)!.add(component);
        this.checkE(entity);
    }

    public getEntitiesWithComponent(componentClass: Function): Entity[] {
        return this.components.get(componentClass) ?? [];
    }

    public getEntitiesWithComponents(componentClasses: Function[]): Entity[] {
        const entities = this.getEntitiesWithComponent(componentClasses[0]);
        return entities.filter(entity => componentClasses.every(componentClass => this.entities.get(entity)!.has(componentClass)));
    }

    public getComponents(entity: Entity): ComponentContainer {
        return this.entities.get(entity)!;
    }

    public getComponent<T extends Component>(entity: Entity, componentClass: ComponentClass<T>): T {
        return this.entities.get(entity)?.get(componentClass)!;
    }

    public removeComponent(
        entity: Entity, componentClass: Function
    ): void {
        this.entities.get(entity)?.delete(componentClass);
        this.components.get(componentClass)?.splice(
            this.components.get(componentClass)!.indexOf(entity), 1
        );

        this.checkE(entity);
    }

    // API: Systems

    public addSystem(system: System): void {
        // Checking invariant: systems should not have an empty
        // Components list, or they'll run on every entity. Simply remove
        // or special case this check if you do want a System that runs
        // on everything.
        if (system.componentsRequired.size == 0) {
            console.warn("System not added: empty Components list.");
            console.warn(system);
            return;
        }

        // Give system a reference to the ECS so it can actually do
        // anything.
        system.ecs = this;

        // Save system and set who it should track immediately.
        this.systems.set(system, new Set());
        for (let entity of this.entities.keys()) {
            this.checkES(entity, system);
        }
    }

    /**
     * Note: I never actually had a removeSystem() method for the entire
     * time I was programming the game Fallgate (2 years!). I just added
     * one here for a specific testing reason (see the next post).
     * Because it's just for demo purposes, this requires an actual
     * instance of a System to remove (which would be clunky as a real
     * API).
     */
    public removeSystem(system: System): void {
        this.systems.delete(system);
    }

    /**
     * This is ordinarily called once per tick (e.g., every frame). It
     * updates all Systems, then destroys any Entities that were marked
     * for removal.
     */
    public update(delta:number): void {
        // Update all systems. (Later, we'll add a way to specify the
        // update order.)
        for (let [system, entities] of this.systems.entries()) {
            system.update(entities, delta)
        }

        // Remove any entities that were marked for deletion during the
        // update.
        while (this.entitiesToDestroy.length > 0) {
            this.destroyEntity(this.entitiesToDestroy.pop()!);
        }
    }

    // Private methods for doing internal state checks and mutations.

    private destroyEntity(entity: Entity): void {
        for (let componentClass of this.components.keys()) {
            if (this.entities.get(entity)?.has(componentClass)) {
                this.removeComponent(entity, componentClass);
            }
        }

        this.entities.delete(entity);
        for (let entities of this.systems.values()) {
            entities.delete(entity);  // no-op if doesn't have it
        }

    }

    private checkE(entity: Entity): void {
        for (let system of this.systems.keys()) {
            this.checkES(entity, system);
        }
    }

    private checkES(entity: Entity, system: System): void {
        let have = this.entities.get(entity);
        let need = system.componentsRequired;
        if (have!.hasAll(need)) {
            // should be in system
            this.systems.get(system)!.add(entity); // no-op if in
        } else {
            // should not be in system
            this.systems.get(system)!.delete(entity); // no-op if out
        }
    }

    hasEntity(enemy: number) {
        return this.entities.has(enemy);
    }

    hasComponent(entity: Entity, componentClass: Function) {
        return this.entities.get(entity)?.has(componentClass) ?? false;
    }
}

// ---

import { Events } from 'phaser';

// Used to emit events between React components and Phaser scenes
// https://newdocs.phaser.io/docs/3.70.0/Phaser.Events.EventEmitter
export const EventBus = new Events.EventEmitter();

// ---

import React, { forwardRef, useEffect, useLayoutEffect, useRef } from 'react';
import StartGame from './main';
import { EventBus } from './EventBus';

export interface IRefPhaserGame
{
    game: Phaser.Game | null;
    scene: Phaser.Scene | null;
}

interface IProps
{
    currentActiveScene?: (scene_instance: Phaser.Scene) => void
}

export const PhaserGame = forwardRef<IRefPhaserGame, IProps>(function PhaserGame({ currentActiveScene }, ref)
{
    const game = useRef<Phaser.Game | null>(null!);

    useLayoutEffect(() =>
    {
        if (game.current === null)
        {
            game.current = StartGame("game-container");

            if (typeof ref === 'function')
            {
                ref({ game: game.current, scene: null });
            } else if (ref)
            {
                ref.current = { game: game.current, scene: null };
            }

        }

        return () =>
        {
            if (game.current)
            {
                try {
                    game.current.plugins.destroy();
                } finally {
                    game.current.canvas.remove();
                    game.current.destroy(true);
                    game.current = null;
                }
            }
        }
    }, [ref]);

    useEffect(() =>
    {
        EventBus.on('current-scene-ready', (scene_instance: Phaser.Scene) =>
        {
            if (currentActiveScene && typeof currentActiveScene === 'function')
            {
                currentActiveScene(scene_instance);
            }

            if (typeof ref === 'function')
            {
                ref({ game: game.current, scene: scene_instance });
            } else if (ref)
            {
                ref.current = { game: game.current, scene: scene_instance };
            }

        });
        return () =>
        {
            EventBus.removeListener('current-scene-ready');
        }
    }, [currentActiveScene, ref]);

    return <div id='game-container'/>;
});

// ---

import { Entity } from "../ECS";


export enum SlotType {
    WORK = "work",
    SLEEP = "sleep",
    FORAGE = "forage"
}

export enum SlotLayout {
  RADIAL = "radial",
  GRID = "grid"
}

export interface Slot {
  x: number;
  y: number;
  occupiedBy: Entity | null;
}

interface BaseSlotDefinition {
  layout: SlotLayout;
  count: number;
}

interface RadialSlotDefinition extends BaseSlotDefinition {
  layout: SlotLayout.RADIAL;
  radius: number; // Distance from center for RADIAL layout
}

interface GridSlotDefinition extends BaseSlotDefinition {
  layout: SlotLayout.GRID;
  spacing: number; // Distance between slot centers for GRID layout
}

export type SlotDefinition = RadialSlotDefinition | GridSlotDefinition;

export class InteractionSlots {
  private slots: Map<SlotType, Slot[]> = new Map();

  constructor(definitions: Partial<Record<SlotType, SlotDefinition>>) {
    for (const [type, def] of Object.entries(definitions) as [SlotType, SlotDefinition][]) {
      if (def) { // Ensure def is not undefined if Record value can be optional
        this.slots.set(type, createSlots(def));
      }
    }
  }

  public reserve(entity: Entity, slotType: SlotType = SlotType.WORK): { x: number; y: number } | null {
    const group = this.slots.get(slotType);
    if (!group) return null;

    if (slotType === SlotType.WORK) {
      console.log(`reserve WORK slot for entity ${entity}`);
    }

    for (const slot of group) {
      if (slot.occupiedBy === null) {
        slot.occupiedBy = entity;
        return { x: slot.x, y: slot.y };
      }
    }
    return null;
  }

  public releaseAll(entity: Entity): void {
    for (const group of this.slots.values()) {
      for (const slot of group) {
        if (slot.occupiedBy === entity) {
          slot.occupiedBy = null;
        }
      }
    }
  }

  public release(entity: Entity, slotType: SlotType): void {
    const group = this.slots.get(slotType);
    if (!group) return;

    for (const slot of group) {
      if (slot.occupiedBy == entity) {
        slot.occupiedBy = null;
      }
    }
  }

  public getSlotsArray(type: SlotType): ReadonlyArray<Slot> {
    return this.slots.get(type) || [];
  }

  public inUse(type:SlotType):boolean {
    if (this.slots.has(type)) {
      return this.slots.get(type)!.some(slot => slot.occupiedBy !== null);
    }
    return false;
  }
}

function createSlots(definition: SlotDefinition): Slot[] {
  const slots: Slot[] = [];
  const { count } = definition;

  if (definition.layout === SlotLayout.RADIAL) {
    // radius is guaranteed to exist due to the RadialSlotDefinition type
    const { radius } = definition;
    if (count <= 0) return slots; // No slots to create

    for (let i = 0; i < count; i++) {
      const angle = (i / count) * Math.PI * 2;
      slots.push({
        x: Math.round(Math.cos(angle) * radius),
        y: Math.round(Math.sin(angle) * radius),
        occupiedBy: null
      });
    }
  } else if (definition.layout === SlotLayout.GRID) {
    // spacing is guaranteed to exist due to the GridSlotDefinition type
    const { spacing } = definition;
    if (count <= 0) return slots; // No slots to create

    const gridSize = Math.ceil(Math.sqrt(count));
    // This offset centers the grid around the local (0,0) point
    const offsetAmount = (gridSize - 1) / 2;

    for (let i = 0; i < count; i++) {
      const row = Math.floor(i / gridSize);
      const col = i % gridSize;

      slots.push({
        x: Math.round((col - offsetAmount) * spacing),
        y: Math.round((row - offsetAmount) * spacing),
        occupiedBy: null
      });
    }
  }
  return slots;
}

// ---

import {Component} from "../ECS.ts";

export class Transform extends Component {
    locationState: LocationState = LocationState.OUTSIDE;
    direction: number = 0; // -1 for right, 1 for left
    constructor(
        public x: number,
        public y: number
    ) {
        super();
    }
}

export enum LocationState {
    AWAY,
    OUTSIDE,
    INSIDE
}


// ---

export class AnimImportsConfig {
    public readonly FrameWidth = 256;
    public readonly FrameHeight = 256;
    public readonly StaticWidth = 1536;
    public readonly StaticHeight = 1024;
    public readonly NumberOfTrees = 6;
    public readonly NumberOfBushes = 2;
    public readonly NumberOfFrames = 4;
}

// ---

export class CameraConfig {
    public readonly MaxTimeBetweenClicksMs: number = 200;
    public readonly MaxZoom: number = 8;
    public readonly MinZoom: number = 0.14;
    public readonly DefaultZoom: number = 1;
    public readonly DragDamping: number = 0.95;
    public readonly InertiaThreshold: number = 0.05;
    public readonly ZoomDurationMs: number = 300;
    public readonly PanDurationMs: number = 300;
    public readonly WheelZoomFactorIncrement: number = 1.5;
    public readonly WheelZoomFactorDecrement: number = 0.5;
    public readonly BackgroundColor: number = 0x0000ff;
    public readonly PanEasing: string = 'Linear';
}

// ---

import {AnimImportsConfig} from "./AnimImportsConfig.ts";
import {MapConfig} from "./MapConfig.ts";
import {Display} from "./Display.ts";
import {CameraConfig} from "./CameraConfig.ts";

export class Config {
    public static readonly Display:Display = new Display();
    public static readonly Map:MapConfig = new MapConfig();
    public static readonly AnimImports:AnimImportsConfig = new AnimImportsConfig();
    public static readonly Camera = new CameraConfig();
    public static readonly GameWidth = Config.Display.Width*(Config.Camera.MaxZoom-1);
    public static readonly GameHeight = Config.Display.Height*(Config.Camera.MaxZoom-1);
    public static readonly EntryScene = "Game"; // "GameEditorTools"
}

// ---

export class Display {
    public readonly Width = 1280;
    public readonly Height = 720;
    public readonly PixelsPerUnit = 256;
}

// ---

export class MapConfig {
    public readonly WidthInTiles = 128;
    public readonly HeightInTiles = 72;
}


// ---

export class TimeConfig {
    static HoursPerDay = 9;
    static DaysPerSemester = 30;
    static MinutesPerHour = 60;

    // In real-world seconds, 1 hour of in-game time takes 1 minute IRL
    static RealSecondsPerHour = 60;

    static SpeedMultipliers = {
        paused: 0,
        normal: 1,
        fast: 12,
        veryfast: 60,
    } as const;
}


// ---

export namespace WeatherConfig {
    
    const timeMultiplier = 10000;
    const freq = 0.0005 / timeMultiplier; 
    
    // Wind behavior
    export const Wind = {
        StrengthFrequency: freq,   // How fast wind strength changes (lower = slower)
        DirectionFrequency: 0.00000005,   // How often direction noise updates
        DirectionThreshold: 0,        // Threshold for flipping direction (uses noise > 0)
        Bias: 0.3,                  // 0 = favor calm, 1 = favor wind, 0.5 = uniform,
        MinSpeed: 100,                 // Minimum wind speed
        MaxSpeed: 1000,               // Maximum wind speed
    };

    // Cloud cover behavior
    export const CloudCover = {
        Frequency: freq,           // How fast cloud cover changes
        NoiseOffset: 5000,            // Offset for sampling different noise axis
        MinAlpha: 0,                // Minimum cloud alpha (when cover is low)
        MaxAlpha: 1.0,                // Maximum cloud alpha (full cover)
        Bias: 0  //  0 = usually clear, 1 = usually cloudy    
    };
}


// ---

export class DnDEvent {
    public static readonly DragControlStart = 'drag-control-start';
    public static readonly DragControlEnd = 'drag-control-end';
    
    public static readonly DragStart = 'drag:start';
    public static readonly DragDrop = 'drag:drop';
    public static readonly DragCancel = 'drag:cancel';
    public static readonly DragDrag = 'drag:drag';
}

// ---

export class EditorEvent {
    public static readonly MapUpdated: string = 'map-updated';
    public static readonly MapLoaded: string = 'map-loaded';
    public static readonly PaletteTypeSelected: string = 'palette-type-selected';
}

export enum PaletteType {
    none = 'none',
    trees = 'trees',
    caves = 'caves',
}

// ---

export enum GameEvent {
    NewGame = "new-game",
    LoadGame = "load-game",
    GameLoaded = "game-loaded",
    SetTimeSpeed = "set-time-speed",
    SetTime = "set-time",
    SetWeather = "set-weather",
    SelectionChanged = "selection-changed",
    StoryEventEnded = "StoryEventEnded",
    StoryEventOptionChosen = "StoryEventOptionChosen",
    StoryEventStarted = "StoryEventStarted",
    StoryEventPageChanged = "StoryEventPageChanged",
    ViewsInitialized = "ViewsInitialized",
    ResourcesUpdated = "ResourcesUpdated",
    InitGame = "init-game",
    CharacterUpdate = "character-update",
    ViewSelected = "ViewSelected",
    TreeSelectedForCutting = "TreeSelectedForCutting",
    ToolSelected = "ToolSelected",
}


// ---

export class Naming {
    public static readonly VIEW: string = 'view-';
    public static readonly SPRITE: string = 'sprite-';
    public static readonly SEPARATOR: string = '-';
}

// ---

export class PointerEvent {
    public static readonly PointerDown: string = 'pointerdown';
    public static readonly PointerUp: string = 'pointerup';
    public static readonly PointerMove: string = 'pointermove';
    public static readonly Wheel: string = 'wheel';
    public static readonly DoubleClick: string = 'dblclick';
}

// ---

export const UIConfig = {
    PanelTransitionMs: 100,
};

// ---

export enum UIEvent {
    ShowPanelCalled = "show-panel",
    PortraitClicked = "portrait-clicked",
    FindViewRequested = "find-view-requested",
}

export const GameUIEvent = UIEvent;


// ---

import { DisplayModule } from "./setup/DisplayModule.ts";
import {ECS, Entity} from "../ECS.ts";
import { Layers } from "./setup/Layers.ts";
import {Config} from "../config/Config.ts";
import {createView} from "./setup/ViewStore.ts";
import {View} from "./setup/View.ts";
import { EffectType } from "./setup/ViewEffectController.ts";

export interface GameDisplayContext {
    scene: Phaser.Scene;
    layers: Layers;
    ecs: ECS;
    viewsByEntity: Map<Entity, View>;
    iconsByEntity: Map<Entity, View>;
}

export type GameDisplayModule = DisplayModule<GameDisplayContext>;

export class GameDisplay implements GameDisplayContext {
    modules: GameDisplayModule[];
    scene: Phaser.Scene;
    ecs: ECS;
    layers: Layers;
    hill: View;
    
    viewsByEntity:Map<Entity, View> = new Map();
    iconsByEntity:Map<Entity, View> = new Map();

    init(
        scene: Phaser.Scene, 
        ecs: ECS, 
        modules: GameDisplayModule[])
    {
        this.scene = scene;
        this.ecs = ecs;
        this.layers = new Layers(scene);
        this.modules = modules;
        
        for (const module of this.modules) {
            module.init(this);
        }
        
        this.setHill();
    }
    
    public setHill(): void {
        // Why offset?
        const hOffset = 100;
        const wOffset = 100;

        const hillPosition = {
            x: Math.round(Config.GameWidth / 2 + wOffset),
            y: Math.round(Config.GameHeight / 2 + hOffset)
        };


        const hillDef = createView({
            position: hillPosition,
            spriteName: 'hill',
            selectable: false,
        });
        
        this.hill = new View(0, {}, hillDef, this.layers.Ground, this.scene);
        this.hill.applyEffect(EffectType.Shader, { shader: "TimeTint" });
    }

    public destroy() {
        this.modules.forEach(module => module.destroy());
        this.layers.destroy();
    }

    public update(delta: number) {
        this.modules.forEach(module => module.update(delta));
        this.viewsByEntity.forEach(view => view.update(delta));
        this.iconsByEntity.forEach(view => view.update(delta));
    }
}


// ---

import {GameDisplay} from "../GameDisplay.ts";
import {DisplayModule} from "../setup/DisplayModule.ts";
import {ControlledCamera} from "./ControlledCamera.ts";
import {Config} from "../../config/Config.ts";
import { EventBus } from "../../EventBus.ts";
import { GameEvent } from "../../consts/GameEvent.ts";
import { UIEvent } from "../../consts/UIEvent.ts";

export class CameraModule extends DisplayModule<GameDisplay> {
    public Camera: ControlledCamera;

    override init(display: GameDisplay) {
        this.Camera = new ControlledCamera(display.scene, Config.GameWidth, Config.GameHeight, Config.Camera);
        EventBus.on(UIEvent.FindViewRequested, this.handleFindViewRequested.bind(this));
    }

    private handleFindViewRequested(view: Phaser.GameObjects.Container) {
        if (view) {
            this.Camera.lookAt(view.x, view.y);
        }
    }

    override update(delta: number) {
        this.Camera?.update(delta);
    }

    override destroy() {
        this.Camera?.destroy();
        EventBus.off(GameEvent.ViewSelected);
    }
}

// ---

import Phaser from 'phaser';
import {CameraConfig} from "../../config/CameraConfig.ts";
import {PointerEvent} from "../../consts/PointerEvent.ts";
import { EventBus } from '../../EventBus.ts';

export class ControlledCamera {

    private readonly scene: Phaser.Scene;
    private readonly camera: Phaser.Cameras.Scene2D.Camera;
    private readonly config: CameraConfig; 

    private isDown = false;
    private isCountingClicks = false;
    private clickCount = 0;
    private timeout: number = 0;
    private dragInertia: Phaser.Math.Vector2 = new Phaser.Math.Vector2();
    private lastDragDelta: Phaser.Math.Vector2 = new Phaser.Math.Vector2();
    private readonly inertiaThresholdSq: number;
    
    public draggable: boolean = true;
    
    public constructor(
        scene: Phaser.Scene,
        worldWidth: number,
        worldHeight: number,
        config: CameraConfig, 
    ) {
        this.scene = scene;
        this.config = config;
        this.inertiaThresholdSq = this.config.InertiaThreshold * this.config.InertiaThreshold; 

        this.camera = this.scene.cameras.main;
        this.setupCamera(worldWidth, worldHeight);
    }

    public lookAt(x: number, y: number) {
        this.dragInertia.set(0, 0);

        const cam = this.camera;
        cam.pan(x,y,
          this.config.PanDurationMs,
          this.config.PanEasing,
          true
        );
      
        cam.zoomTo(
          this.config.DefaultZoom,
          this.config.ZoomDurationMs
        );
    }

    public follow(entity: Phaser.GameObjects.GameObject) {
        this.camera.startFollow(entity, true, 0.1, 0.1);
    }

    public destroy() {
        this.scene.input.off(PointerEvent.PointerDown, this.handlePointerDown, this);
        this.scene.input.off(PointerEvent.PointerUp, this.handlePointerUp, this);
        this.scene.input.off(PointerEvent.PointerMove, this.handlePointerMove, this);
        this.scene.input.off(PointerEvent.Wheel, this.handleWheel, this);
        clearTimeout(this.timeout);
    }

    private resetZoom() {
        this.dragInertia.set(0, 0);
        this.camera.pan(
            this.camera.width / 2,
            this.camera.height / 2,
            this.config.PanDurationMs,
            this.config.PanEasing,
            true
        );
        this.camera.zoomTo(
            this.config.MinZoom,
            this.config.ZoomDurationMs
        );
    }

    private handlePointerDown(pointer: Phaser.Input.Pointer) {
        if (pointer.rightButtonDown()) {
            return;
        }
        this.isDown = true;
        this.dragInertia.set(0, 0);
        this.lastDragDelta.set(0, 0);
        clearTimeout(this.timeout);

        if (!this.isCountingClicks) {
            this.isCountingClicks = true;
            this.timeout = window.setTimeout(() => {
                this.isCountingClicks = false;
                this.clickCount = 0;
            }, this.config.MaxTimeBetweenClicksMs);
        }
    }

    private handlePointerUp(pointer: Phaser.Input.Pointer) {
        if (this.scene.input.manager.activePointer.rightButtonDown()) {
            return;
        }
        this.dragInertia.copy(this.lastDragDelta);
        this.isDown = false;

        if (this.isCountingClicks) {
            this.clickCount++;
            if (this.clickCount === 2) {
                // TODO - fire event
                // this.resetZoom();
                const worldPoint = pointer.positionToCamera(this.camera) as Phaser.Math.Vector2;
                EventBus.emit(PointerEvent.DoubleClick, worldPoint);
                this.isCountingClicks = false;
                this.clickCount = 0;
                clearTimeout(this.timeout);
            }
        }
    }

    private handleWheel(pointer: Phaser.Input.Pointer) {
        const zoom = this.camera.zoom;
        let newZoom: number;

        if (pointer.deltaY < 0) {
            newZoom = Phaser.Math.Clamp(
                zoom * this.config.WheelZoomFactorIncrement,
                this.config.MinZoom,
                this.config.MaxZoom
            );
        } else {
            newZoom = Phaser.Math.Clamp(
                zoom * this.config.WheelZoomFactorDecrement, 
                this.config.MinZoom, 
                this.config.MaxZoom
            );
        }

        if (newZoom !== zoom) {
            this.dragInertia.set(0, 0);
            this.adjustCameraToPointer(pointer, newZoom);
        }
    }

    private adjustCameraToPointer(pointer: Phaser.Input.Pointer, newZoom: number) {
        const worldPoint = pointer.positionToCamera(this.camera) as Phaser.Math.Vector2;
        const newX = worldPoint.x - (worldPoint.x - this.camera.scrollX);
        const newY = worldPoint.y - (worldPoint.y - this.camera.scrollY);
        this.camera.zoomTo(
            newZoom,
            this.config.ZoomDurationMs
        );
        this.camera.setScroll(newX, newY);
    }

    private handlePointerMove(pointer: Phaser.Input.Pointer) {
        if (!this.isDown || !this.draggable) {
            return;
        }
        const dx = pointer.x - pointer.prevPosition.x;
        const dy = pointer.y - pointer.prevPosition.y;
        this.lastDragDelta.set(dx, dy);
        this.camera.scrollX -= (dx / this.camera.zoom);
        this.camera.scrollY -= (dy / this.camera.zoom);
    }

    update(_:number) {
        if (!this.isDown && this.dragInertia.lengthSq() > this.inertiaThresholdSq) {
            this.camera.scrollX -= (this.dragInertia.x / this.camera.zoom);
            this.camera.scrollY -= (this.dragInertia.y / this.camera.zoom);
            this.dragInertia.scale(this.config.DragDamping);
        } else if (this.dragInertia.x !== 0 || this.dragInertia.y !== 0) {
            this.dragInertia.set(0, 0);
        }
    }

    private setupCamera(worldWidth: number, worldHeight: number) {
        this.camera.setBackgroundColor(this.config.BackgroundColor);
        this.camera.setBounds(0, 0, worldWidth, worldHeight);

        this.scene.input.on(PointerEvent.PointerDown, this.handlePointerDown, this);
        this.scene.input.on(PointerEvent.PointerUp, this.handlePointerUp, this);
        this.scene.input.on(PointerEvent.PointerMove, this.handlePointerMove, this);
        this.scene.input.on(PointerEvent.Wheel, this.handleWheel, this);

        this.resetZoom();
    }
}

// ---


import Phaser from "phaser";
import { ECS, Entity } from "../../../ECS";
import { Transform } from "../../../components/Transform";
import { WoodDojo } from "../../../logic/buildings/wood_dojo/WoodDojo";
import { SpriteKey } from "../../setup/SpriteLibrary";
import { View } from "../../setup/View";
import { ViewDefinition, ViewType, PanelDefinition } from "../../setup/ViewDefinition";
import { ViewDisplayModule, registerViewDisplayModule } from "../../setup/ViewDisplayModule";
import { EffectType } from "../../setup/ViewEffectController";
import { createView } from "../../setup/ViewStore";
import { ToolType } from "../tools/GameTools";
import { GameDisplayContext } from "../../GameDisplay";

export class BuildingViewModule extends ViewDisplayModule {
    init(context: GameDisplayContext): void {
        registerViewDisplayModule(this, context, context.viewsByEntity);
    }

    update(delta: number): void {
        this.tracker?.update();
    }

    destroy(): void {
        this.tracker?.destroy();
    }
      
  getComponentClasses(): Function[] {
    return [Transform, WoodDojo];
  }

  getLayerContainer(): Phaser.GameObjects.Container {
    return this.context.layers.Caves;
  }

  createDefinition(ecs: ECS, entity: Entity): ViewDefinition {
    const transform = ecs.getComponent(entity, Transform);

    return createView({
      spriteName: "wood_dojo" as SpriteKey,
      position: {
        x: Math.round(transform.x),
        y: Math.round(transform.y),
      },
      size: { x: 2, y: 2 },
      frame: 0,
      type: ViewType.CAVE,
      panelDefinition: this.createPanelDefinition(),
    });
  }

  private createPanelDefinition(): PanelDefinition {
    const panel = new PanelDefinition();
    panel.title = "Wood Dojo";
    panel.description = "Center of Wood Mastery";
    panel.imagePath = "assets/panels/wood_dojo_panel.png";
    panel.actions = [
      {
        label: "Select Trees to Harvest",
        type: ToolType.TreeCutting,
      },
    ];
    return panel;
  }

  updateView(ecs: ECS, entity: Entity, view: View): boolean {
    const transform = ecs.getComponent(entity, Transform);
    view.viewContainer.x = Math.round(transform.x);
    view.viewContainer.y = Math.round(transform.y);
    return false;
  }

  createView(ecs: ECS, entity: number, views: { [key: number]: ViewDefinition; }, viewDefinition: ViewDefinition): View {
    const view = new View(viewDefinition.id, views, viewDefinition, this.context.layers.Surface, this.context.scene);
    view.applyEffect(EffectType.Shader, { shader: "TimeTint" });

    return view;
}
}


// ---

import { ECS, Entity } from "../../../ECS";
import { Cave } from "../../../logic/buildings/Cave";
import { Transform } from "../../../components/Transform";
import { GameDisplayContext } from "../../GameDisplay";
import { SpriteKey } from "../../setup/SpriteLibrary";
import { View } from "../../setup/View";
import { ViewDefinition, ViewType } from "../../setup/ViewDefinition";
import { ViewDisplayModule, registerViewDisplayModule } from "../../setup/ViewDisplayModule";
import { EffectType } from "../../setup/ViewEffectController";
import { createView } from "../../setup/ViewStore";


export class CaveViewModule extends ViewDisplayModule {
    init(context: GameDisplayContext): void {
        registerViewDisplayModule(this, context, context.viewsByEntity);
    }

    update(delta: number): void {
        this.tracker?.update();
    }

    destroy(): void {
        this.tracker?.destroy();
    }
      
  getComponentClasses(): Function[] {
    return [Transform, Cave];
  }

  getLayerContainer(): Phaser.GameObjects.Container {
    return this.context.layers.Caves;
  }

  createDefinition(ecs: ECS, entity: Entity): ViewDefinition {
    const transform = ecs.getComponent(entity, Transform);

    return createView({
      spriteName: "cave" as SpriteKey,
      position: {
        x: Math.round(transform.x),
        y: Math.round(transform.y),
      },
      frame: 0,
      type: ViewType.CAVE,
    });
  }

  updateView(ecs: ECS, entity: Entity, view: View): boolean {
    const transform = ecs.getComponent(entity, Transform);
    view.viewContainer.x = Math.round(transform.x);
    view.viewContainer.y = Math.round(transform.y);
    return false;
  }

  createView(ecs: ECS, entity: number, views: { [key: number]: ViewDefinition; }, viewDefinition: ViewDefinition): View {
    const view = new View(viewDefinition.id, views, viewDefinition, this.context.layers.Caves, this.context.scene);
    view.applyEffect(EffectType.Shader, { shader: "TimeTint" });
    return view;
}
}


// ---


import Phaser from "phaser";
import { ECS, Entity } from "../../../ECS";
import { EventBus } from "../../../EventBus";
import { GameEvent } from "../../../consts/GameEvent";
import { Character, CharacterType } from "../../../logic/characters/Character";
import { LocationState, Transform } from "../../../components/Transform";
import { View } from "../../setup/View";
import { ViewDefinition, PanelDefinition, ViewType, PanelType } from "../../setup/ViewDefinition";
import { ViewDisplayModule, registerViewDisplayModule } from "../../setup/ViewDisplayModule";
import { EffectType } from "../../setup/ViewEffectController";
import { createView } from "../../setup/ViewStore";
import { ViewTracker } from "../../setup/ViewTracker";
import { GameDisplayContext } from "../../GameDisplay";
import { ActionIntentComponent } from "../../../logic/intent/intent-to-action/ActionIntentComponent";
import { CharacterAction } from "../../../logic/intent/intent-to-action/actionIntentData";

export class CharacterViewModule extends ViewDisplayModule {
    init(context: GameDisplayContext): void {
        registerViewDisplayModule(this, context, context.viewsByEntity);
    }

    update(delta: number): void {
        this.tracker?.update();
    }

    destroy(): void {
        this.tracker?.destroy();
    }
      
    getComponentClasses(): Function[] {
       return [Transform, Character];
    }

    getLayerContainer(): Phaser.GameObjects.Container {
        return this.context.layers.Surface;
    }

    createDefinition(ecs: ECS, entity: Entity): ViewDefinition {
        const transform = ecs.getComponent(entity, Transform);

        const panelDefinition = new PanelDefinition();
        panelDefinition.title = "Professor Booker";
        panelDefinition.description = "The kind, absent-minded founder of Zooniversity.";
        panelDefinition.imagePath = "assets/characters/booker/booker_panel.png";
        panelDefinition.panelType = PanelType.CHARACTER;

        return createView({
            spriteName: "booker_char",
            position: {
                x: Math.round(transform.x),
                y: Math.round(transform.y),
            },
            frame: 0,
            type: ViewType.CHARCTER,
            panelDefinition
        });
    }

    updateView(ecs: ECS, entity: Entity, view: View): boolean {
        const transform = ecs.getComponent(entity, Transform);
        const rx = Math.round(transform.x);
        const ry = Math.round(transform.y);
        view.viewContainer.visible = transform.locationState != LocationState.INSIDE;
        const isChanged = view.viewContainer.x !== rx || view.viewContainer.y !== ry;

        view.viewContainer.x = rx;
        view.viewContainer.y = ry;
        view.viewContainer.scaleX = view.viewDefinition.size.x * transform.direction;

        const action = ecs.getComponent(entity, ActionIntentComponent)?.currentPerformedAction ?? CharacterAction.NONE;

        const updateData = {
            id: entity,
            pos: ViewTracker.getReactCoordsFromPhaser(view.viewContainer, this.context.scene.cameras.main),
            character: {
                icon: "assets/characters/booker/booker_icon.png",
                type: CharacterType.PROFESSOR
            },
            currentAction: action
        };

        EventBus.emit(GameEvent.CharacterUpdate, updateData);

        return isChanged;
    }


    createView(ecs: ECS, entity: number, views: { [key: number]: ViewDefinition; }, viewDefinition: ViewDefinition): View {
        const view = new View(viewDefinition.id, views, viewDefinition, this.context.layers.Surface, this.context.scene);
        view.applyEffect(EffectType.Shader, { shader: "TimeTint" });
        return view;
    }
}


// ---

import { BuffType } from "../../../logic/buffs/buffsData";

export interface BuffDisplayInfo {
    isBuff: boolean;
    displayName: string;
    iconAssetKey: string;
    description: string;
}

export const BuffDisplayRegistry: Partial<Record<BuffType, BuffDisplayInfo>> = {
    [BuffType.RESTED]: {
        displayName: "Rested",
        iconAssetKey: "assets/icons/sleep_icon.png",
        description: "Feeling refreshed! +10% to walking and work speed.",
        isBuff: true,
    },
    [BuffType.TIRED]: {
        displayName: "Tired",
        iconAssetKey: "assets/icons/sleep_icon.png",
        description: "Tired! -25%% to walking and work speed.",
        isBuff: false,
    }
    // Add display information for other BuffTypes as they are created and need UI representation.
};

// ---

import { GameDisplayContext } from "../../GameDisplay.ts";
import { DisplayModule } from "../../setup/DisplayModule.ts";
import { EventBus } from "../../../EventBus.ts";
import { UIEvent } from "../../../consts/UIEvent.ts";
import { GameEvent } from "../../../consts/GameEvent.ts";
import { PanelDefinition } from "../../setup/ViewDefinition.ts";
import { PanelTypeReducer, PanelTypeReducers } from "./PanelReducersRegistry.ts";
import { PanelActionImplementation, SelectionPanelReducer, SelectionPanelReducers, createPanelActions } from "./PanelAction.ts";

export type PanelData = {
  findAction?:()=>void;
  actionsImpl?: PanelActionImplementation[];
  panelTypeData?: unknown;
} & PanelDefinition;

const findActionDefinition = {
  label: "find",
  type: "find",
};

export class DataPanelModule extends DisplayModule<GameDisplayContext> {
  private display: GameDisplayContext;
  private activeEntity: number = -1;
  private lastPayload: string = "";

  public init(display: GameDisplayContext): void {
    this.display = display;
    EventBus.on(GameEvent.SelectionChanged, this.handleSelectionChanged, this);
  }

  public destroy(): void {
    EventBus.off(GameEvent.SelectionChanged, this.handleSelectionChanged, this);
  }

  private handleSelectionChanged(entity: number): void {
    this.activeEntity = entity;
    this.updatePanel();
  }

  public update(_: number): void {
    this.updatePanel();
  }

  private updatePanel(): void {
    if (this.activeEntity === -1) {
        EventBus.emit(UIEvent.ShowPanelCalled, null);
        this.lastPayload = "";
        return;
    }

    const view = this.display.viewsByEntity.get(this.activeEntity);
    if (!view) return;

    const baseDef = view.viewDefinition.panelDefinition;
    if (!baseDef) return;

    const reducer: SelectionPanelReducer | undefined = SelectionPanelReducers[view.viewDefinition.type];
    const reduced = reducer ? reducer(this.activeEntity, this.display.ecs) : {};

    const typeReducer: PanelTypeReducer | undefined = baseDef.panelType ? PanelTypeReducers[baseDef.panelType] : undefined;
    const panelTypeData = typeReducer ? typeReducer(this.activeEntity, this.display.ecs) : undefined;

    const fullDef: PanelData = {
            ...baseDef,
            ...reduced,
            actionsImpl: createPanelActions({...baseDef, actions:[findActionDefinition, ...(baseDef.actions || [])]}, this.activeEntity, view),
            panelTypeData,
            findAction:()=>{EventBus.emit(UIEvent.FindViewRequested, view.viewContainer);}
        };

        const payload = JSON.stringify(fullDef);
        if (payload !== this.lastPayload) {
            this.lastPayload = payload;
            EventBus.emit(UIEvent.ShowPanelCalled, fullDef);
        }
    }
}


// ---

import { Entity, ECS } from "../../../ECS";
import { EventBus } from "../../../EventBus";
import { GameEvent } from "../../../consts/GameEvent";
import { UIEvent } from "../../../consts/UIEvent";
import { View } from "../../setup/View";
import { PanelDefinition, DisplayTrait } from "../../setup/ViewDefinition";
import { ToolType } from "../tools/GameTools";

export type PanelActionImplementation = {
    label: string;
    type: string;
    action: () => void;
    icon?: string;
};

type PanelActionMaker = (def: PanelDefinition, entity: number, view: View) => () => void;

const actionFunctions: Record<string, PanelActionMaker> = {
    tree_cutting: (_def, _entity, _view) => () => {
        EventBus.emit(GameEvent.ToolSelected, ToolType.TreeCutting);
    },
    find: (_def, _entity, view) => () => {
        EventBus.emit(UIEvent.FindViewRequested, view.viewContainer);
    }
};

const actionIcons: Record<string, string> = {
    tree_cutting: "assets/icons/axe_icon.png",
    find: "assets/icons/find_icon.png"
};

export function createPanelActions(
    def: PanelDefinition,
    entity: number,
    view: View
    ): PanelActionImplementation[] {
    if (!def.actions) return [];
    return def.actions.map(action => ({
        label: action.label,
        type: action.type,
        action: actionFunctions[action.type]?.(def, entity, view) ?? (() => {}),
        icon: actionIcons[action.type] ?? undefined
    }));
}

export interface SelectionPanelData {
    traits?: DisplayTrait[];
    extraLines?: string[];
}

export type SelectionPanelReducer = (entity: Entity, ecs: ECS) => Partial<SelectionPanelData>;

export const SelectionPanelReducers: Partial<Record<number, SelectionPanelReducer>> = {}; // populated elsewhere if needed
  

// ---

import { ECS, Entity } from "../../../ECS";
import { PanelType } from "../../setup/ViewDefinition";
import { cavePanelReducer } from "./buildings/cavePanelReducer";
import { characterPanelReducer } from "./character/characterPanelReducer";
import { treePanelReducer } from "./tree/treePanelReducer";
import { woodDojoPanelReducer } from "./buildings/woodDojoPanelReducer";

export type PanelTypeReducer = (entity: Entity, ecs: ECS) => unknown;

export const PanelTypeReducers: Partial<Record<PanelType, PanelTypeReducer>> = {
  [PanelType.CHARACTER]: characterPanelReducer,
  [PanelType.WOOD_DOJO]: woodDojoPanelReducer,
  [PanelType.CAVE]: cavePanelReducer,
  [PanelType.TREE]: treePanelReducer
};

// ---

import { PanelDefinition, PanelType } from "../../setup/ViewDefinition";
import { ToolType } from "../tools/GameTools";

export enum PanelId {
  CHAR_BOOKER = "char_booker",
  BUILDING_WOOD_DOJO = "building_wood_dojo",
  TREE_GENERIC = "tree_generic",
  CAVE_GENERIC = "cave_generic",
}

export const PanelRegistry: Partial<Record<PanelId, PanelDefinition>> = {};

export function loadPanelRegistry(scene: Phaser.Scene) {
    const raw = scene.cache.json.get("panelRegistry") as Record<PanelId, PanelDefinition>;
    for (const [key, value] of Object.entries(raw)) {
      PanelRegistry[key as PanelId] = {
        ...value,
        panelType: PanelType[value.panelType as keyof typeof PanelType],
        actions: value.actions?.map((a: any) => ({
          label: a.label,
          type: ToolType[a.type as keyof typeof ToolType],
        })),
      };
    }
  }

// ---

import { ECS, Entity } from "../../../../ECS";

export function cavePanelReducer(entity: Entity, ecs: ECS): unknown {
    return {}; // Placeholder for cave-specific data
}


// ---

import { ECS, Entity } from "../../../../ECS";
import { WoodDojo } from "../../../../logic/buildings/wood_dojo/WoodDojo";

export function woodDojoPanelReducer(entity: Entity, ecs: ECS): unknown {
    const dojo = ecs.getComponent(entity, WoodDojo);
    return { assignedCharacters: dojo?.assignedCharacters ?? [] };
}


// ---

import { ECS, Entity } from "../../../../ECS";
import { TimeConfig } from "../../../../config/TimeConfig";
import { ActionIntentComponent } from "../../../../logic/intent/intent-to-action/ActionIntentComponent";
import { StrollComponent } from "../../../../logic/intent/intent-to-action/relaxation/StrollComponent";
import { CharacterIntent, CharacterAction, isChoppingData, isSleepingData, isStrollingAtPointData, isWalkingData } from "../../../../logic/intent/intent-to-action/actionIntentData";
import { StatCalculator } from "../../../../logic/buffs/StatCalculator";
import { AffectedStat } from "../../../../logic/buffs/buffsData";
import { DormitoryComponent } from "../../../../logic/buildings/dormitory/DormitoryComponent";
import { WoodDojo } from "../../../../logic/buildings/wood_dojo/WoodDojo";
import { ScheduleComponent } from "../../../../logic/characters/ScheduleComponent";
import { NeedType, NeedsComponent } from "../../../../logic/needs/NeedsComponent";
import { getTime } from "../../../../logic/time/TimeComponent";
import { Tree } from "../../../../logic/trees/Tree";
import { deriveBuffs } from "./deriveBuffs";

const NeedTypeToStatMap = new Map<NeedType, AffectedStat>([
    [NeedType.FOOD, AffectedStat.HUNGER_MODIFICATION_RATE],
    [NeedType.SLEEP, AffectedStat.SLEEP_MODIFICATION_RATE]
]);

export function characterPanelReducer(entity: Entity, ecs: ECS): unknown {
    const actionIntent = ecs.getComponent(entity, ActionIntentComponent);
    const schedule = ecs.getComponent(entity, ScheduleComponent);
    const needs = ecs.getComponent(entity, NeedsComponent);
    const time = getTime(ecs);
    const hour = time.hour;

    if (!actionIntent || !schedule) {
        return {
            currentStatusText: "Awaiting assignment",
            currentPerformedAction: CharacterAction.IDLE,
            currentScheduleIndex: hour,
            currentScheduleText: "No schedule",
            scheduleIconTypes: []
        };
    }

    const needsData = [...needs.needs].map(
        ([key, value]) => (
            { 
                type:key.toString(), 
                current:Math.floor(value.current), 
                max:Math.floor(value.max), 
                changeRatePerHour:((StatCalculator.getEffectiveStat(ecs, entity, NeedTypeToStatMap.get(key)!)*TimeConfig.HoursPerDay).toFixed(2))
            })
        );

    return {
        currentAction: {type:actionIntent.currentPerformedAction, description:actionToString[actionIntent.currentPerformedAction]},
        schedule: {currentSlotIndex:hour, slots:schedule.entries},
        needs: needsData,
        statusEffects:deriveBuffs(ecs, entity, time.minutesElapsed),
        currentStatusText: deriveCurrentStatusText(ecs, entity, actionIntent)
    }
}


export enum CharacterScheduleIconType {
    HARVEST = "Harvest", SLEEP = "Sleep", STUDY = "Study", REST = "Rest", BUILD = "Build", NONE = "None",
  }
  
function getStatusTextForRest(ecs: ECS, entity: Entity, aic: ActionIntentComponent): string {
    const strollComp = ecs.getComponent(entity, StrollComponent);
    if (strollComp) {
        if (aic.currentPerformedAction === CharacterAction.WALKING && isWalkingData(aic.actionData) && aic.actionData.ultimateTargetEntityId) {
            return `Strolling towards ${getEntityName(ecs, aic.actionData.ultimateTargetEntityId)}`;
        } else if (aic.currentPerformedAction === CharacterAction.STROLLING && isStrollingAtPointData(aic.actionData)) {
            return `Enjoying nature near ${getEntityName(ecs, aic.actionData.atTreeEntityId)}`;
        }
        return "Having a relaxing stroll";
    }
    return "Taking personal time";
}

function getStatusTextForHarvest(ecs: ECS, entity: Entity, aic: ActionIntentComponent): string {
    if (aic.currentPerformedAction === CharacterAction.WALKING && isWalkingData(aic.actionData) && aic.actionData.ultimateTargetEntityId) {
        return `Walking to ${getEntityName(ecs, aic.actionData.ultimateTargetEntityId)} to harvest`;
    } else if (aic.currentPerformedAction === CharacterAction.CHOPPING && isChoppingData(aic.actionData)) {
        return `Chopping ${getEntityName(ecs, aic.actionData.targetTreeEntityId)}`;
    } else if (aic.currentPerformedAction === CharacterAction.NONE) {
        return "Waiting for available tree";
    }
    return "Preparing to harvest";
}

function getStatusTextForSleep(ecs: ECS, entity: Entity, aic: ActionIntentComponent): string {
    if (aic.currentPerformedAction === CharacterAction.WALKING && isWalkingData(aic.actionData) && aic.actionData.ultimateTargetEntityId) {
        return `Going to bed at ${getEntityName(ecs, aic.actionData.ultimateTargetEntityId)}`;
    } else if (aic.currentPerformedAction === CharacterAction.SLEEPING && isSleepingData(aic.actionData)) {
        return `Sleeping in ${getEntityName(ecs, aic.actionData.bedEntityId)}`;
    } else if (aic.currentPerformedAction === CharacterAction.NONE) {
        return "Waiting for a bed";
    }
    return "Preparing for bed";
}

function deriveCurrentStatusText(ecs: ECS, entity: Entity, actionIntent: ActionIntentComponent): string {
    switch (actionIntent.intentType) {
        case CharacterIntent.REST:    return getStatusTextForRest(ecs, entity, actionIntent);
        case CharacterIntent.HARVEST: return getStatusTextForHarvest(ecs, entity, actionIntent);
        case CharacterIntent.SLEEP:   return getStatusTextForSleep(ecs, entity, actionIntent);
        case CharacterIntent.NONE:    return "Contemplating.";
        default:{
            const actionString = (Object.keys(CharacterAction) as Array<keyof typeof CharacterAction>)
                .find(key => CharacterAction[key] === actionIntent.currentPerformedAction);
            return actionString ? `${actionString}` : "Engaged in a task";
          }
    }
}

function getEntityName(ecs: ECS, entityId: Entity | null | undefined): string {
    if (entityId === null || entityId === undefined || !ecs.hasEntity(entityId)) return "an unknown place";
    if (ecs.hasComponent(entityId, Tree)) return "a tree";
    if (ecs.hasComponent(entityId, WoodDojo)) return "the Wood Dojo";
    if (ecs.hasComponent(entityId, DormitoryComponent)) return "the Dormitory";
    return `location #${entityId}`;
}

const actionToString : Record<CharacterAction, string> = {
    [CharacterAction.IDLE]: "Idle",
    [CharacterAction.WALKING]: "Walking",
    [CharacterAction.CHOPPING]: "Chopping",
    [CharacterAction.BUILDING]: "Building",
    [CharacterAction.STUDYING]: "Studying",
    [CharacterAction.SLEEPING]: "Sleeping",
    [CharacterAction.STROLLING]: "Resting",
    [CharacterAction.RELAXING]: "Resting",
    [CharacterAction.NONE]: "None",
    [CharacterAction.EATING]: "Eating",
    [CharacterAction.FORAGING]: "Foraging"
}


// ---

import { ECS, Entity } from "../../../../ECS";
import { BuffsComponent } from "../../../../logic/buffs/BuffsComponent";
import { AffectedStat, BuffEffectApplicationType, BuffEffect, BUFF_DEFINITIONS } from "../../../../logic/buffs/buffsData";
import { BuffDisplayRegistry } from "../BuffDisplayRegistry";

export interface DisplayableBuffEffect {
    stat: AffectedStat;
    value: number;
    applicationType: BuffEffectApplicationType;
    effectText: string; // Textual description of the specific effect
}

export interface DisplayableBuffData {
    key: string; 
    displayName: string;
    iconAssetKey: string;
    description: string; // General description of the buff
    effects: DisplayableBuffEffect[];
    totalDurationMinutes: number;
    remainingDurationMinutes: number; 
    isBuff: boolean; 
}

function formatEffectValue(value: number, type: BuffEffectApplicationType): string {
    if (type === BuffEffectApplicationType.FLAT_ADDITIVE) {
        return `${value >= 0 ? '+' : ''}${value}`;
    }
    if (type === BuffEffectApplicationType.PERCENT_MULTIPLICATIVE) {
        const percentage = Math.round((value - 1) * 100);
        return `${percentage >= 0 ? '+' : ''}${percentage}%`;
    }
    return `${value}`; // Fallback
}

function affectedStatToText(stat: AffectedStat): string {
    switch (stat) {
        case AffectedStat.LOCOMOTION_SPEED: return "Speed";
        case AffectedStat.WORK_SPEED: return "Work Rate";
        case AffectedStat.HARVEST_SPEED: return "Harvest Rate";
        default: {
            return "";
        }
    }
}

function effectToText(effect: BuffEffect): string {
    const valueText = formatEffectValue(effect.value, effect.type);
    const statText = affectedStatToText(effect.stat);
    return `${statText}: ${valueText}`;
}

export function deriveBuffs(ecs: ECS, entity: Entity, currentTimeMinutes: number): DisplayableBuffData[] {
    const displayedBuffs: DisplayableBuffData[] = [];
    const activeBuffsComp = ecs.getComponent(entity, BuffsComponent);

    if (!activeBuffsComp || activeBuffsComp.buffs.length === 0) {
        return displayedBuffs;
    }

    for (const activeBuff of activeBuffsComp.buffs) {
        const definition = BUFF_DEFINITIONS[activeBuff.type];
        const displayInfo = BuffDisplayRegistry[activeBuff.type];

        if (definition && displayInfo) {
            const remainingDuration = Math.max(0, Math.floor(activeBuff.expirationTimeMinutes - currentTimeMinutes));
            
            const processedEffects: DisplayableBuffEffect[] = activeBuff.effects.map(eff => ({
                stat: eff.stat,
                value: eff.value,
                applicationType: eff.type,
                effectText: effectToText(eff)
            }));

            displayedBuffs.push({
                key: activeBuff.type.toString(),
                displayName: displayInfo.displayName,
                iconAssetKey: displayInfo.iconAssetKey,
                description: displayInfo.description,
                effects: processedEffects,
                totalDurationMinutes: definition.defaultDurationMinutes,
                remainingDurationMinutes: remainingDuration,
                isBuff: displayInfo.isBuff 
            });
        }
    }
    return displayedBuffs;
}

// ---

// src/game/display/game/data_panel/tree/treePanelReducer.ts
import { ECS, Entity } from "../../../../ECS";
import { Tree } from "../../../../logic/trees/Tree";
import { HarvestableComponent, ResourceDrop } from "../../../../logic/trees/HarvestableComponent";
import { ForagableComponent } from "../../../../logic/foraging/ForagableComponent";
import { ResourceType } from "../../../../logic/resources/ResourceType";
import { PlantSpriteKey } from "../../../setup/SpriteLibrary";
import { InteractionSlots, SlotType } from "../../../../components/InteractionSlots";

export interface TreeHarvestableUIData {
  hitpointsCurrent: number;
  hitpointsMax: number;
  yield: ResourceDrop[];
  isSelectedForCutting: boolean;
  isBeingCut: boolean;
}

export interface TreeForagableUIData {
  resourceType: ResourceType;
  currentAmount: number;
  maxAmount: number;
  regenRatePerMinute: number;
  yieldPerMinute: number;
}

export interface TreePanelUIData {
  id: Entity;
  treeType: PlantSpriteKey | string;
  displayName: string;

  harvestableInfo?: TreeHarvestableUIData;
  foragableInfo?: TreeForagableUIData;
}

function deriveDisplayName(treeType: PlantSpriteKey | string): string {
    const name = treeType.toString().replace(/([A-Z0-9])/g, ' $1').replace(/^./, str => str.toUpperCase()).replace(/ (Tree|Bush)/g, '$1').trim();
    return name.includes("Tree") || name.includes("Bush") ? name : `Tree (${name})`;
}

export function treePanelReducer(entity: Entity, ecs: ECS): TreePanelUIData | null {
    if (!ecs.hasEntity(entity)) return null;

    const tree = ecs.getComponent(entity, Tree);
    if (!tree) {
        return null;
    }

    const displayName = deriveDisplayName(tree.type);
    const baseData: TreePanelUIData = {
        id: entity,
        treeType: tree.type,
        displayName: displayName,
    };

    const harvestable = ecs.getComponent(entity, HarvestableComponent);
    if (!harvestable) {
        return baseData; // No harvestable data, return basic info
    }

    const isBeingCut = !!(ecs.getComponent(entity, InteractionSlots)?.inUse(SlotType.WORK));

    if (harvestable) {
        baseData.harvestableInfo = {
            hitpointsCurrent: Math.max(0, Math.floor(harvestable.amount)),
            hitpointsMax: harvestable.maxAmount,
            yield: harvestable.drops,
            isSelectedForCutting: tree.selectedForCutting,
            isBeingCut: isBeingCut
        };
    }

    const foragable = ecs.getComponent(entity, ForagableComponent);
    if (foragable) {
        baseData.foragableInfo = {
            resourceType: foragable.resourceType,
            currentAmount: foragable.currentAmount,
            maxAmount: foragable.maxAmount,
            regenRatePerMinute: foragable.regenRatePerMinute,
            yieldPerMinute: foragable.yieldPerMinute,
        };
    }
    
    return baseData;
}

// ---

import { Pos } from "../../../../utils/Math";
import Container = Phaser.GameObjects.Container;
import Graphics = Phaser.GameObjects.Graphics;

export type Position = "top" | "bottom" | "left" | "right";
export type Direction = "horizontal" | "vertical";

export interface ValueRef {
  current: number;
  max: number;
}

export interface SizeConfig {
  minWidth: number;
  maxWidth: number;
  minWidthValue: number;
  maxWidthValue: number;
}

export interface BorderConfig {
  color: number;
  thickness: number;
  radius?: number;
  opacity?: number;
}

export interface ProgressBarConfig {
  position: Position;
  offset: number;
  valueRef: ValueRef;
  size: SizeConfig;
  fillColor?: number;
  backgroundColor?: number;
  direction?: Direction;
  border?: BorderConfig;
}

export class ProgressBar {
  private container: Container;
  private graphics: Graphics;
  private config: Required<Omit<ProgressBarConfig, 'border'>> & { border?: BorderConfig };

  private isVisible: boolean = true;
  private anchorPos = { x: 0, y: 0 };
  private displayWidth: number = 32;
  private displayHeight: number = 32;

  private lastValue: number = -1;
  private lastMax: number = -1;
  private lastVisible: boolean = true;

  constructor(container: Container, config: ProgressBarConfig) {
    this.container = container;
    const direction: Direction =
      config.direction ?? (config.position === "left" || config.position === "right" ? "vertical" : "horizontal");

    this.config = {
      direction,
      fillColor: 0x00ff00,
      backgroundColor: 0x000000,
      ...config
    };

    this.graphics = container.scene.add.graphics();
    this.container.add(this.graphics);
    
    const sprite = container.list.find(obj => obj instanceof Phaser.GameObjects.Sprite) as Phaser.GameObjects.Sprite;
    if (sprite) {
      this.displayWidth = sprite.displayWidth;
      this.displayHeight = sprite.displayHeight;
    }
  }

  destroy(): void {
    this.graphics.destroy();
  }

  hide(): void {
    this.isVisible = false;
    this.graphics.setVisible(false);
  }

  show(): void {
    this.isVisible = true;
    this.graphics.setVisible(true);
  }

  update(delta: number, position:Pos): void {
    if (!this.isVisible || !this.config.valueRef) return;

    const { current, max } = this.config.valueRef;
    if (current === this.lastValue && max === this.lastMax && this.isVisible === this.lastVisible) return;

    this.lastValue = current;
    this.lastMax = max;
    this.lastVisible = this.isVisible;

    const { minWidth, maxWidth, minWidthValue, maxWidthValue } = this.config.size;
    const { fillColor, backgroundColor, direction, border } = this.config;

    const thickness = 6;
    const barLength = this.calculateWidth(max, minWidthValue, maxWidthValue, minWidth, maxWidth);
    const progress = Phaser.Math.Clamp(current / (max || 1), 0, 1);

    this.updateDisplaySize();
    this.getAnchorPosition(barLength, thickness);
    this.anchorPos.x += position.x;
    this.anchorPos.y += position.y;
    
    this.graphics.clear();

    // Border
    if (border) {
      this.graphics.fillStyle(border.color, border.opacity ?? 1);
      const radius = border.radius ?? 0;
      if (direction === "horizontal") {
        this.drawRoundedRect(
            this.anchorPos.x - border.thickness,
            this.anchorPos.y - border.thickness,
            barLength + 2 * border.thickness,
            thickness + 2 * border.thickness,
            radius
        );
      } else {
        this.drawRoundedRect(
            this.anchorPos.x - border.thickness,
            this.anchorPos.y - border.thickness,
            thickness + 2 * border.thickness,
            barLength + 2 * border.thickness,
            radius
        );
      }
    }

    // Background
    this.graphics.fillStyle(backgroundColor, 0.5);
    if (direction === "horizontal") {
      this.drawRoundedRect(this.anchorPos.x, this.anchorPos.y, barLength, thickness, 0);
    } else {
      this.drawRoundedRect(this.anchorPos.x, this.anchorPos.y, thickness, barLength, 0);
    }

    // Foreground
    this.graphics.fillStyle(fillColor, 1);
    if (direction === "horizontal") {
      this.drawRoundedRect(this.anchorPos.x, this.anchorPos.y, barLength * progress, thickness, 0);
    } else {
      const filled = barLength * progress;
      this.drawRoundedRect(this.anchorPos.x, this.anchorPos.y + (barLength - filled), thickness, filled, 0);
    }
  }

  private drawRoundedRect(x: number, y: number, w: number, h: number, r: number) {
    r > 0 ? this.graphics.fillRoundedRect(x, y, w, h, r) : this.graphics.fillRect(x, y, w, h);
  }

  private calculateWidth(value: number, minV: number, maxV: number, minW: number, maxW: number): number {
    if (value <= minV) return minW;
    if (value >= maxV) return maxW;
    const t = (Math.log(value) - Math.log(minV)) / (Math.log(maxV) - Math.log(minV));
    return minW + t * (maxW - minW);
  }

  private getAnchorPosition(length: number, thickness: number): void {
    const { position } = this.config;
    const { x: cx, y: cy } = this.container;
    const offset = this.config.offset;
    const halfW = this.displayWidth / 2;
    const halfH = this.displayHeight / 2;

    switch (position) {
      case "top":
        this.anchorPos.x = cx - length / 2;
        this.anchorPos.y = cy - halfH - offset - thickness;
        break;
      case "bottom":
        this.anchorPos.x = cx - length / 2;
        this.anchorPos.y = cy + halfH + offset;
        break;
      case "left":
        this.anchorPos.x = cx - halfW - offset - thickness;
        this.anchorPos.y = cy - length / 2;
        break;
      case "right":
        this.anchorPos.x = cx + halfW + offset;
        this.anchorPos.y = cy - length / 2;
        break;
    }
  }

  private updateDisplaySize(): void {
    const sprite = this.container.list.find(obj => obj instanceof Phaser.GameObjects.Sprite) as Phaser.GameObjects.Sprite;
    if (sprite) {
      this.displayWidth = sprite.displayWidth;
      this.displayHeight = sprite.displayHeight;
    }
  }
}

export const harvestBarConfig: ProgressBarConfig = {
  position: "left",
  offset: 50,
  valueRef: { current: 0, max: 1 },
  size: {
    minWidth: 20,
    maxWidth: 120,
    minWidthValue: 0.1,
    maxWidthValue: 1
  },
  fillColor: 0xffaa00,
  backgroundColor: 0x111111,
  border: {
    color: 0xffffff,
    thickness: 2,
    radius: 6,
    opacity: 0.8
  }
};


// ---

import { View } from "../../setup/View";
import { EffectInstance } from "../../setup/ViewEffectController";


export interface ShudderEffectConfig {
  interval: number;  // ms between shakes
  duration: number;  // ms shake duration
  strength: number;  // max shake distance in px
}

export class ShudderEffect implements EffectInstance {
  private sprite: Phaser.GameObjects.Sprite | undefined;
  private readonly interval: number;
  private readonly duration: number;
  private readonly strength: number;

  private timer = 0;
  private elapsed = 0;
  private isShaking = false;
  private originalX = 0;
  timeScale: number = 1;

  constructor(private view: View, config: ShudderEffectConfig) {
    this.sprite = view.getSprite?.();
    this.interval = config.interval;
    this.duration = config.duration;
    this.strength = config.strength;

    if (this.sprite) {
      this.originalX = this.sprite.x;
    }
  }

  start(): void {
    this.timer = 0;
    this.elapsed = 0;
    this.isShaking = false;
    if (this.sprite) {
      this.originalX = this.sprite.x;
    }
  }

  stop(): void {
    if (this.sprite) {
      this.sprite.x = this.originalX;
    }
  }

  setSpeed(speed: number): void {
    this.timeScale = speed;
  }
  
  update(delta: number): void {
    if (!this.sprite) return;

    this.timer += delta * this.timeScale;

    if (!this.isShaking && this.timer >= this.interval) {
      this.isShaking = true;
      this.elapsed = 0;
      this.timer = 0;
    }

    if (this.isShaking) {
      this.elapsed += delta;
      const t = Math.min(this.elapsed / this.duration, 1);
      const fade = 1 - t;

      this.sprite.x = this.originalX + (Math.random() - 0.5) * 2 * this.strength * fade;

      if (t >= 1) {
        this.sprite.x = this.originalX;
        this.isShaking = false;
      }
    }
  }
}


// ---

import { GameDisplayContext } from "../../GameDisplay.ts";
import { DisplayModule } from "../../setup/DisplayModule.ts";
import { TimeComponent } from "../../../logic/time/TimeComponent.ts";
import { TimeConfig } from "../../../config/TimeConfig.ts";
import { getColorForMinute } from "../time_tint/getColorForMinute.ts";
import { Config } from "../../../config/Config.ts";
import { WeatherComponent } from "../../../logic/weather/WeatherComponent.ts";
import { getWorldEntity } from "../../../logic/serialization/getWorldEntity.ts";

interface CloudLayerConfig {
    speed: number;
    preferredSprites: { key: string; weight: number }[];
    tintOffset: number;
    yOffset: number;
    ySpread: number;
    baseDensity: number;
    scaleMin: number;
    scaleMax: number;
    direction: 1 | -1;
}

interface CloudEntry {
    sprite: Phaser.GameObjects.Image;
    layerIndex: number;
}

export const CLOUD_TINT_GRADIENT: [number, number][] = [
    [0.0, 0x445566],
    [0.375, 0xf8f8ff],
    [0.5, 0xffffff],
    [0.875, 0xf8f8ff],
    [1.0, 0x445566],
];

function createCloudLayer(overrides: Partial<CloudLayerConfig>): CloudLayerConfig {
    return {
        speed: 0.5,
        preferredSprites: [{ key: "cloud0", weight: 1 }],
        tintOffset: 0.0,
        yOffset: 0,
        ySpread: 1200,
        baseDensity: 20,
        scaleMin: 1.0,
        scaleMax: 3.0,
        direction: 1,
        ...overrides,
    };
}

const CLOUD_LAYERS: CloudLayerConfig[] = [
    createCloudLayer({
        speed: 0.2,
        preferredSprites: [{ key: "cloud1", weight: 3 }, { key: "cloud0", weight: 1 }],
        tintOffset: 0,
        yOffset: 300,
    }),
    createCloudLayer({
        speed: 0.4,
        preferredSprites: [{ key: "cloud3", weight: 2 }, { key: "cloud0", weight: 2 }],
        tintOffset: 0.05,
        yOffset: 1200,
    }),
    createCloudLayer({
        speed: 0.8,
        preferredSprites: [{ key: "cloud0", weight: 4 }],
        tintOffset: 0.1,
        yOffset: 2200,
    }),
];

export class CloudsModule extends DisplayModule<GameDisplayContext> {
    private worldEntity!: number;
    private context!: GameDisplayContext;
    private containers: Phaser.GameObjects.Container[] = [];
    private cloudsByLayer: CloudEntry[][] = [];
    private outThreshold = 1000;
    private sceneWidth = 0;

    init(context: GameDisplayContext): void {
        this.context = context;
        const { scene, ecs, layers } = context;
        this.worldEntity = getWorldEntity(ecs);
        this.sceneWidth = scene.scale.width * 2 * Config.Camera.MaxZoom;

        CLOUD_LAYERS.forEach((layer, index) => {
            const container = scene.add.container();
            container.setDepth(-925 + index);
            layers.Sky.add(container);

            const clouds: CloudEntry[] = [];
            const spacing = this.sceneWidth / layer.baseDensity;
            const phaseOffset = (index / CLOUD_LAYERS.length) * spacing;

            for (let i = 0; i < layer.baseDensity; i++) {
                const sprite = this.spawnCloud(layer, scene);

                // Phase offset prevents same x positions between layers
                sprite.x = (i * spacing + phaseOffset) % this.sceneWidth;

                sprite.y = layer.yOffset + (Math.random() - 0.5) * layer.ySpread;
                container.add(sprite);
                clouds.push({ sprite, layerIndex:index });
            }


            this.containers.push(container);
            this.cloudsByLayer.push(clouds);
        });
    }

    update(delta: number): void {
        const { ecs } = this.context;
        const time = ecs.getComponent(this.worldEntity, TimeComponent);
        const weather = ecs.getComponent(this.worldEntity, WeatherComponent);

        const total = TimeConfig.HoursPerDay * TimeConfig.MinutesPerHour;
        const minute = time.hour * TimeConfig.MinutesPerHour + time.minute;
        const speedFactor = time.speedFactor ?? 1;
        const cloudCover = weather.cloudCover ?? 1;
        const windDir = weather.windDirection ?? 1;
        const effectiveSpeed = (weather.windStrength / TimeConfig.MinutesPerHour) * speedFactor * windDir;

        CLOUD_LAYERS.forEach((layer, layerIndex) => {
            this.updateLayer(layer, layerIndex, cloudCover, effectiveSpeed, windDir, minute, total, delta, speedFactor);
        });
    }

    private updateLayer(
        layer: CloudLayerConfig,
        layerIndex: number,
        cloudCover: number,
        effectiveSpeed: number,
        windDir: 1 | -1,
        minute: number,
        total: number,
        delta: number,
        speedFactor: number
    ) {
        const clouds = this.cloudsByLayer[layerIndex];
        const targetCount = Math.floor(layer.baseDensity * cloudCover);

        let activeCount = 0;

        for (let i = 0; i < clouds.length; i++) {
            const { sprite } = clouds[i];

            const becameVisible = this.updateCloud(
                sprite,
                activeCount < targetCount,
                layer,
                layerIndex,
                effectiveSpeed,
                windDir,
                minute,
                total,
                delta,
                speedFactor
            );

            if (becameVisible) {
                activeCount++;
            }
        }
    }

    private updateCloud(
        sprite: Phaser.GameObjects.Image,
        canBeActive: boolean,
        layer: CloudLayerConfig,
        layerIndex: number,
        effectiveSpeed: number,
        windDir: 1 | -1,
        minute: number,
        total: number,
        delta: number,
        speedFactor: number
    ): boolean {
        let becameVisible = false;

        // Move always
        sprite.x += (delta * 0.01 * effectiveSpeed);

        // Drift
        const drift = Math.sin(sprite.x * 0.00025 + layerIndex) * 0.05 * speedFactor;
        sprite.y -= drift;

        const outLeft = sprite.x < -this.outThreshold;
        const outRight = sprite.x > this.sceneWidth + this.outThreshold;
        const isOut = outLeft || outRight;

        if (isOut) {
            if (canBeActive) {
                // Re-enter
                const baseOffset = layerIndex * 20;
                const jitter = (Math.random() - 0.5) * 30;
                const offset = baseOffset + jitter;

                sprite.x = windDir === 1
                    ? -this.outThreshold + offset
                    : this.sceneWidth + this.outThreshold - offset;

                sprite.y = layer.yOffset + (Math.random() - 0.5) * layer.ySpread;

                if (!sprite.visible) {
                    sprite.setVisible(true);
                    becameVisible = true;
                }
            } else {
                sprite.setVisible(false);
            }
        } else if (!sprite.visible && canBeActive && this.shouldReenter(sprite, windDir)) {
            sprite.setVisible(true);
            becameVisible = true;
        }

        // Tint always
        const adjusted = (minute + layer.tintOffset * total) % total;
        sprite.setTint(getColorForMinute(adjusted, total, CLOUD_TINT_GRADIENT));

        return sprite.visible && becameVisible;
    }


    private shouldReenter(sprite: Phaser.GameObjects.Image, windDir: 1 | -1): boolean {
        const halfWidth = sprite.displayWidth / 2;

        if (windDir === 1) {
            // Entering from left → right
            const rightEdge = sprite.x + halfWidth;
            return rightEdge >= 0 && rightEdge <= this.outThreshold;
        } else {
            // Entering from right → left
            const leftEdge = sprite.x - halfWidth;
            return leftEdge <= this.sceneWidth && leftEdge >= this.sceneWidth - this.outThreshold;
        }
    }


    destroy(): void {
        this.cloudsByLayer.flat().forEach(c => c.sprite.destroy());
        this.containers.forEach(c => c.destroy());
        this.cloudsByLayer = [];
        this.containers = [];
    }

    private spawnCloud(layer: CloudLayerConfig, scene: Phaser.Scene): Phaser.GameObjects.Image {
        const spriteKey = this.chooseWeighted(layer.preferredSprites);
        const sprite = scene.add.image(0, 0, spriteKey);
        const scale = Phaser.Math.FloatBetween(layer.scaleMin, layer.scaleMax);
        sprite.setAlpha(0.8);
        sprite.setScale(scale);
        sprite.y = layer.yOffset + (Math.random() - 0.5) * layer.ySpread;
        return sprite;
    }

    private chooseWeighted(prefs: { key: string; weight: number }[]): string {
        const total = prefs.reduce((sum, p) => sum + p.weight, 0);
        let r = Math.random() * total;
        for (const p of prefs) {
            if (r < p.weight) return p.key;
            r -= p.weight;
        }
        return prefs[0].key;
    }
}


// ---

import {TimeComponent} from "../../../logic/time/TimeComponent.ts";
import {GameDisplayContext} from "../../GameDisplay.ts";
import {Entity} from "../../../ECS.ts";
import {DisplayModule} from "../../setup/DisplayModule.ts";
import {TimeConfig} from "../../../config/TimeConfig.ts";
import {Config} from "../../../config/Config.ts";
import {getColorForMinute, SKY_TINT_GRADIENT} from "../time_tint/getColorForMinute.ts";
import { getWorldEntity } from "../../../logic/serialization/getWorldEntity.ts";

export class SkyDisplayModule extends DisplayModule<GameDisplayContext> {
    private background!: Phaser.GameObjects.Rectangle;
    private worldEntity!: Entity;
    private context!: GameDisplayContext;
    init(context: GameDisplayContext): void {
        this.context = context;
        const { scene, ecs } = context;

        this.worldEntity = getWorldEntity(ecs);
        const w = (scene.scale.width*Config.Camera.MaxZoom) + 200;
        const h = (scene.scale.height*Config.Camera.MaxZoom)  + 200;
        this.background = scene.add
            .rectangle(0, 0, w, h, 0x000000)
            .setOrigin(0.5, 0.5)
            .setScrollFactor(0)
            .setDepth(-1000);

        context.layers.Sky.add(this.background);

        scene.scale.on("resize", () => {
            this.background.setSize(scene.scale.width, scene.scale.height);
        });
    }

    update(_: number): void {
        const time = this.context.ecs.getComponent(this.worldEntity, TimeComponent);
        
        if (!time){
            return;
        }
        
        const minutesInDay = TimeConfig.HoursPerDay * TimeConfig.MinutesPerHour;
        const currentMinute =
            time.hour * TimeConfig.MinutesPerHour + time.minute;

        const color = getColorForMinute(currentMinute, minutesInDay, SKY_TINT_GRADIENT);
        this.background.setFillStyle(color, 1);
    }

    destroy(): void {
        this.background?.destroy();
    }
}


// ---

import {GameDisplayContext} from "../../GameDisplay.ts";
import {DisplayModule} from "../../setup/DisplayModule.ts";
import {TimeComponent} from "../../../logic/time/TimeComponent.ts";
import {TimeConfig} from "../../../config/TimeConfig.ts";
import {Config} from "../../../config/Config.ts";
import { getWorldEntity } from "../../../logic/serialization/getWorldEntity.ts";

export class StarfieldModule extends DisplayModule<GameDisplayContext> {
    private starContainer!: Phaser.GameObjects.Container;
    private starBackground!: Phaser.GameObjects.Image;
    private stars: Phaser.GameObjects.Graphics[] = [];
    private starOffsets: number[] = [];
    private worldEntity!: number;
    private starCount = 120;
    private scene!: Phaser.Scene;
    private context!: GameDisplayContext;
    private center!: Phaser.Math.Vector2;

    init(context: GameDisplayContext): void {
        this.context = context;
        const { scene, layers, ecs } = context;
        this.scene = scene;

        this.worldEntity = getWorldEntity(ecs);

        const camera = scene.cameras.main;
        const width = camera.width * Config.Camera.MaxZoom;
        const height = camera.height * Config.Camera.MaxZoom;

        this.center = new Phaser.Math.Vector2(camera.scrollX + width / 2, camera.scrollY + height / 3);

        // Main container centered in the sky
        this.starContainer = scene.add.container(this.center.x, this.center.y);
        this.starContainer.setDepth(-950);
        layers.Sky.add(this.starContainer);

        // Milky Way background image (rotates with stars)
        this.starBackground = scene.add.image(0, 0, 'night_sky');
        this.starBackground.setOrigin(0.5);
        this.starBackground.setAlpha(0.6);
        this.starBackground.setScale(13); // Adjust scale if needed
        this.starContainer.add(this.starBackground);

        // Add twinkling stars in front
        for (let i = 0; i < this.starCount; i++) {
            const g = scene.add.graphics();
            g.fillStyle(0xffffff, 1);

            const radius = Math.random() * width * 0.6;
            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            const r = Math.random() * 2.5 + .5;

            g.fillCircle(0, 0, r);
            g.x = x;
            g.y = y;

            this.starContainer.add(g);
            this.stars.push(g);
            this.starOffsets.push(angle);
        }
    }

    update(): void {
        const time = this.context.ecs.getComponent(this.worldEntity, TimeComponent);
        const total = TimeConfig.HoursPerDay * TimeConfig.MinutesPerHour;
        const currentMinute = time.hour * TimeConfig.MinutesPerHour + time.minute;
        const baseAlpha = getNightAlpha(currentMinute, total);
        const zoom = this.scene.cameras.main.zoom;
        const timeSec = this.scene.time.now / 1000;

        // Rotate full circle over the day
        const t = currentMinute / total;
        this.starContainer.rotation = t * Math.PI * 2;

        for (let i = 0; i < this.stars.length; i++) {
            const star = this.stars[i];
            const offset = this.starOffsets[i];
            const twinkle = 0.85 + 0.15 * Math.sin(timeSec * 12 + offset) * Math.sin(timeSec * 7 + offset * 1.3);

            star.setAlpha(baseAlpha * twinkle);
            star.setScale(1 / zoom); // visual size constant
        }

        // Fade background in/out with stars
        this.starBackground.setAlpha(baseAlpha * 0.6);
    }

    destroy(): void {
        for (const star of this.stars) {
            star.destroy();
        }
        this.stars = [];
        this.starOffsets = [];

        this.starBackground?.destroy();
        this.starContainer?.destroy();
    }
}

function getNightAlpha(minute: number, total: number): number {
    const t = (minute % total) / total;

    if (t < 0.25 || t > 0.875) return 1; // full night
    if (t < 0.375) return 1 - (t - 0.25) * 8; // fade out at dawn
    if (t > 0.75) return (t - 0.75) * 8;      // fade in at dusk

    return 0;
}



// ---

import {GameDisplayContext} from "../../GameDisplay.ts";
import {DisplayModule} from "../../setup/DisplayModule.ts";
import {TimeComponent} from "../../../logic/time/TimeComponent.ts";
import {WeatherComponent} from "../../../logic/weather/WeatherComponent.ts";
import {updateTimeTintPipeline} from "./updateTimeTintPineline.ts";
import { getWorldEntity } from "../../../logic/serialization/getWorldEntity.ts";

export class TinterModule extends DisplayModule<GameDisplayContext> {
    private worldEntity!: number;
    private context!: GameDisplayContext;
    
    init(context: GameDisplayContext): void {
        this.context = context;
        const { ecs } = context;

        this.worldEntity = getWorldEntity(ecs);
    }

    update(_: number): void {
        const { ecs, scene } = this.context;
        const time = ecs.getComponent(this.worldEntity, TimeComponent);
        const weather = ecs.getComponent(this.worldEntity, WeatherComponent);
        updateTimeTintPipeline(scene, time, weather);
    }

    destroy(): void {
    }
}


// ---

import {View} from "../../setup/View.ts";
import {getColorForMinute, SPRITE_TINT_GRADIENT} from "./getColorForMinute.ts";


export class ViewTinter {
    private views = new Set<View>();

    add(view: View): void {
        this.views.add(view);
    }

    remove(view: View): void {
        this.views.delete(view);
    }

    clear(): void {
        this.views.clear();
    }

    update(minute: number, totalMinutesInDay: number): void {
        const color = getColorForMinute(minute, totalMinutesInDay, SPRITE_TINT_GRADIENT);

        for (const view of this.views) {
            view.getSprite()?.setTint(color);
        }
    }
}

// ---

import {lerpColor} from "../../../../utils/Color.ts";

export const SKY_TINT_GRADIENT: [number, number][] = [
    [0.0, 0x0a0a2a],   // midnight
    [0.1, 0x0a0a2a],  // still night
    [0.2, 0xffcc88], // dawn
    [0.3, 0x99ccff], // day
    [0.5, 0x99ccff],   // full day
    [0.75, 0x99ccff],  // hold daylight
    [0.875, 0xff9966], // dusk
    [1.0, 0x0a0a2a],   // back to night
];

export const SPRITE_TINT_GRADIENT: [number, number][] = [
    [0.0, 0x4c5b88],   // deep night
    [0.1, 0x4c5b88],  // night holds
    [0.25, 0xfff2cc], // dawn
    [0.5, 0xffffff],   // full day
    [0.75, 0xffffff],  // hold day
    [0.875, 0xfff2cc], // dusk
    [1.0, 0x4c5b88],   // back to night
];


export function getColorForMinute(
    minute: number,
    total: number,
    gradient: [number, number][]
): number {
    const t = (minute % total) / total;

    for (let i = 0; i < gradient.length - 1; i++) {
        const [t1, c1] = gradient[i];
        const [t2, c2] = gradient[i + 1];

        if (t >= t1 && t <= t2) {
            const factor = (t - t1) / (t2 - t1);
            return lerpColor(c1, c2, factor);
        }
    }

    return gradient[0][1]; // fallback
}


// ---

import {TimeComponent} from "../../../logic/time/TimeComponent.ts";
import {WeatherComponent} from "../../../logic/weather/WeatherComponent.ts";
import {TimeTintPipeline} from "../../../../render/pipelines/TimeTintPipeline.ts";
import {TimeConfig} from "../../../config/TimeConfig.ts";
import {getColorForMinute, SPRITE_TINT_GRADIENT} from "./getColorForMinute.ts";

/**
 * Updates the TimeTintPipeline with time of day, cloud cover, and optional lighting.
 */
export function updateTimeTintPipeline(
    scene: Phaser.Scene,
    time: TimeComponent,
    weather: WeatherComponent
): void {
    const renderer = scene.renderer as Phaser.Renderer.WebGL.WebGLRenderer;
    const pipeline = renderer.pipelines.get('TimeTint') as TimeTintPipeline;

    const minute = time.hour * TimeConfig.MinutesPerHour + time.minute;
    const total = TimeConfig.HoursPerDay * TimeConfig.MinutesPerHour;

    const color = getColorForMinute(minute, total, SPRITE_TINT_GRADIENT);
    pipeline.setTintColor(Phaser.Display.Color.ValueToColor(color));
    pipeline.setCloudAlpha(1 - ((weather.cloudCover ?? 0))*.5);
    pipeline.setResolution(scene.scale.width, scene.scale.height);

    // Optional lighting RT (e.g. scene.lightingRT)
    const lightingRT = (scene as any).lightingRT as Phaser.GameObjects.RenderTexture | undefined;
    const glTex = (lightingRT as any)?._renderer?.glTexture;

    pipeline.setLightingTexture(glTex ?? null);
}


// ---

import { EventBus } from "../../../EventBus";
import { GameEvent } from "../../../consts/GameEvent";
import { UIEvent } from "../../../consts/UIEvent";
import { GameDisplayContext } from "../../GameDisplay";
import { DisplayModule } from "../../setup/DisplayModule";
import { RightClickHandler } from "../../utils/RightClickHandler";
import { SelectionTool } from "./selection/SelectionTool";
import { TreeCutSelectionTool } from "./trees/TreeCutSelectionTool";

export enum ToolType {
    None = "none",
    Selection = "selection",
    TreeCutting = "tree_cutting"
}

export interface ITool {
    start(): void;
    stop(): void;
    type: ToolType;
}

export type Tool = ITool & DisplayModule<GameDisplayContext>;

export class GameTools extends DisplayModule<GameDisplayContext> {
    private context!: GameDisplayContext;
    private modules: Tool[] = [new SelectionTool(), new TreeCutSelectionTool()];
    private activeTool: ToolType = ToolType.None;
    private awaitingReset: boolean = false;
    private rClickHandler!: RightClickHandler;

    init(context: GameDisplayContext): void {
        this.context = context;
        this.modules.forEach(module => {
            module.init(context);
        });

        EventBus.on(GameEvent.ToolSelected, this.handleToolSelected, this);
        EventBus.emit(GameEvent.ToolSelected, ToolType.Selection);

        this.rClickHandler = new RightClickHandler(this.handleRightClick.bind(this));
        this.rClickHandler.start();
    }

    handleRightClick(){
        this.awaitingReset = true;
    }

    handleToolSelected(toolType: ToolType): void {
        if (this.activeTool == toolType) {
            if (this.activeTool != ToolType.Selection) {
                this.awaitingReset = true;
            }
            return;
        }

        this.activeTool = toolType;

        this.modules.forEach(module => {
            if (module.type === toolType) {
                module.start();
            } else {
                module.stop();
            }
        });
    }

    update(delta: number): void {
        if (this.awaitingReset) {
            EventBus.emit(GameEvent.ToolSelected, ToolType.Selection);
            this.awaitingReset = false;
        }
    }

    destroy(): void {
        // Clean up if necessary
        this.context = null!;
        this.modules.forEach(module => {
            module.destroy();
        });
        EventBus.off(GameEvent.ToolSelected, this.handleToolSelected, this);
        this.rClickHandler.stop();
    }
}

// ---

import { DisplayModule } from "../../../setup/DisplayModule.ts";
import { GameDisplayContext } from "../../../GameDisplay.ts";
import { GameEvent } from "../../../../consts/GameEvent.ts";
import { EventBus } from "../../../../EventBus.ts";
import OutlinePipelinePlugin from "phaser3-rex-plugins/plugins/outlinepipeline-plugin.js";

const OUTLINE_CONFIG = {
    thickness: 2,
    outlineColor: 0xd4a857,
    quality: 0.2,
};

export class SelectionHighlightModule extends DisplayModule<GameDisplayContext> {
    private context!: GameDisplayContext;
    private selected: number = -1;
    private outlinePlugin!: OutlinePipelinePlugin;

    init(context: GameDisplayContext): void {
        this.context = context;
        this.outlinePlugin = context.scene.plugins.get('rexOutlinePipeline') as OutlinePipelinePlugin;

        EventBus.on(GameEvent.SelectionChanged, this.handleSelectionChanged, this);
    }

    destroy(): void {
        EventBus.off(GameEvent.SelectionChanged, this.handleSelectionChanged, this);
        this.clearOutline();
    }

    update(): void {}

    private handleSelectionChanged(entity: number): void {
        if (entity === this.selected) return;

        this.clearOutline();
        this.selected = entity;

        if (entity === -1) return;

        const view = this.context.viewsByEntity.get(entity);
        if (!view) return;

        this.outlinePlugin.add(view.viewContainer, OUTLINE_CONFIG);

        EventBus.emit(GameEvent.ViewSelected, view.viewContainer);
    }

    private clearOutline(): void {
        if (this.selected === -1) return;

        const prev = this.context.viewsByEntity.get(this.selected);
        if (prev) {
            this.outlinePlugin.remove(prev.viewContainer);
        }

        this.selected = -1;
    }
}


// ---

import { DisplayModule } from "../../../setup/DisplayModule.ts";
import { GameDisplayContext } from "../../../GameDisplay.ts";
import { GameEvent } from "../../../../consts/GameEvent.ts";
import { EventBus } from "../../../../EventBus.ts";
import { ITool, ToolType } from "../GameTools.ts";
import { UIEvent } from "../../../../consts/UIEvent.ts";
import { ClickThresholdHandler } from "../../../utils/ClickThresholdHandler.ts";
import { AlphaSampler } from "../../../utils/AlphaSampler.ts";

export class SelectionTool extends DisplayModule<GameDisplayContext> implements ITool {
  type: ToolType = ToolType.Selection;
  private context!: GameDisplayContext;
  private cycleStack: number[] = [];
  private cycleIndex = 0;
  private clickHandler!: ClickThresholdHandler;
  private alphaSampler!: AlphaSampler;

  init(context: GameDisplayContext): void {
    this.context = context;
    this.alphaSampler = new AlphaSampler(context.scene);
    this.clickHandler = new ClickThresholdHandler(
      context.scene,
      this.handleClick.bind(this),
      5
    );
  }

  start(): void {
    this.clickHandler.start();
    EventBus.on(UIEvent.PortraitClicked, this.onPortraitClicked, this);
  }

  stop(): void {
    this.clickHandler.stop();
    EventBus.off(UIEvent.PortraitClicked, this.onPortraitClicked, this);
  }

  destroy(): void {
    this.clickHandler.stop();
    this.alphaSampler.destroy();
  }

  update(): void {}

  private onPortraitClicked(selected: number): void {
    EventBus.emit(GameEvent.SelectionChanged, selected);
  }

  private async handleClick(pointer: Phaser.Input.Pointer): Promise<void> {
    const camera = this.context.scene.cameras.main;
    const worldPoint = pointer.positionToCamera(camera) as Phaser.Math.Vector2;

    const allViews = [...this.context.viewsByEntity.entries()];
    const overlapping: number[] = [];

    for (const [entity, view] of allViews) {
      const sprite = view.getSprite();
      if (!view.selectable || !sprite?.input?.enabled) continue;

      const bounds = sprite.getBounds();
      if (!bounds.contains(worldPoint.x, worldPoint.y)) continue;

      const alpha = await this.alphaSampler.getAlphaAt(sprite, worldPoint.x, worldPoint.y);
      if (alpha > 0) {
        overlapping.push(entity);
      }
    }

    overlapping.sort((a, b) => {
      const va = this.context.viewsByEntity.get(a);
      const vb = this.context.viewsByEntity.get(b);
      return (vb?.getSprite()?.depth ?? 0) - (va?.getSprite()?.depth ?? 0);
    });

    if (overlapping.length === 0) {
      this.cycleStack = [];
      this.cycleIndex = 0;
      EventBus.emit(GameEvent.SelectionChanged, -1);
      return;
    }

    const sameStack = arraysEqual(overlapping, this.cycleStack);
    if (!sameStack) {
      this.cycleStack = overlapping;
      this.cycleIndex = 0;
    }

    const selected = this.cycleStack[this.cycleIndex];
    EventBus.emit(GameEvent.SelectionChanged, selected);
    this.cycleIndex = (this.cycleIndex + 1) % this.cycleStack.length;
  }
}

function arraysEqual(a: number[], b: number[]): boolean {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}


// ---

import { DisplayModule } from "../../../setup/DisplayModule.ts";
import { GameDisplayContext } from "../../../GameDisplay.ts";
import { GameEvent } from "../../../../consts/GameEvent.ts";
import { EventBus } from "../../../../EventBus.ts";
import { ITool, ToolType } from "../GameTools.ts";
import { ClickThresholdHandler } from "../../../utils/ClickThresholdHandler.ts";
import { Tree } from "../../../../logic/trees/Tree.ts";
import { AlphaSampler } from "../../../utils/AlphaSampler.ts";

export class TreeCutSelectionTool extends DisplayModule<GameDisplayContext> implements ITool {
  type: ToolType = ToolType.TreeCutting;
  private context!: GameDisplayContext;
  private clickHandler!: ClickThresholdHandler;
  private alphaSampler!: AlphaSampler;

  init(context: GameDisplayContext): void {
    this.context = context;
    this.clickHandler = new ClickThresholdHandler(
      context.scene,
      this.handleClick.bind(this),
      5
    );

    this.alphaSampler = new AlphaSampler(context.scene);
  }

  start(): void {
    this.clickHandler.start();
  }

  stop(): void {
    this.clickHandler.stop();
  }

  destroy(): void {
    this.stop();
    this.alphaSampler.destroy();
  }

  update(): void {}

  private async handleClick(pointer: Phaser.Input.Pointer): Promise<void> {
    const camera = this.context.scene.cameras.main;
    const worldPoint = pointer.positionToCamera(camera) as Phaser.Math.Vector2;
  
    const allViews = [...this.context.viewsByEntity.entries()];
    const overlapping: number[] = [];
  
    for (const [entity, view] of allViews) {
      const sprite = view.getSprite();
      if (!sprite) continue;
      if (!view.selectable || !sprite?.input?.enabled) continue;
  
      const bounds = sprite.getBounds();
      if (!bounds.contains(worldPoint.x, worldPoint.y)) continue;
  
      const alpha = await this.alphaSampler.getAlphaAt(sprite, worldPoint.x, worldPoint.y);
      if (alpha > 0) {
        overlapping.push(entity);
      }
    }
  
    overlapping.sort((a, b) => {
      const va = this.context.viewsByEntity.get(a);
      const vb = this.context.viewsByEntity.get(b);
      return (vb?.getSprite()?.depth ?? 0) - (va?.getSprite()?.depth ?? 0);
    });
  
    if (overlapping.length === 0) return;
  
    const selected = overlapping[0];
    EventBus.emit(GameEvent.TreeSelectedForCutting, selected);
  
    const tree = this.context.ecs.getComponent(selected, Tree);
    if (tree) {
      tree.selectedForCutting = !tree.selectedForCutting;
    }
  }  
}


// ---


import Phaser from "phaser";
import { ECS, Entity } from "../../../ECS";
import { Transform } from "../../../components/Transform";
import { Tree } from "../../../logic/trees/Tree";
import { GameDisplayContext } from "../../GameDisplay";
import { View } from "../../setup/View";
import { ViewDefinition, ViewType } from "../../setup/ViewDefinition";
import { ViewDisplayModule, registerViewDisplayModule } from "../../setup/ViewDisplayModule";
import { EffectType } from "../../setup/ViewEffectController";
import { createView } from "../../setup/ViewStore";

export class TreeCutIconViewModule extends ViewDisplayModule {
  init(context: GameDisplayContext): void {
    registerViewDisplayModule(this, context, context.iconsByEntity);
  }

  update(delta: number): void {
    this.tracker?.update();
  }

  destroy(): void {
    this.tracker?.destroy();
  }

  getComponentClasses(): Function[] {
    return [Transform, Tree];
  }

  getLayerContainer(): Phaser.GameObjects.Container {
    return this.context.layers.Icons;
  }

  getViewsByEntityMap(context: GameDisplayContext) {
    return context.iconsByEntity;
  }

  createDefinition(ecs: ECS, entity: Entity): ViewDefinition {
    const transform = ecs.getComponent(entity, Transform);

    return createView({
      spriteName: "axe_icon",
      position: {
        x: Math.round(transform.x),
        y: Math.round(transform.y),
      },
      frame: 0,
      type: ViewType.ICON,
      size: { x: 0.25, y: 0.25 },
    });
  }

  updateView(ecs: ECS, entity: Entity, view: View): boolean {
    const transform = ecs.getComponent(entity, Transform);
    const tree = ecs.getComponent(entity, Tree);

    view.viewContainer.x = Math.round(transform.x);
    view.viewContainer.y = Math.round(transform.y);

    const sprite = view.getSprite();
    if (sprite) sprite.visible = tree.selectedForCutting;

    return false;
  }

  createView(ecs: ECS, entity: number, views: { [key: number]: ViewDefinition; }, viewDefinition: ViewDefinition): View {
    const view = new View(viewDefinition.id, views, viewDefinition, this.context.layers.Icons, this.context.scene);
    view.applyEffect(EffectType.Red);
    return view;
  }
}


// ---

import Phaser from "phaser";

export interface TreeFallAnimationConfig {
  scene: Phaser.Scene;
  spriteKey: string;
  position: { x: number; y: number };
  size: { x: number; y: number };
  duration: number;
  direction?: number; // 1 or -1
  onComplete?: () => void;
  container?: Phaser.GameObjects.Container;
}

export class TreeFallAnimation {
  private sprite: Phaser.GameObjects.Sprite;
  private scene: Phaser.Scene;
  private tween: Phaser.Tweens.Tween;

  constructor(config: TreeFallAnimationConfig) {
    const { container, scene, spriteKey, position, size, duration, direction = Math.random() < 0.5 ? -1 : 1, onComplete } = config;

    this.scene = scene;
    this.sprite = scene.add.sprite(position.x, position.y, spriteKey);
    container?.add(this.sprite);
    this.sprite.setDisplaySize(size.x, size.y);
    this.sprite.setOrigin(0.5, 1);
    this.sprite.setPipeline("TimeTint");

    const offsetX = direction * 20;
    const rotation = direction * Phaser.Math.DegToRad(90);

    this.tween = scene.tweens.add({
      targets: this.sprite,
      x: position.x + offsetX,
      rotation: rotation,
      duration: duration,
      ease: "Sine.easeOut",
      onComplete: () => {
        onComplete?.();
      }
    });
  }

  setSpeed(speed: number): void {
    this.tween.timeScale = speed;
  }
  
  fadeOut(duration: number, onComplete?: () => void): void {
    this.scene.tweens.add({
      targets: this.sprite,
      alpha: 0,
      duration,
      ease: "Linear",
      onComplete: () => {
        this.sprite.destroy();
        onComplete?.();
      }
    });
  }
}


// ---

import {DisplayModule} from "../../setup/DisplayModule.ts";
import {GameDisplayContext} from "../../GameDisplay.ts";
import {Entity} from "../../../ECS.ts";
import {WeatherComponent} from "../../../logic/weather/WeatherComponent.ts";
import {TimeComponent} from "../../../logic/time/TimeComponent.ts";
import {SimplexNoise} from "../../../../utils/SimplexNoise.ts";
import {ViewType} from "../../setup/ViewDefinition.ts";
import { getWorldEntity } from "../../../logic/serialization/getWorldEntity.ts";

export class TreeSwayConfig {
    public static MaxRotation = Phaser.Math.DegToRad(6);
    public static SpatialFrequency = 0.001;
    public static TimeSpeed = 0.001;
}

export class TreeSwayModule extends DisplayModule<GameDisplayContext> {
    private context!: GameDisplayContext;
    private worldEntity!: Entity;
    private time = 0;
    private simplex = new SimplexNoise();

    init(context: GameDisplayContext): void {
        this.context = context;
        this.worldEntity = getWorldEntity(context.ecs);
    }

    update(delta: number): void {
        this.time += delta;
        const { ecs, viewsByEntity } = this.context;

        const timeComp = ecs.getComponent(this.worldEntity, TimeComponent);
        const weather = ecs.getComponent(this.worldEntity, WeatherComponent);

        const windStrength = Phaser.Math.Clamp(weather.windStrength ?? 0, 0, 1000) / 1000;
        const speedFactor = timeComp.speedFactor ?? 1;

        const t = this.time * TreeSwayConfig.TimeSpeed * speedFactor;
        const { SpatialFrequency: freq, MaxRotation: maxAngle } = TreeSwayConfig;

        for (const [entity, view] of viewsByEntity) {
            if (view.type !== ViewType.TREE) continue;

            const sprite = view.getSprite() as Phaser.GameObjects.Sprite;

            const sway = this.simplex.noise3D(
                sprite.x * freq,
                sprite.y * freq,
                t + entity * 1000 // phase offset by entity ID
            );

            sprite.rotation = sway * maxAngle * windStrength;
        }
    }


    destroy(): void {
        // Clean up if necessary
        this.context = null!;
        this.worldEntity = null!;
    }
}

// ---

import Phaser from "phaser";
import { ECS, Entity } from "../../../ECS";
import { Config } from "../../../config/Config";
import { Transform } from "../../../components/Transform";
import { Tree } from "../../../logic/trees/Tree";
import { HarvestableComponent } from "../../../logic/trees/HarvestableComponent";
import { View } from "../../setup/View";
import { ViewDefinition, ViewType } from "../../setup/ViewDefinition";
import { ViewDisplayModule, registerViewDisplayModule } from "../../setup/ViewDisplayModule";
import { EffectType } from "../../setup/ViewEffectController";
import { createView as createViewDefinition } from "../../setup/ViewStore";
import { GameDisplayContext } from "../../GameDisplay";
import { ProgressBarConfig, ValueRef } from "../effects/ProgressBar";
import { ShudderEffectConfig } from "../effects/ShudderEffect";
import { TreeFallAnimation } from "./TreeFallAnimation";
import { TimeComponent, getTime } from "../../../logic/time/TimeComponent";
import { InteractionSlots, SlotType } from "../../../components/InteractionSlots";

const harvestBarConfig: ProgressBarConfig = {
  position: "left",
  offset: 50,
  valueRef: { current: 0, max: 1 },
  size: {
    minWidth: 20,
    maxWidth: 120,
    minWidthValue: 0.1,
    maxWidthValue: 1
  },
  fillColor: 0xffaa00,
  backgroundColor: 0x111111,
  border: {
    color: 0xffffff,
    thickness: 2,
    radius: 6,
    opacity: 0.8
  }
};

export class TreeViewModule extends ViewDisplayModule {
  private harvestRefs: Map<number, ValueRef> = new Map();
  private fallAnimations: Map<number, TreeFallAnimation> = new Map();
  private harvested: Map<number, boolean> = new Map();

  init(context: GameDisplayContext): void {
    registerViewDisplayModule(this, context, context.viewsByEntity);
  }

  update(delta: number): void {
    this.tracker?.update();
  }

  destroy(): void {
    this.tracker?.destroy();
    for (const anim of this.fallAnimations.values()) anim.fadeOut(500);
    this.fallAnimations.clear();
  }

  getComponentClasses(): Function[] {
    return [Transform, Tree, HarvestableComponent];
  }

  getLayerContainer(): Phaser.GameObjects.Container {
    return this.context.layers.Surface;
  }

  createDefinition(ecs: ECS, entity: Entity): ViewDefinition {
    const transform = ecs.getComponent(entity, Transform);
    const tree = ecs.getComponent(entity, Tree);

    return createViewDefinition({
      spriteName: tree.type,
      position: {
        x: Math.round(transform.x),
        y: Math.round(transform.y),
      },
      frame: 0,
      type: ViewType.TREE,
    });
  }

  updateView(ecs: ECS, entity: Entity, view: View): boolean {
    const transform = ecs.getComponent(entity, Transform);
    const tree = ecs.getComponent(entity, Tree);
    const harvestable = ecs.getComponent(entity, HarvestableComponent);

    const posX = Math.round(transform.x);
    const posY = Math.round(transform.y + Config.AnimImports.FrameHeight / 2);
    const isFallen = harvestable.harvested;

    view.viewContainer.x = posX;
    view.viewContainer.y = posY;
    view.viewContainer.scaleY = isFallen ? 0 : 1;

    const slots = ecs.getComponent(entity, InteractionSlots);

    this.updateHarvestProgress(entity, harvestable, view);
    this.updateShudderEffect(!!(slots?.inUse(SlotType.WORK)), view);
    this.spawnFallAnimation(entity, tree, view, posX, posY, isFallen, () => {
      this.fallAnimations.delete(entity);
      this.harvested.set(entity, true);
    });

    const time = getTime(ecs);
    this.fallAnimations.forEach((anim, _) => {
      const speed = time.speedFactor;
      anim.setSpeed(speed);
    });
    return false;
  }

  private updateHarvestProgress(entity: number, harvestable: HarvestableComponent, view: View): void {
    if (!harvestable.harvested && harvestable.amount !== harvestable.maxAmount) {
      const valueRef = this.harvestRefs.get(entity) || { current: harvestable.amount, max: harvestable.maxAmount };
      valueRef.current = harvestable.amount;
      if (!this.harvestRefs.has(entity)) {
        this.harvestRefs.set(entity, valueRef);
        view.applyEffect(EffectType.Progress, {
          ...harvestBarConfig,
          valueRef,
          container: this.context.layers.Icons
        });
      }
    } else {
      this.harvestRefs.delete(entity);
      view.clearEffect(EffectType.Progress);
      view.clearEffect(EffectType.Shudder);
    }
  }

  private updateShudderEffect(inUse:boolean, view: View): void {
    if (inUse) {
      const fps = view.getSprite()?.scene.game.loop.actualFps || 60;
      view.applyEffect(EffectType.Shudder, {
        duration: 1 * fps,
        interval: 3 * fps,
        strength: 20
      } as ShudderEffectConfig);
    } else {
      view.clearEffect(EffectType.Shudder);
    }
  }

  private spawnFallAnimation(entity: number, tree: Tree, view: View, x: number, y: number, isFallen: boolean, onComplete:()=>void): void {
    if (!isFallen || this.fallAnimations.has(entity) || this.harvested.has(entity)) return;

    const spriteKey = tree.type;
    const anim = new TreeFallAnimation({
      container: this.context.layers.Surface,
      scene: this.context.scene,
      spriteKey,
      position: { x, y },
      size: {
        x: view.getSprite()?.displayWidth || 64,
        y: view.getSprite()?.displayHeight || 64
      },
      duration: 400,
      onComplete: () => {
        setTimeout(() => {
          anim.fadeOut(500, onComplete);
        }, 200);
      }
    });

    this.fallAnimations.set(entity, anim);
  }

  createView(ecs: ECS, entity: number, views: { [key: number]: ViewDefinition }, viewDefinition: ViewDefinition): View {
    const view = new View(viewDefinition.id, views, viewDefinition, this.context.layers.Surface, this.context.scene);
    view.applyEffect(EffectType.Shader, { shader: "TimeTint" });
    return view;
  }
}


// ---

import {ViewTracker} from "./ViewTracker.ts";
import {GameDisplayContext} from "../GameDisplay.ts";

export abstract class DisplayModule<T> {
    public abstract init(display: T, trackers?: Array<(context: GameDisplayContext)=>ViewTracker>): void;
    public abstract update(delta: number): void;
    public abstract destroy(): void;
}

// ---

import {Scene} from "phaser";

export class Layers {
    public Sky :Phaser.GameObjects.Container;
    public Ground :Phaser.GameObjects.Container;
    public Caves :Phaser.GameObjects.Container;
    public Surface :Phaser.GameObjects.Container;
    public Icons :Phaser.GameObjects.Container;
    
    constructor(scene:Scene) {
        this.Sky = scene.add.container();
        this.Ground = scene.add.container();
        this.Caves = scene.add.container();
        this.Surface = scene.add.container();
        this.Icons = scene.add.container();
    }
    
    public destroy() {
        this.Sky.destroy();
        this.Ground.destroy();
        this.Caves.destroy();
        this.Surface.destroy();
        this.Icons.destroy();
    }
}

// ---

import {Pos} from "../../../utils/Math.ts";
import {Config} from "../../config/Config.ts";

export const PlantSpriteKeys = ['tree0', 'tree1', 'tree2', 'tree3', 'tree4', 'tree5', 'bush0', 'bush1'] as const;
export type PlantSpriteKey = typeof PlantSpriteKeys[number];
export type HillSpriteKey = 'hill';
export const CaveSpriteKeys = ['cave', 'wood_dojo'] as const;
export type CaveSpriteKey = typeof CaveSpriteKeys[number];
export const CharacterKeys = ['booker_char'] as const;
export type CharacterKey = typeof CharacterKeys[number];
export type SpriteKey = PlantSpriteKey | HillSpriteKey | CaveSpriteKey | CharacterKey;

interface SpriteDefinition {
    key: SpriteKey;
    defaultSize: Pos;
    path?: string;
}

const defaultTreeSize = {x:2, y:2};
const defaultBushSize = {x:1, y:1};
const defaultCaveSize = {x:1, y:1};
const defaultHillSize = {x:1 + Config.GameWidth/Config.Display.PixelsPerUnit, y:Config.GameHeight/Config.Display.PixelsPerUnit};

export const SpriteLibrary: Record<SpriteKey, SpriteDefinition> = {
    tree0: {key: 'tree0', defaultSize: defaultTreeSize, path: 'assets/plants/tree0.png'},
    tree1: {key: 'tree1', defaultSize: defaultTreeSize, path: 'assets/plants/tree1.png'},
    tree2: {key: 'tree2', defaultSize: defaultTreeSize, path: 'assets/plants/tree2.png'},
    tree3: {key: 'tree3', defaultSize: defaultTreeSize, path: 'assets/plants/tree3.png'},
    tree4: {key: 'tree4', defaultSize: defaultTreeSize, path: 'assets/plants/tree4.png'},
    tree5: {key: 'tree5', defaultSize: defaultTreeSize, path: 'assets/plants/tree5.png'},
    bush0: {key: 'bush0', defaultSize: defaultBushSize, path: 'assets/plants/bush0.png'},
    bush1: {key: 'bush1', defaultSize: defaultBushSize, path: 'assets/plants/bush1.png'},
    hill: {key: 'hill', defaultSize: defaultHillSize, path: 'assets/hill/hill.png'},
    cave: {key: 'cave', defaultSize: defaultCaveSize, path: 'assets/hill/cave.png'},
    wood_dojo: {key: 'wood_dojo', defaultSize: defaultCaveSize, path: 'assets/hill/wood_dojo.png'},
    booker_char: {key: 'booker_char', defaultSize: {x: 0.5, y: 0.75}, path: 'assets/characters/booker_char.png'},
};

// ---

import Phaser from "phaser";
import { ViewDefinition, ViewType } from "./ViewDefinition";
import { Naming } from "../../consts/Naming";
import { Config } from "../../config/Config";
import { SpriteKey, SpriteLibrary } from "./SpriteLibrary";
import { EffectType, ViewEffectController } from "./ViewEffectController";

export class View {
  public readonly id: number;
  public readonly viewDefinition: ViewDefinition;
  public readonly viewContainer: Phaser.GameObjects.Container;
  public readonly subViews: View[] = [];

  public type = ViewType.NONE;
  public selectable = true;

  sprite: Phaser.GameObjects.Sprite;
  private readonly effects: ViewEffectController;

  constructor(
    id: number,
    views: { [key: number]: ViewDefinition },
    viewDefinition: ViewDefinition,
    parentContainer: Phaser.GameObjects.Container,
    scene: Phaser.Scene
  ) {
    this.id = id;
    this.viewDefinition = viewDefinition;
    this.type = viewDefinition.type;
    this.selectable = viewDefinition.selectable ?? true;

    viewDefinition.position.x = Math.round(viewDefinition.position.x);
    viewDefinition.position.y = Math.round(viewDefinition.position.y);

    this.viewContainer = scene.add.container(
      viewDefinition.position.x,
      viewDefinition.position.y
    );
    this.viewContainer.name = `${Naming.VIEW}${id}`;
    parentContainer.add(this.viewContainer);

    this.initSprite(scene);

    for (const subViewId of viewDefinition.subViews) {
      const subDef = views[subViewId];
      if (subDef) {
        const subView = new View(
          subViewId,
          views,
          subDef,
          this.viewContainer,
          scene
        );
        this.subViews.push(subView);
      }
    }

    this.effects = new ViewEffectController(this);
  }

  private initSprite(scene: Phaser.Scene): void {
    const { spriteName, frame, size, type } = this.viewDefinition;
    if (!spriteName) return;

    const sprite = scene.add.sprite(0, 0, spriteName);
    sprite.name = `${Naming.SPRITE}${this.id}`;
    this.viewContainer.add(sprite);

    sprite.setOrigin(0.5, type === ViewType.TREE ? 1 : 0.5);
    sprite.setFrame(frame);
    sprite.setInteractive({ useHandCursor: false });

    const defaultSize = SpriteLibrary[spriteName as SpriteKey]?.defaultSize ?? { x: 1, y: 1 };
    const pxPerUnit = Config.Display.PixelsPerUnit;
    sprite.setDisplaySize(
      defaultSize.x * pxPerUnit * size.x,
      defaultSize.y * pxPerUnit * size.y
    );

    this.sprite = sprite;
  }

  public getSprite(): Phaser.GameObjects.Sprite | undefined {
    return this.sprite;
  }

  public syncSprite(spriteName: string): void {
    if (this.viewDefinition.spriteName === spriteName) return;

    this.sprite?.destroy();

    this.viewDefinition.spriteName = spriteName;
    this.initSprite(this.viewContainer.scene);
  }

  public applyEffect(type: EffectType, opts?: any): void {
    this.effects.apply(type, opts);
  }

  public clearEffect(type: EffectType): void {
    this.effects.clear(type);
  }

  public clearAllEffects(): void {
    this.effects.clearAll();
  }

  public update(delta: number): void {
    this.effects.update(delta);
  }

  public sortSubviewsByY(): void {
    const containers = this.viewContainer.list.filter(
      obj => obj instanceof Phaser.GameObjects.Container
    ) as Phaser.GameObjects.Container[];

    containers
      .sort((a, b) => (a.y * a.scaleY - a.height / 2) - (b.y * b.scaleY - b.height / 2))
      .forEach(c => this.viewContainer.bringToTop(c));

    this.subViews.forEach(subView => subView.sortSubviewsByY());
  }

  public destroy(): void {
    this.clearAllEffects();
    this.sprite?.destroy();
    this.viewContainer.destroy();
  }
}

// ---

import {Pos} from "../../../utils/Math.ts";

export enum ViewType {
    NONE = 0,
    TREE = 1,
    CAVE = 2,
    CHARCTER = 3,
    ICON = 4,
}

export enum DisplayTraitType {
    NONE = 0,
    WOOD = 1,
    FOOD = 2
}

export enum PanelType {
    CHARACTER = "CHARACTER",
    WOOD_DOJO = "WOOD_DOJO",
    TREE = "TREE",
    CAVE = "CAVE"
}

export class DisplayTrait {
    public type: DisplayTraitType;
    public value: number;
}

export class PanelDefinition {
    public title:string;
    public description:string;
    public imagePath:string;
    public traits?: DisplayTrait[];
    actions?: PanelActionDefinition[];
    panelType: PanelType;
}

export interface PanelActionDefinition {
    label: string;
    type: string;
}

export class ViewDefinition {
    public readonly id: number;
    public spriteName: string;
    public readonly position: Pos;
    public readonly size: Pos;
    public frame: number;
    public subViews: number[];
    public type = ViewType.NONE;
    public selectable = true;
    public panelDefinition?: PanelDefinition;
}



// ---

import { ViewTracker } from "./ViewTracker";
import { ECS, Entity } from "../../ECS";
import { View } from "../setup/View";
import { ViewDefinition } from "../setup/ViewDefinition";
import { GameDisplayContext } from "../GameDisplay";
import { DisplayModule } from "./DisplayModule";

export abstract class ViewDisplayModule implements DisplayModule<GameDisplayContext> {
    tracker!: ViewTracker;
    context!: GameDisplayContext;
  
    abstract getComponentClasses(): Function[];
  
    abstract createDefinition(ecs: ECS, entity: Entity): ViewDefinition;
  
    abstract updateView(ecs: ECS, entity: Entity, view: View): boolean;
  
    abstract createView(ecs: ECS, entity: Entity, views: { [key: number]: ViewDefinition }, viewDefinition: ViewDefinition): View;
  
    abstract getLayerContainer(): Phaser.GameObjects.Container;
  
    abstract init(context: GameDisplayContext): void;
  
    abstract update(delta: number): void;
  
    abstract destroy(): void;
  
    static getReactCoordsFromPhaser(
      container: Phaser.GameObjects.Container,
      camera: Phaser.Cameras.Scene2D.Camera
    ): { x: number; y: number } {
      const x = (container.x - camera.worldView.x) * camera.zoom;
      const y = (container.y - camera.worldView.y) * camera.zoom;
      const canvas = camera.scene.sys.game.canvas;
      return {
        x: Phaser.Math.Clamp(x, 0, canvas.width),
        y: Phaser.Math.Clamp(y, 0, canvas.height),
      };
    }
  }
  

export function registerViewDisplayModule(
    module: ViewDisplayModule,
    context: GameDisplayContext,
    viewsByEntity: Map<Entity, View>
  ): void {
    module.context = context;
    module.tracker = new ViewTracker({
      viewsByEntity,
      ecs: context.ecs,
      scene: context.scene,
      componentClasses: module.getComponentClasses(),
      layerContainer: module.getLayerContainer(),
      createDefinition: module.createDefinition.bind(module),
      updateView: module.updateView.bind(module),
      createView: module.createView.bind(module)
    });
  
    module.tracker.init();
    module.tracker.update();
  }
  

// ---

import { ProgressBar, ProgressBarConfig } from "../game/effects/ProgressBar";
import { ShudderEffect, ShudderEffectConfig } from "../game/effects/ShudderEffect";
import { View } from "./View";

export interface EffectInstance {
  start(): void;
  stop(): void;
  update?(delta: number): void;
}

export enum EffectType {
  Red = "red",
  Highlight = "highlight",
  Shader = "shader",
  Shake = "shake",
  Progress = "progress",
  Shudder = "shudder",
}

export type ProgressBarOptions = ProgressBarConfig & { container: Phaser.GameObjects.Container };

export class ViewEffectController {
  private readonly view: View;
  private readonly active: Map<EffectType, EffectInstance> = new Map();

  constructor(view: View) {
    this.view = view;
  }

  apply(type: EffectType, opts?: Record<string, any>): void {
    if (this.active.has(type)) return;

    let instance: EffectInstance | undefined;

    switch (type) {
      case EffectType.Red:
        instance = this.makeRed(opts);
        break;
      case EffectType.Highlight:
        instance = this.makeRed(opts);
        break;
      case EffectType.Shader:
        instance = this.makeShader(opts);
        break;
      case EffectType.Shake:
        instance = this.makeShake(opts);
        break;
      case EffectType.Progress:
        instance = this.makeProgress(opts as ProgressBarOptions);
        break;
      case EffectType.Shudder:
        instance = new ShudderEffect(this.view, opts as ShudderEffectConfig);
        break;
    }

    if (instance) {
      this.active.set(type, instance);
      instance.start();
    }
  }

  clear(type: EffectType): void {
    const effect = this.active.get(type);
    if (effect) {
      effect.stop();
      this.active.delete(type);
    }
  }

  clearAll(): void {
    for (const effect of this.active.values()) {
      effect.stop();
    }
    this.active.clear();
  }

  update(delta: number): void {
    for (const effect of this.active.values()) {
      effect.update?.(delta);
    }
  }

  private makeShake(opts?: Record<string, any>): EffectInstance {
    const sprite = this.view.getSprite?.();
    if (!sprite) return { start: () => {}, stop: () => {} };

    const tween = sprite.scene.tweens.add({
      targets: sprite,
      scale: { from: 1, to: opts?.scale ?? 1.15 },
      yoyo: true,
      duration: opts?.duration ?? 200,
      repeat: opts?.repeat ?? 0,
    });

    return {
      start: () => {},
      stop: () => tween.stop(),
    };
  }

  private makeRed(opts?: Record<string, any>): EffectInstance {
    const sprite = this.view.getSprite?.();
    if (!sprite) return { start: () => {}, stop: () => {} };

    const tint = opts?.color ?? 0xff0000;

    return {
      start: () => sprite.setTint(tint),
      stop: () => sprite.clearTint(),
    };
  }

  private makeShader(opts?: Record<string, any>): EffectInstance {
    const sprite = this.view.getSprite?.();
    if (!sprite) return { start: () => {}, stop: () => {} };

    const shader = opts?.shader ?? "TimeTint";

    return {
      start: () => sprite.setPipeline(shader),
      stop: () => sprite.resetPipeline(),
    };
  }

  private makeProgress(config: ProgressBarOptions): EffectInstance {
    const bar = new ProgressBar(config.container, config);
  
    return {
      start: bar.show.bind(bar),
      stop: bar.hide.bind(bar),
      update: (delta: number) => bar.update(delta, this.view.viewDefinition.position)
    };
  }
}


// ---

import {DisplayTraitType, PanelDefinition, PanelType, ViewDefinition, ViewType} from "./ViewDefinition.ts";

export type ViewMap = Record<number, ViewDefinition>;

let nextId = 1;
let viewMap: ViewMap = {};

const panelDefinitions: Record<ViewType, PanelDefinition> = {
    [ViewType.TREE]: {
        title: "Tree",
        description: "A lush forest tree. May sway in the wind.",
        imagePath: "assets/panels/tree_panel.png",
        traits: [
            { type: DisplayTraitType.WOOD, value: 10 },
            { type: DisplayTraitType.FOOD, value: 5 },
        ],
        panelType: PanelType.TREE,
    },
    [ViewType.CAVE]: {
        title: "Cave",
        description: "A dark cave entrance. Mysterious and unexplored.",
        imagePath: "assets/panels/cave_panel.png",
        panelType: PanelType.CAVE
    },
    [ViewType.NONE]: {
        title: "",
        description: "",
        imagePath: "",
    } ,
    [ViewType.CHARCTER]: {
        title: "Character",
        description: "Some character",
        imagePath: "",
        panelType: PanelType.CHARACTER
    } 
} as Record<ViewType, PanelDefinition>;

export function createView(def: Partial<ViewDefinition>): ViewDefinition {
    const id = nextId++;
    const type = def.type ?? ViewType.NONE;

    const view: ViewDefinition = {
        id,
        spriteName: def.spriteName ?? ``,
        position: def.position ?? { x: 0, y: 0 },
        size: def.size ?? { x: 1, y: 1 },
        frame: def.frame ?? 0,
        subViews: [],
        type,
        selectable: def.selectable !== false,
        panelDefinition: def.panelDefinition ?? panelDefinitions[type],
        ...def,
    } as ViewDefinition;

    viewMap[id] = view;
    return view;
}

export function getView(id: number): ViewDefinition | undefined {
    return viewMap[id];
}

export function getViews(): ViewMap {
    return viewMap;
}

export function clearViews() {
    viewMap = {};
    nextId = 1;
}


// ---

import Phaser from "phaser";
import { ECS, Entity } from "../../ECS.ts";
import { View } from "./View.ts";
import { ViewDefinition } from "./ViewDefinition.ts";
import { getViews } from "./ViewStore.ts";
import { Pos } from "../../../utils/Math.ts";

export interface ViewTrackerOptions {
    ecs: ECS;
    scene: Phaser.Scene;
    componentClasses: Function[];
    layerContainer: Phaser.GameObjects.Container;
    createDefinition: (ecs: ECS, entity: Entity) => ViewDefinition;
    updateView: (ecs: ECS, entity: Entity, view: View) => boolean;
    createView: (ecs: ECS, entity: Entity,
        views: { [key: number]: ViewDefinition },
        viewDefinition: ViewDefinition) => View;
    viewsByEntity: Map<Entity, View>; // 👈 Shared view map
}

export class ViewTracker {
    private viewsByEntity: Map<Entity, View>;
    private viewsLocal = new Map<Entity, View>();
    private firstRun = true;

    private ecs: ECS;
    private componentClasses: Function[];
    private layerContainer: Phaser.GameObjects.Container;
    private createDefinition: (ecs: ECS, entity: Entity) => ViewDefinition;
    private updateView: (ecs: ECS, entity: Entity, view: View) => boolean;
    createView: ((ecs: ECS, entity: Entity,views: { [key: number]: ViewDefinition; }, viewDefinition: ViewDefinition) => View);

    constructor({
                    ecs,
                    componentClasses,
                    layerContainer,
                    createDefinition,
                    updateView,
                    createView,
                    viewsByEntity
                }: ViewTrackerOptions) {
        this.ecs = ecs;
        this.componentClasses = componentClasses;
        this.layerContainer = layerContainer;
        this.createDefinition = createDefinition;
        this.updateView = updateView;
        this.createView = createView;
        this.viewsByEntity = viewsByEntity;
    }

    public init() {
        this.viewsLocal.clear();
        this.firstRun = true;
    }

    public update() {
        const entityList = this.ecs.getEntitiesWithComponents(this.componentClasses);
        const currentSet = new Set<Entity>(entityList);
        let changed = this.firstRun;

        // Remove destroyed entities
        for (const [entity, view] of this.viewsLocal) {
            if (!currentSet.has(entity)) {
                view.viewContainer.destroy();
                this.viewsLocal.delete(entity);
                this.viewsByEntity.delete(entity); // 🔁 global map cleanup
                changed = true;
            }
        }

        // Add newly created entities
        for (const entity of entityList) {
            if (!this.viewsLocal.has(entity)) {
                const def = this.createDefinition(this.ecs, entity);
                const view = this.createView(this.ecs, entity, getViews(), def);
                this.viewsLocal.set(entity, view);
                this.viewsByEntity.set(entity, view); // 🔁 global map update
                changed = true;
            }
        }

        // Update all tracked views
        for (const [entity, view] of this.viewsLocal) {
            if (this.updateView(this.ecs, entity, view)) {
                changed = true;
            }
        }

        if (changed) {
            const sorted = this.layerContainer.list
                .filter(obj => obj instanceof Phaser.GameObjects.Container)
                .map(obj => obj as Phaser.GameObjects.Container)
                .sort((a, b) => (a.y - b.y));

            sorted.forEach(c => this.layerContainer.bringToTop(c));
        }

        this.firstRun = false;
    }

    public destroy() {
        for (const view of this.viewsLocal.values()) {
            view.viewContainer.destroy();
        }
        for (const entity of this.viewsLocal.keys()) {
            this.viewsByEntity.delete(entity);
        }
        this.viewsLocal.clear();
    }

    public static getReactCoordsFromPhaser(
        container: Phaser.GameObjects.Container,
        camera: Phaser.Cameras.Scene2D.Camera
      ): Pos {
        const x = (container.x - camera.worldView.x) * camera.zoom;
        const y = (container.y - camera.worldView.y) * camera.zoom;
      
        const canvas = camera.scene.sys.game.canvas;
        const maxX = canvas.width;
        const maxY = canvas.height;
      
        return {
          x: Phaser.Math.Clamp(x, 0, maxX),
          y: Phaser.Math.Clamp(y, 0, maxY),
        };
    }
}


// ---

export class AlphaSampler {
  private rt: Phaser.GameObjects.RenderTexture;

  constructor(scene: Phaser.Scene) {
    this.rt = scene.add.renderTexture(0, 0, 1, 1).setVisible(false);
  }

  async getAlphaAt(sprite: Phaser.GameObjects.Sprite, worldX: number, worldY: number): Promise<number> {
    if (!sprite.texture || !sprite.frame) return 0;

    const originOffsetX = sprite.displayOriginX;
    const originOffsetY = sprite.displayOriginY;
    
    const local = sprite.getWorldTransformMatrix().applyInverse(worldX, worldY);
    const tx = Math.floor(local.x + originOffsetX);
    const ty = Math.floor(local.y + originOffsetY);
    
    if (tx < 0 || ty < 0 || tx >= sprite.width || ty >= sprite.height) return 0;

    this.rt.clear();
    this.rt.drawFrame(sprite.texture.key, sprite.frame.name, -tx, -ty);

    return new Promise<number>((resolve) => {
      this.rt.snapshotPixel(0, 0, (color) => {
        'alpha' in color && resolve(color?.alpha ?? 0);
      });
    });
  }

  destroy(): void {
    this.rt.destroy();
  }
}


// ---

export type ClickCallback = (pointer: Phaser.Input.Pointer) => void;

export class ClickThresholdHandler {
  private threshold: number;
  private downPos: Phaser.Math.Vector2 | null = null;
  private scene: Phaser.Scene;
  private onClick: ClickCallback;

  constructor(scene: Phaser.Scene, onClick: ClickCallback, threshold = 5) {
    this.scene = scene;
    this.onClick = onClick;
    this.threshold = threshold;
  }

  start(): void {
    this.scene.input.on('pointerdown', this.onPointerDown, this);
    this.scene.input.on('pointerup', this.onPointerUp, this);
  }

  stop(): void {
    this.scene.input.off('pointerdown', this.onPointerDown, this);
    this.scene.input.off('pointerup', this.onPointerUp, this);
  }

  private onPointerDown(pointer: Phaser.Input.Pointer): void {
    this.downPos = pointer.position.clone();
  }

  private onPointerUp(pointer: Phaser.Input.Pointer): void {
    if (!this.downPos) return;

    const upPos = pointer.position;
    const distance = Phaser.Math.Distance.BetweenPoints(this.downPos, upPos);
    this.downPos = null;

    if (distance <= this.threshold) {
      this.onClick(pointer);
    }
  }
}


// ---

export type RightClickCallback = (event: MouseEvent) => void;

export class RightClickHandler {
  private callback: RightClickCallback;
  private targetElement: HTMLElement | Window;
  private boundHandleContextMenu: (event: Event) => void; 
  private isListening: boolean = false;

  constructor(callback: RightClickCallback, targetElement: HTMLElement | Window = window) {
    this.callback = callback;
    this.targetElement = targetElement;
    this.boundHandleContextMenu = this.handleContextMenu.bind(this);
  }

  private handleContextMenu(event: Event): void {
    event.preventDefault();
    this.callback(event as MouseEvent);
  }

  public start(): void {
    if (this.isListening) {
      return;
    }
    this.targetElement.addEventListener('contextmenu', this.boundHandleContextMenu);
    this.isListening = true;
  }

  public stop(): void {
    if (!this.isListening) {
      return;
    }
    this.targetElement.removeEventListener('contextmenu', this.boundHandleContextMenu);
    this.isListening = false;
  }
}

// ---

import { ECS } from "../../ECS";
import { TimeConfig } from "../../config/TimeConfig";
import { getTime } from "../../logic/time/TimeComponent";

export function getDeltaInGameMinutes(ecs: ECS, deltaMs: number): number {
    const time = getTime(ecs);
    if (!time || time.speedFactor === 0) return 0;

    const realSecondsPassed = deltaMs / 1000;
    const gameMinutesPassed = (realSecondsPassed / TimeConfig.RealSecondsPerHour) * TimeConfig.MinutesPerHour * time.speedFactor;
    return gameMinutesPassed;
}

// ---

import Container = Phaser.GameObjects.Container;

export function sortContainerByY(container: Container) {
    const sorted = container.list
        .filter(obj => obj instanceof Container)
        .sort((a, b) => {
            const aC = a as Container;
            const bC = b as Container;

            const aBottom = (aC.y + aC.height * aC.scaleY)
            const bBottom = bC.y + bC.height * bC.scaleY;

            return aBottom - bBottom;
        });

    sorted.forEach(c => container.bringToTop(c));
}


// ---

import Phaser from 'phaser';
import {Pos} from "../../../utils/Math.ts";

export function worldToLocal(container: Phaser.GameObjects.Container, worldPos: Pos): Pos {
    const matrix = container.getWorldTransformMatrix();
    const inverse = new Phaser.GameObjects.Components.TransformMatrix();
    matrix.copyToContext(inverse as any); // hacky but safe in Phaser 3
    inverse.invert();

    const out = new Phaser.Math.Vector2();
    inverse.transformPoint(worldPos.x, worldPos.y, out);
    return { x: out.x, y: out.y };
}


// ---

import { System, Entity } from "../../ECS";
import { getTime } from "../time/TimeComponent";
import { BuffsComponent } from "./BuffsComponent";

export class BuffManagementSystem extends System {
    public componentsRequired = new Set<Function>([BuffsComponent]);

    public update(entities: Set<Entity>, delta: number): void {
        const currentTimeMinutes = getTime(this.ecs).minutesElapsed;
        if (currentTimeMinutes === null) {
            return; 
        }

        for (const entity of entities) {
            const activeBuffs = this.ecs.getComponent(entity, BuffsComponent);
            
            activeBuffs.buffs = activeBuffs.buffs.filter(
                buff => buff.expirationTimeMinutes > currentTimeMinutes
            );
        }
    }
}

// ---

import { Component } from "../../ECS";
import { ActiveBuff, BuffType, BUFF_DEFINITIONS, BuffStackingBehavior } from "./buffsData";

export class BuffsComponent extends Component {
    public buffs: ActiveBuff[] = [];

    public addBuff(buffTypeToAdd: BuffType, currentTimeMinutes: number): void {
        const definition = BUFF_DEFINITIONS[buffTypeToAdd];
        if (!definition) {
            console.warn(`Attempted to add undefined buff type: ${buffTypeToAdd}`);
            return;
        }

        const newExpirationTimeMinutes = currentTimeMinutes + definition.defaultDurationMinutes;
        const existingBuffIndex = this.buffs.findIndex(b => b.type == buffTypeToAdd);

        if (existingBuffIndex != -1) {
            const existingBuff = this.buffs[existingBuffIndex];
            switch (definition.stackingBehavior) {
                case BuffStackingBehavior.REFRESH_DURATION:
                    existingBuff.expirationTimeMinutes = Math.max(existingBuff.expirationTimeMinutes, newExpirationTimeMinutes);
                    // Optionally, if effects could change or be stronger, update them:
                    // existingBuff.effects = [...definition.effects]; 
                    break;
                case BuffStackingBehavior.NO_STACK:
                    // Buff already exists, do nothing
                    break;
                case BuffStackingBehavior.INDEPENDENT_STACKING:
                    // Add a new instance regardless
                    this.buffs.push({
                        type: definition.type,
                        expirationTimeMinutes: newExpirationTimeMinutes,
                        effects: [...definition.effects], // Create a new copy of effects
                        stackingBehavior: definition.stackingBehavior,
                        source: definition.displayName 
                    });
                    break;
                case BuffStackingBehavior.HIGHEST_EFFECT_WINS:
                    // This would require comparing effect values, more complex.
                    // For now, let's treat it like REFRESH_DURATION or log a warning.
                    existingBuff.expirationTimeMinutes = Math.max(existingBuff.expirationTimeMinutes, newExpirationTimeMinutes);
                    // Potentially update effects if new ones are "stronger"
                    break;
                default:
                    // Default to refresh if behavior is unknown
                    existingBuff.expirationTimeMinutes = Math.max(existingBuff.expirationTimeMinutes, newExpirationTimeMinutes);
                    break;
            }
        } else {
            // Buff does not exist, add new one
            this.buffs.push({
                type: definition.type,
                expirationTimeMinutes: newExpirationTimeMinutes,
                effects: [...definition.effects],
                stackingBehavior: definition.stackingBehavior,
                source: definition.displayName
            });
        }
    }

    public removeBuff(buffTypeToRemove: BuffType): void {
        this.buffs = this.buffs.filter(b => b.type != buffTypeToRemove);
    }

    public hasBuff(buffType: BuffType): boolean {
        return this.buffs.some(b => b.type == buffType);
    }

    public getBuff(buffType: BuffType): ActiveBuff | undefined {
        return this.buffs.find(b => b.type == buffType);
    }
}

// ---

import { System, Entity } from "../../ECS";
import { ActionIntentComponent } from "../intent/intent-to-action/ActionIntentComponent";
import { CharacterAction } from "../intent/intent-to-action/actionIntentData";
import { BuffsComponent } from "./BuffsComponent";
import { MIN_SLEEP_DURATION_FOR_RESTED_BUFF_MINUTES, BuffType } from "./buffsData";
import { getTime } from "../time/TimeComponent"; // Adjust path
import { CharacterSleepStateComponent } from "../buildings/dormitory/CharacterSleepStateComponent";
import { NeedType, NeedsComponent } from "../needs/NeedsComponent";

export class SleepEffectsSystem extends System {
    public componentsRequired = new Set<Function>([ActionIntentComponent]);

    public update(entities: Set<Entity>, delta: number): void {
        const currentTimeMinutes = getTime(this.ecs).minutesElapsed;
        if (currentTimeMinutes === null) return;

        for (const entity of entities) {
            const actionIntent = this.ecs.getComponent(entity, ActionIntentComponent);
            const sleepState = this.ecs.getComponent(entity, CharacterSleepStateComponent);
            const needs = this.ecs.getComponent(entity, NeedsComponent);
            const sleep = needs?.need(NeedType.SLEEP);
            if (!sleep){
                return;
            }
            if (actionIntent.currentPerformedAction === CharacterAction.SLEEPING) {
                if (!sleepState) {
                    this.ecs.addComponent(entity, new CharacterSleepStateComponent(currentTimeMinutes));
                    const buffs = this.ecs.getComponent<BuffsComponent>(entity, BuffsComponent);
                    if (!buffs){
                        console.error("Error, no buffs found!");
                        return;
                    }

                    if (buffs.hasBuff(BuffType.SLEEPING)){
                        return;
                    }

                    buffs.addBuff(BuffType.SLEEPING, 0);
                    return;
                }
            } else { // Not currently SLEEPING
                if (sleepState) {
                    
                    // Was sleeping, but no longer is. Apply buff if duration was sufficient.
                    const sleepDurationMinutes = currentTimeMinutes - sleepState.sleepStartTimeMinutes;
                    if (sleepDurationMinutes >= MIN_SLEEP_DURATION_FOR_RESTED_BUFF_MINUTES && sleep.current == sleep.max) {
                        let activeBuffs = this.ecs.getComponent(entity, BuffsComponent);
                        if (!activeBuffs) {
                            activeBuffs = new BuffsComponent();
                            this.ecs.addComponent(entity, activeBuffs);
                        }
                        activeBuffs.addBuff(BuffType.RESTED, currentTimeMinutes);
                    }
                    this.ecs.removeComponent(entity, CharacterSleepStateComponent);

                    const buffs = this.ecs.getComponent<BuffsComponent>(entity, BuffsComponent);
                    if (!buffs){
                        console.error("Error, no buffs found!");
                        return;
                    }

                    buffs.removeBuff(BuffType.SLEEPING);
                }
            }
        }
    }
}

// ---

import { ECS, Entity } from "../../ECS"; // Adjust path
import { AffectedStat, BuffEffect, BuffEffectApplicationType } from "./buffsData";
import { LocomotionComponent } from "../locomotion/LocomotionComponent"; // Adjust path
import { HarvesterComponent as HarvesterComponent } from "../trees/HarvesterComponent"; // Adjust path, aliased to avoid name clash
import { BuffsComponent } from "./BuffsComponent";
import { WorkerComponent } from "../characters/WorkerComponent";

export class StatCalculator {

    private static getBaseValue(ecs: ECS, entity: Entity, statType: AffectedStat): number {
        switch (statType) {
            case AffectedStat.LOCOMOTION_SPEED:{
                const loco = ecs.getComponent(entity, LocomotionComponent);
                return loco?.speed ?? 0; // Default to 0 if component or baseSpeed is missing
            }
            case AffectedStat.WORK_SPEED:{
                const worker = ecs.getComponent(entity, WorkerComponent);
                return worker?.workSpeed ?? 0; 
            }
            case AffectedStat.HARVEST_SPEED:{
                const effectiveWorkSpeed = StatCalculator.getEffectiveStat(ecs, entity, AffectedStat.WORK_SPEED);
                const harvesterForHS = ecs.getComponent(entity, HarvesterComponent);
                const baseHarvestSpeedAdditive = harvesterForHS?.harvestPerMinute ?? 0;
                return effectiveWorkSpeed + baseHarvestSpeedAdditive;
            }       
            case AffectedStat.SLEEP_MODIFICATION_RATE:{
                return -0.1;
            }
            case AffectedStat.HUNGER_MODIFICATION_RATE:{
                return -0.25;
            }
            case AffectedStat.FOOD_GATHERING_YIELD_MULTIPLIER:{
                return 1;
            }
            default:
                console.warn(`StatCalculator: Base value for stat type ${statType} not defined.`);
                return 0;
        }
    }

    public static getEffectiveStat(
        ecs: ECS, 
        entity: Entity, 
        statType: AffectedStat
    ): number {
        let currentValue = StatCalculator.getBaseValue(ecs, entity, statType);
        
        const activeBuffsComp = ecs.getComponent(entity, BuffsComponent);
        if (!activeBuffsComp || activeBuffsComp.buffs.length === 0) {
            return currentValue;
        }

        const relevantEffects: BuffEffect[] = [];
        for (const buff of activeBuffsComp.buffs) {
            for (const effect of buff.effects) {
                if (effect.stat === statType) {
                    relevantEffects.push(effect);
                }
            }
        }

        if (relevantEffects.length === 0) {
            return currentValue;
        }

        // Sort effects: FLAT_ADDITIVE first, then PERCENT_MULTIPLICATIVE.
        // Further sort by 'order' if provided.
        relevantEffects.sort((a, b) => {
            const typeOrderA = a.type === BuffEffectApplicationType.FLAT_ADDITIVE ? 1 : 2;
            const typeOrderB = b.type === BuffEffectApplicationType.FLAT_ADDITIVE ? 1 : 2;
            if (typeOrderA !== typeOrderB) {
                return typeOrderA - typeOrderB;
            }
            return (a.order ?? 0) - (b.order ?? 0);
        });

        // Apply flat additive bonuses
        for (const effect of relevantEffects) {
            if (effect.type === BuffEffectApplicationType.FLAT_ADDITIVE) {
                currentValue += effect.value;
            }
        }

        // Apply percent multiplicative bonuses
        for (const effect of relevantEffects) {
            if (effect.type === BuffEffectApplicationType.PERCENT_MULTIPLICATIVE) {
                currentValue *= effect.value; // Assumes value is like 1.1 for +10%
            }
        }
        
        // Min value for stats like speed/rate is typically 0, or a small positive epsilon.
        // This can be handled by the consuming system or configured per stat if needed.
        return currentValue;
    }
}

// ---

import { System, Entity } from "../../ECS";
import { NeedType, NeedsComponent } from "../needs/NeedsComponent";
import { getTime } from "../time/TimeComponent";
import { BuffsComponent } from "./BuffsComponent";
import { BuffType } from "./buffsData";

const TIRED_THRESHOLD = 0.65;

export class TiredEffectSystem extends System {
    public componentsRequired = new Set<Function>([NeedsComponent, BuffsComponent]);


    public update(entities: Set<Entity>, delta: number): void {
        const currentTimeMinutes = getTime(this.ecs).minutesElapsed;
        if (currentTimeMinutes === null) return;

        for (const entity of entities) {
            const needs = this.ecs.getComponent(entity, NeedsComponent);
            const sleep = needs.need(NeedType.SLEEP);
            if (!sleep){
                continue;
            }
            const buffs = this.ecs.getComponent(entity, BuffsComponent);
            if (sleep.current / sleep.max > TIRED_THRESHOLD){
                buffs.removeBuff(BuffType.TIRED);
                return;
            }

            if (!buffs.hasBuff(BuffType.TIRED))
                buffs.addBuff(BuffType.TIRED, 0);
        }
    }
}

// ---

export enum BuffType {
    RESTED = "RESTED",
    STROLL_SPEED = "STROLL_SPEED",
    SLEEPING = "SLEEPING",
    TIRED = "TIRED",
    EATING = "EATING"
}


export enum AffectedStat {
    LOCOMOTION_SPEED = "LOCOMOTION_SPEED",
    WORK_SPEED = "WORK_SPEED",
    HARVEST_SPEED = "HARVEST_SPEED",
    SLEEP_MODIFICATION_RATE = "SLEEP_MODIFICATION_RATE",
    HUNGER_MODIFICATION_RATE = "HUNGER_MODIFICATION_RATE",
    FOOD_GATHERING_YIELD_MULTIPLIER = "FOOD_GATHERING_YIELD_MULTIPLIER"
}

export enum BuffEffectApplicationType {
    FLAT_ADDITIVE = "FLAT_ADDITIVE",
    PERCENT_MULTIPLICATIVE = "PERCENT_MULTIPLICATIVE",
}

export enum BuffStackingBehavior {
    REFRESH_DURATION = "REFRESH_DURATION", // New instance refreshes duration, effects might update if stronger
    INDEPENDENT_STACKING = "INDEPENDENT_STACKING", // Multiple instances co-exist, StatCalculator sums effects
    NO_STACK = "NO_STACK", // Only one instance allowed; subsequent applications ignored or fail
    HIGHEST_EFFECT_WINS = "HIGHEST_EFFECT_WINS" // Only the instance with the highest effect value for a given stat applies
}

export interface BuffEffect {
    stat: AffectedStat;
    type: BuffEffectApplicationType;
    value: number;
    order?: number; 
}

export interface ActiveBuff {
    type: BuffType;
    expirationTimeMinutes: number;
    effects: BuffEffect[];
    stackingBehavior: BuffStackingBehavior; // Could be copied from BuffDefinition or set per instance
    source?: string;
}

export interface BuffDefinition {
    readonly type: BuffType;
    readonly defaultDurationMinutes: number;
    readonly effects: ReadonlyArray<BuffEffect>;
    readonly stackingBehavior: BuffStackingBehavior;
    readonly displayName?: string; // Optional display name for UI
}

export const MIN_SLEEP_DURATION_FOR_RESTED_BUFF_MINUTES = 30;

export const BUFF_DEFINITIONS: Readonly<Record<BuffType, BuffDefinition>> = {
    [BuffType.RESTED]: {
        type: BuffType.RESTED,
        defaultDurationMinutes: 60,
        effects: [
            { stat: AffectedStat.LOCOMOTION_SPEED, type: BuffEffectApplicationType.PERCENT_MULTIPLICATIVE, value: 1.10, order: 100 },
            { stat: AffectedStat.WORK_SPEED,       type: BuffEffectApplicationType.PERCENT_MULTIPLICATIVE, value: 1.10, order: 100 },
        ],
        stackingBehavior: BuffStackingBehavior.REFRESH_DURATION,
    },
    [BuffType.STROLL_SPEED]: {
        type: BuffType.STROLL_SPEED,
        defaultDurationMinutes: Number.MAX_SAFE_INTEGER, // Effectively indefinite, managed by adding/removing
        effects: [
            { stat: AffectedStat.LOCOMOTION_SPEED, type: BuffEffectApplicationType.PERCENT_MULTIPLICATIVE, value: 0.1, order: 50 }
        ],
        stackingBehavior: BuffStackingBehavior.NO_STACK, // Only one instance of this effect
    },
    [BuffType.SLEEPING]:{
        type: BuffType.SLEEPING,
        defaultDurationMinutes:Number.MAX_SAFE_INTEGER,
        effects:[
            {stat: AffectedStat.SLEEP_MODIFICATION_RATE, type:BuffEffectApplicationType.FLAT_ADDITIVE, value:0.6}
        ],
        stackingBehavior: BuffStackingBehavior.INDEPENDENT_STACKING
    },
    [BuffType.EATING]:{
        type: BuffType.EATING,
        defaultDurationMinutes:10,
        effects: [
            { stat: AffectedStat.HUNGER_MODIFICATION_RATE, type: BuffEffectApplicationType.FLAT_ADDITIVE, value: 2.5, order: 100 },
        ],
        stackingBehavior: BuffStackingBehavior.REFRESH_DURATION,
    },
    [BuffType.TIRED]:{
        type: BuffType.TIRED,
        defaultDurationMinutes:Number.MAX_SAFE_INTEGER,
        effects: [
            { stat: AffectedStat.LOCOMOTION_SPEED, type: BuffEffectApplicationType.PERCENT_MULTIPLICATIVE, value: 0.75, order: 100 },
            { stat: AffectedStat.WORK_SPEED,       type: BuffEffectApplicationType.PERCENT_MULTIPLICATIVE, value: .75, order: 100 },
        ],
        stackingBehavior: BuffStackingBehavior.REFRESH_DURATION,
    }
};

// ---

import {Component} from "../../ECS.ts";

export class Cave extends Component {
    constructor(
        public explored: boolean = false
    ) {
        super();
    }
}

// ---

import { Component } from "../../../ECS"; // Adjust path as needed

/**
 * Tracks the state of an entity currently performing the SLEEPING action,
 * primarily to determine sleep duration for effects like the "Rested" buff.
 */
export class CharacterSleepStateComponent extends Component {
    /** Game time in total minutes (e.g., from TimeComponent.minutesElapsed) when the SLEEPING action began. */
    public sleepStartTimeMinutes: number;

    constructor(sleepStartTimeMinutes: number) {
        super();
        this.sleepStartTimeMinutes = sleepStartTimeMinutes;
    }
}

// ---

import { Component } from "../../../ECS";

export class DormitoryComponent extends Component {
    public assignedCharacters: number[] = [];

    constructor(public maxCapacity: number = 5) {
        super();
    }
}

// ---

import { System, Entity } from "../../../ECS";
import { DormitoryComponent } from "./DormitoryComponent";

export class DormitorySystem extends System {
    public componentsRequired = new Set<Function>([DormitoryComponent]);

    public update(dormitoryEntities: Set<Entity>, delta: number): void {
        for (const dormitoryEntity of dormitoryEntities) {
            const dorm = this.ecs.getComponent(dormitoryEntity, DormitoryComponent);

            for (let i = dorm.assignedCharacters.length - 1; i >= 0; i--) {
                const characterId = dorm.assignedCharacters[i];
                if (!this.ecs.hasEntity(characterId)) {
                    dorm.assignedCharacters.splice(i, 1);
                }
            }
        }
    }
}

// ---

import { Component, Entity } from "../../../ECS";

/**
 * Stores the entity ID of a character's assigned "home" base.
 * This could be a dormitory, a work building like a WoodDojo, or another central point
 * used as a reference for behaviors like strolling or context-based task targeting.
 */
export class HomeComponent extends Component {
    /**
     * @param homeEntityId The entity ID of the character's assigned home structure.å
     */
    constructor(public homeEntityId: Entity) {
        super();
    }
}

// ---

import { Component, ECS, Entity } from "../../../ECS";
import { WoodDojoWorker } from "./WoodDojoWorker";

export class WoodDojo extends Component {
    public assignedCharacters: number[] = [];
    
    public assignCharacter(ecs: ECS, dojoEntityId: Entity, characterId: Entity): void {
        if (!this.assignedCharacters.includes(characterId)) {
            this.assignedCharacters.push(characterId);
        }

        if (ecs.hasEntity(characterId) && !ecs.hasComponent(characterId, WoodDojoWorker)) {
            ecs.addComponent(characterId, new WoodDojoWorker(dojoEntityId));
        }
    }

    public unassignCharacter(ecs: ECS, characterId: Entity): void {
        const index = this.assignedCharacters.indexOf(characterId);
        if (index > -1) {
            this.assignedCharacters.splice(index, 1);
        }

        if (ecs.hasEntity(characterId) && ecs.hasComponent(characterId, WoodDojoWorker)) {
            ecs.removeComponent(characterId, WoodDojoWorker);
        }
    }
}

// ---

import { System, Entity } from "../../../ECS";
import { WoodDojo } from "./WoodDojo";

export class WoodDojoSystem extends System {
    public componentsRequired = new Set<Function>([WoodDojo]);

    public update(dojoEntities: Set<Entity>, delta: number): void {
        for (const dojoEntity of dojoEntities) {
            const dojo = this.ecs.getComponent(dojoEntity, WoodDojo);

            // Clean up non-existent characters from the assignedCharacters list
            // Iterate backwards when removing elements from an array during iteration
            for (let i = dojo.assignedCharacters.length - 1; i >= 0; i--) {
                const characterId = dojo.assignedCharacters[i];
                if (!this.ecs.hasEntity(characterId)) {
                    dojo.assignedCharacters.splice(i, 1);
                }
            }
        }
    }
}

// ---

import { Component } from "../../../ECS";

export class WoodDojoWorker extends Component {
    
    constructor(public dojoId: number) {
        super();
    }
}

// ---

import { Component } from "../../ECS";

export enum CharacterType {
    PROFESSOR = "PROFESSOR"
}

export class CharacterDefinition {
    public name: string;
    public description: string;
    public type:CharacterType;
}

export class Character extends Component {
    constructor(
        public definition: CharacterDefinition,
    ) {
        super();
    }
}

// ---

import { Component } from "../../ECS";
import { CharacterIntent } from "../intent/intent-to-action/actionIntentData";

export type ScheduleEntry = CharacterIntent; // One entry per hour

export class ScheduleComponent extends Component {
  public lastScheduleStartHour: number = 0; // Time in minutes when the schedule started

  constructor(public entries: ScheduleEntry[]) {
    super();
  }
}

export function createStandardSchedule(): ScheduleComponent {
  return new ScheduleComponent([
    CharacterIntent.SLEEP,
    CharacterIntent.HARVEST,
    CharacterIntent.HARVEST,
    CharacterIntent.HARVEST,
    CharacterIntent.REST,
    CharacterIntent.HARVEST,
    CharacterIntent.HARVEST,
    CharacterIntent.HARVEST,
    CharacterIntent.SLEEP
  ]);
}

// ---

import { Component } from "../../ECS";

export class WorkerComponent extends Component {
    public workSpeed: number = 1; 

    constructor() {
        super();
    }
}

// ---

// src/game/logic/foraging/ForagableComponent.ts
import { Component } from "../../ECS"; // Adjust path as needed
import { ResourceType } from "../resources/ResourceType"; // Adjust path as needed

export class ForagableComponent extends Component {
  public resourceType: ResourceType;
  public currentAmount: number;
  public maxAmount: number;
  public regenRatePerMinute: number; // Units regenerated per game minute for the node
  public yieldPerMinute: number;     // Base units a character can extract per minute of foraging at this node

  constructor(
    resourceType: ResourceType,
    initialAmount: number,
    maxAmount: number,
    regenRatePerMinute: number,
    yieldPerMinute: number = 1 // Default base yield of 1 unit per minute of foraging
  ) {
    super();
    this.resourceType = resourceType;
    this.currentAmount = initialAmount;
    this.maxAmount = maxAmount;
    this.regenRatePerMinute = regenRatePerMinute;
    this.yieldPerMinute = yieldPerMinute;
  }

  public isDepleted(): boolean {
    return this.currentAmount <= 0;
  }
}

// ---

import { System, Entity, ECS } from "../../ECS";
import { ForagableComponent } from "./ForagableComponent";
import { ResourceTracker } from "../resources/ResourceTracker";
import { StatCalculator } from "../buffs/StatCalculator";
import { AffectedStat } from "../buffs/buffsData"; 
import { InteractionSlots, SlotType } from "../../components/InteractionSlots"; 
import { getDeltaInGameMinutes } from "../../display/utils/getDeltaInGameMinutes";
import { ActionIntentComponent } from "../intent/intent-to-action/ActionIntentComponent";
import { CharacterAction, ForagingActionData, ActionDataType, CharacterIntent } from "../intent/intent-to-action/actionIntentData";

function releaseForageSlot(ecs: ECS, characterEntity: Entity, foragableEntityId: Entity): void {
    if (ecs.hasEntity(foragableEntityId) && ecs.hasComponent(foragableEntityId, InteractionSlots)) {
        ecs.getComponent(foragableEntityId, InteractionSlots)?.release(characterEntity, SlotType.FORAGE);
    }
}

export class ForagingSystem extends System {
    public componentsRequired = new Set<Function>([ActionIntentComponent]);

    public update(entities: Set<Entity>, deltaMs: number): void {
        const gameMinutesPassedThisFrame = getDeltaInGameMinutes(this.ecs, deltaMs);
        if (gameMinutesPassedThisFrame === 0) return;

        for (const characterEntity of entities) {
            const actionIntent = this.ecs.getComponent(characterEntity, ActionIntentComponent);

            if (actionIntent.currentPerformedAction !== CharacterAction.FORAGING ||
                (actionIntent.actionData as ForagingActionData)?.type !== ActionDataType.ForagingActionData) {
                continue;
            }

            const foragingData = actionIntent.actionData as ForagingActionData;
            const targetEntityId = foragingData.targetForagableEntityId;

            if (!this.ecs.hasEntity(targetEntityId)) {
                releaseForageSlot(this.ecs, characterEntity, targetEntityId);
                actionIntent.intentType = CharacterIntent.FORAGE_FOOD; // Re-evaluate for new target
                actionIntent.currentPerformedAction = CharacterAction.IDLE;
                actionIntent.actionData = null;
                continue;
            }

            const foragableNode = this.ecs.getComponent(targetEntityId, ForagableComponent);

            if (!foragableNode || foragableNode.currentAmount <= 0) {
                releaseForageSlot(this.ecs, characterEntity, targetEntityId);
                actionIntent.intentType = CharacterIntent.FORAGE_FOOD; // Node depleted, re-evaluate
                actionIntent.currentPerformedAction = CharacterAction.IDLE;
                actionIntent.actionData = null;
                continue;
            }

            const baseYieldFromNodeThisFrame = foragableNode.yieldPerMinute * gameMinutesPassedThisFrame;
            
            // Apply character's yield multiplier (e.g., from Kitchen worker buff)
            const characterYieldMultiplier = StatCalculator.getEffectiveStat(
                this.ecs,
                characterEntity,
                AffectedStat.FOOD_GATHERING_YIELD_MULTIPLIER
            );

            // Amount actually taken cannot exceed what's available on the node
            const amountTakenFromNode = Math.min(baseYieldFromNodeThisFrame, foragableNode.currentAmount);

            if (amountTakenFromNode > 0) {
                foragableNode.currentAmount -= amountTakenFromNode;
                ResourceTracker.add(foragableNode.resourceType, amountTakenFromNode * characterYieldMultiplier);
            }

            if (foragableNode.currentAmount <= 0) {
                releaseForageSlot(this.ecs, characterEntity, targetEntityId);
                actionIntent.intentType = CharacterIntent.FORAGE_FOOD; // Node depleted, re-evaluate
                actionIntent.currentPerformedAction = CharacterAction.IDLE;
                actionIntent.actionData = null;
            }
        }
    }
}

// ---

import { Component } from "../../ECS";

export type TimeSpeed = 'paused' | 'normal' | 'fast' | 'veryfast';

export class InputComponent extends Component {
    constructor(
        public speed: TimeSpeed = 'normal',
        public selection: number = -1 // -1 means no selection
    ) {
        super();
    }
}


// ---

import { Entity, System } from "../../ECS";
import { InputComponent, TimeSpeed } from "./InputComponent.ts";
import { GameEvent } from "../../consts/GameEvent.ts";
import { EventBus } from "../../EventBus.ts";

export class InputSystem extends System {
    public componentsRequired = new Set<Function>([InputComponent]);

    constructor() {
        super();
    }

    handleSetSpeed(speed: TimeSpeed) {
        for (const entity of this.ecs.getEntitiesWithComponent(InputComponent)) {
            const input = this.ecs.getComponent(entity, InputComponent);
            input.speed = speed;
        }
    }

    handleSelectionChange(entityId: number) {
        for (const entity of this.ecs.getEntitiesWithComponent(InputComponent)) {
            const input = this.ecs.getComponent(entity, InputComponent);
            input.selection = entityId;
        }
    }

    update(_: Set<Entity>, __: number): void {}

    initialize(): () => void {
        const boundHandleSetSpeed = this.handleSetSpeed.bind(this);
        const boundHandleSelectionChange = this.handleSelectionChange.bind(this);
        
        EventBus.on(GameEvent.SetTimeSpeed, boundHandleSetSpeed);
        EventBus.on(GameEvent.SelectionChanged, boundHandleSelectionChange);

        for (const entity of this.ecs.getEntitiesWithComponent(InputComponent)) {
            const input = this.ecs.getComponent(entity, InputComponent);
            EventBus.emit(GameEvent.SetTimeSpeed, input.speed);
        }

        return () => {
            EventBus.off(GameEvent.SetTimeSpeed, boundHandleSetSpeed);
            EventBus.off(GameEvent.SelectionChanged, boundHandleSelectionChange);
        };
    }
}


// ---

import { Entity, System } from "../../ECS";
import { ActionIntentComponent } from "./intent-to-action/ActionIntentComponent";
import { CharacterIntent, CharacterAction } from "./intent-to-action/actionIntentData";
import { ScheduleComponent } from "../characters/ScheduleComponent";
import { getTime } from "../time/TimeComponent";
import { NeedsComponent } from "../needs/NeedsComponent";
import { calculateHarvestIntentWeight } from "./weights/calculateHarvestIntentWeight";
import { calculateSleepIntentWeight } from "./weights/calculateSleepIntentWeight";
import { calculateRestIntentWeight } from "./weights/calculateRestIntentWeight";
import { calculateEatIntentWeight } from "./weights/calculateEatIntentWeight";

export class IntentSelectionSystem extends System {
    public componentsRequired = new Set<Function>([
        ActionIntentComponent,
        ScheduleComponent,
        NeedsComponent
    ]);

    public update(entities: Set<Entity>, delta: number): void {
        const currentHour = getTime(this.ecs).hour;

        for (const entity of entities) {
            const actionIntent = this.ecs.getComponent(entity, ActionIntentComponent);
            const schedule = this.ecs.getComponent(entity, ScheduleComponent);
            const needs = this.ecs.getComponent(entity, NeedsComponent);

            const intentWeights: { intent: CharacterIntent, weight: number }[] = [];

            // Calculate weights for all relevant intents
            intentWeights.push({ intent: CharacterIntent.SLEEP, weight: calculateSleepIntentWeight(this.ecs, entity, actionIntent, schedule, needs, currentHour) });
            intentWeights.push({ intent: CharacterIntent.EAT, weight: calculateEatIntentWeight(this.ecs, entity, actionIntent, schedule, needs, currentHour) });
            intentWeights.push({ intent: CharacterIntent.HARVEST, weight: calculateHarvestIntentWeight(this.ecs, entity, schedule, needs, currentHour) });
            intentWeights.push({ intent: CharacterIntent.REST, weight: calculateRestIntentWeight(this.ecs, entity, schedule, needs, currentHour) });

            // Sort by weight descending
            intentWeights.sort((a, b) => b.weight - a.weight);

            let chosenIntent = CharacterIntent.REST;

            if (intentWeights.length > 0 && intentWeights[0].weight > 0) {
                chosenIntent = intentWeights[0].intent;
            }

            if (actionIntent.intentType !== chosenIntent) {
                actionIntent.intentType = chosenIntent;
                actionIntent.currentPerformedAction = CharacterAction.IDLE; // Reset action
                actionIntent.actionData = null; // Clear data for the new intent
            }
        }
    }
}

// ---

import { Pos } from "../../../../utils/Math";
import { Component } from "../../../ECS";

export class HarvestingState extends Component {
    public target: number = -1;
    public targetPos: Pos | undefined;
    
    constructor(target: number = -1, targetPos: Pos | undefined = undefined) {
        super();
        this.target = target;
        this.targetPos = targetPos;
    }
}

// ---

// src/game/logic/character-states/SleepingComponent.ts
import { Component, Entity } from "../../../ECS";
import { Pos } from "../../../../utils/Math";

export class SleepingState extends Component {
    public targetBedEntityId: Entity = -1;
    public targetPosition: Pos | undefined;
    
    constructor(targetBedEntityId: Entity = -1, targetPosition: Pos | undefined = undefined) {
        super();
        this.targetBedEntityId = targetBedEntityId;
        this.targetPosition = targetPosition;
    }
}

// ---

import { Component } from "../../../ECS";
import { CharacterIntent, CharacterAction } from "./actionIntentData";

/**
 * ActionIntentComponent stores a character's high-level intent and their
 * current, concrete performed action. Data specific to the current action
 * is stored in the `actionData` payload.
 */
export class ActionIntentComponent extends Component {
    /** The character's current high-level goal or scheduled task. */
    public intentType: CharacterIntent = CharacterIntent.NONE;

    /** The specific, observable action the character is currently performing. */
    public currentPerformedAction: CharacterAction = CharacterAction.IDLE;
        
    /** * Holds data specific to the `currentPerformedAction`. 
     * Its structure is determined by the action (e.g., WalkingData, ChoppingData).
     * Managed by IntentActionSystem (and its helpers). Should be null if no data needed.
     */
    public actionData: any | null = null;

    constructor(initialIntent: CharacterIntent = CharacterIntent.NONE) {
        super();
        this.intentType = initialIntent;
    }
}

// ---

import { System, Entity } from "../../../ECS";
import { ActionIntentComponent } from "./ActionIntentComponent";
import { CharacterIntent, CharacterAction } from "./actionIntentData";
import { handleEatIntentLogic } from "./intent-handlers/handleEatIntentLogic";
import { handleForageIntentLogic } from "./intent-handlers/handleForageIntentLogic";
import { handleHarvestIntentLogic } from "./intent-handlers/handleHarvestIntentLogic";
import { handleRestIntentLogic } from "./intent-handlers/handleRestIntentLogic";
import { handleSleepIntentLogic } from "./intent-handlers/handleSleepIntentLogic";
import { abortHarvesting } from "./intent-handlers/abortHarvesting";
import { abortSleeping } from "./intent-handlers/abortSleeping";

export class ActionIntentSystem extends System {
    public componentsRequired = new Set<Function>([ActionIntentComponent]);
    public lastIntent:CharacterIntent;

    public update(entities: Set<Entity>, delta: number): void {
        for (const entity of entities) {
            const actionIntent = this.ecs.getComponent(entity, ActionIntentComponent);
            const currentIntent = actionIntent.intentType;
            if (this.lastIntent !== currentIntent) {
                switch (this.lastIntent) {
                    case CharacterIntent.HARVEST:
                        abortHarvesting(this.ecs, entity);
                        break;
                    case CharacterIntent.SLEEP:
                        abortSleeping(this.ecs, entity);
                        break;
                    case CharacterIntent.REST:
                    case CharacterIntent.EAT:
                    case CharacterIntent.FORAGE_FOOD:
                    default:
                        break;
                }
            }

            this.lastIntent = currentIntent;

            switch (currentIntent) {
                case CharacterIntent.HARVEST:
                    handleHarvestIntentLogic(this.ecs, entity, actionIntent);
                    break;
                case CharacterIntent.SLEEP:
                    handleSleepIntentLogic(this.ecs, entity, actionIntent);
                    break;
                case CharacterIntent.REST:
                    handleRestIntentLogic(this.ecs, entity, actionIntent);
                    break;
                case CharacterIntent.EAT:
                    handleEatIntentLogic(this.ecs, entity, actionIntent);
                    break;
                case CharacterIntent.FORAGE_FOOD:
                    handleForageIntentLogic(this.ecs, entity, actionIntent);
                    break;
                default:
                    actionIntent.currentPerformedAction = CharacterAction.IDLE;
                    actionIntent.actionData = null;
                    break;
            }
        }
    }
}

// ---

import { Entity } from "../../../ECS";
import { Pos } from "../../../../utils/Math";

/** Defines the high-level goal or scheduled task for a character. */

export enum CharacterIntent {
    NONE = "NONE",
    HARVEST = "HARVEST",
    BUILD = "BUILD",
    SLEEP = "SLEEP",
    REST = "REST",
    EAT = "EAT",
    STUDY = "STUDY",
    FORAGE_FOOD = "FORAGE_FOOD"
}

/** Defines the concrete, observable, low-level action a character is currently performing. */

export enum CharacterAction {
    IDLE = "Idle",
    WALKING = "Walking",
    CHOPPING = "Chopping",
    BUILDING = "Building",
    STUDYING = "Studying",
    SLEEPING = "Sleeping",
    STROLLING = "Strolling",// Covers walking during stroll and pausing at stroll points
    RELAXING = "Relaxing",
    NONE = "None",
    EATING = "Eating",
    FORAGING = "Foraging"
}

/** Enum to discriminate between different actionData payload structures. */

export enum ActionDataType {
    WalkingData,
    ChoppingData,
    SleepingData,
    StrollingAtPointData,
    EatingData,
    ForagingActionData
}

export interface ForagingActionData {
    readonly type: ActionDataType.ForagingActionData; 
    targetForagableEntityId: Entity;
}

// --- Payload Interfaces for ActionIntentComponent.actionData ---
export interface WalkingData {
    readonly type: ActionDataType.WalkingData;
    targetPosition: Pos;
    ultimateTargetEntityId?: Entity;
}

export interface ChoppingData {
    readonly type: ActionDataType.ChoppingData;
    targetTreeEntityId: Entity;
}

export interface SleepingData {
    readonly type: ActionDataType.SleepingData;
    bedEntityId: Entity;
    slotOffset: Pos;
}

export interface StrollingAtPointData {
    readonly type: ActionDataType.StrollingAtPointData;
    atTreeEntityId: Entity; // The tree/point they are currently at
}

export interface EatingData {
    readonly type: ActionDataType.EatingData; 
}

// --- Type Guards for ActionData Payloads ---

export function isForagingActionData(data: any): data is ForagingActionData {
   return data?.type === ActionDataType.ForagingActionData;
}

export function isEatingData(data: any): data is EatingData {
    return data?.type === ActionDataType.EatingData;
}

export function isWalkingData(data: any): data is WalkingData {
    return data?.type === ActionDataType.WalkingData &&
           data.targetPosition !== undefined;
}

export function isChoppingData(data: any): data is ChoppingData {
    return data?.type === ActionDataType.ChoppingData &&
           typeof data.targetTreeEntityId === 'number';
}

export function isSleepingData(data: any): data is SleepingData {
    return data?.type === ActionDataType.SleepingData;
}

export function isStrollingAtPointData(data: any): data is StrollingAtPointData {
    return data?.type === ActionDataType.StrollingAtPointData;
}

// ---

import { ECS, Entity } from "../../../../ECS";
import { InteractionSlots, SlotType } from "../../../../components/InteractionSlots";
import { LocomotionComponent } from "../../../locomotion/LocomotionComponent";
import { HarvestingState } from "../../character-states/HarvestingState";


export function abortHarvesting(ecs: ECS, characterEntity: Entity): void {
    const harvesting = ecs.getComponent(characterEntity, HarvestingState);
    if (!harvesting) return;

    ecs.removeComponent(characterEntity, HarvestingState);

    const targetEntity = harvesting.target;
    const targetSlots = ecs.getComponent(targetEntity, InteractionSlots);
    targetSlots?.release(characterEntity, SlotType.WORK);

    const locomotion = ecs.getComponent(characterEntity, LocomotionComponent);
    if (locomotion) {
        locomotion.arrived = false;
    }
}


// ---

import { ECS, Entity } from "../../../../ECS";
import { InteractionSlots, SlotType } from "../../../../components/InteractionSlots";
import { LocomotionComponent } from "../../../locomotion/LocomotionComponent";
import { SleepingState } from "../../character-states/SleepingState";

export function abortSleeping(ecs: ECS, characterEntity: Entity): void {
    const sleeping = ecs.getComponent(characterEntity, SleepingState);
    if (!sleeping)
        return; // No sleeping state to abort
    
    ecs.getComponent(sleeping.targetBedEntityId, InteractionSlots)?.release(characterEntity, SlotType.SLEEP);
    ecs.removeComponent(characterEntity, SleepingState);

    const locomotion = ecs.getComponent(characterEntity, LocomotionComponent);
    if (locomotion) {
        locomotion.arrived = false;
    }
}

// ---

// src/game/logic/action-intent/intent-handlers/handleEatIntentLogic.ts
import { ECS, Entity } from "../../../../ECS";
import { ActionIntentComponent } from "../ActionIntentComponent";
import {
    CharacterAction,
    ActionDataType,
    WalkingData,
    CharacterIntent,
} from "../actionIntentData";
import { Transform } from "../../../../components/Transform";
import { LocomotionComponent } from "../../../locomotion/LocomotionComponent";
import { Pos } from "../../../../../utils/Math";
import { NeedsComponent, NeedType } from "../../../needs/NeedsComponent";
import { ResourceTracker } from "../../../resources/ResourceTracker";
import { ResourceType } from "../../../resources/ResourceType";
import { BuffType } from "../../../buffs/buffsData"; // Assuming BuffType.EATING is defined here
import { WoodDojo } from "../../../buildings/wood_dojo/WoodDojo"; // Placeholder for KitchenComponent
import { getTime } from "../../../time/TimeComponent"; // Required for buff application timestamp
import { BuffsComponent } from "../../../buffs/BuffsComponent";

const FOOD_UNITS_CONSUMED_AT_ACTION_START = 1;

function setIdleAndClearIntent(aic: ActionIntentComponent): void {
    aic.currentPerformedAction = CharacterAction.IDLE;
    aic.intentType = CharacterIntent.NONE;
    aic.actionData = null;
}

function setForageIntent(aic: ActionIntentComponent): void {
    aic.intentType = CharacterIntent.FORAGE_FOOD; // Ensure this is in CharacterIntent enum
    aic.currentPerformedAction = CharacterAction.IDLE;
    aic.actionData = null;
}

function setWalkingToKitchen(aic: ActionIntentComponent, targetPosition: Pos, kitchenEntityId: Entity): void {
    aic.currentPerformedAction = CharacterAction.WALKING;
    aic.actionData = {
        type: ActionDataType.WalkingData,
        targetPosition,
        ultimateTargetEntityId: kitchenEntityId
    } as WalkingData;
}

function applyEatingBuffAndSetAction(ecs: ECS, entity: Entity, aic: ActionIntentComponent): void {
    ResourceTracker.add(ResourceType.FOOD, -FOOD_UNITS_CONSUMED_AT_ACTION_START);
    
    let buffs = ecs.getComponent(entity, BuffsComponent);
    if (!buffs) {
        buffs = new BuffsComponent();
        ecs.addComponent(entity, buffs);
    }
    const time = getTime(ecs); 
    buffs.addBuff(BuffType.EATING, time ? time.minutesElapsed : 0);

    aic.currentPerformedAction = CharacterAction.EATING;
    aic.actionData = { type: ActionDataType.EatingData }; 
}

function getKitchenInfo(ecs: ECS): { id: Entity, transform: Transform } | null {
    const kitchens = ecs.getEntitiesWithComponents([WoodDojo, Transform]); // Replace WoodDojo
    if (kitchens.length > 0) {
        const kitchenId = kitchens[0];
        const kitchenTransform = ecs.getComponent(kitchenId, Transform);
        return { id: kitchenId, transform: kitchenTransform };
    }
    return null;
}

export function handleEatIntentLogic(
    ecs: ECS,
    entity: Entity,
    actionIntent: ActionIntentComponent
): void {
    const activeBuffs = ecs.getComponent(entity, BuffsComponent);
    const isEatingBuffActive = activeBuffs?.hasBuff(BuffType.EATING) || false;

    if (isEatingBuffActive){
        return;
    }

    const locomotion = ecs.getComponent(entity, LocomotionComponent);
    const needs = ecs.getComponent(entity, NeedsComponent);

    if (!locomotion || !needs) return setIdleAndClearIntent(actionIntent);

    const foodNeed = needs.need(NeedType.FOOD);


    if (!foodNeed || (foodNeed.current >= foodNeed.max && !isEatingBuffActive)) {
        return setIdleAndClearIntent(actionIntent);
    }

    if (actionIntent.currentPerformedAction === CharacterAction.EATING) {
        return setIdleAndClearIntent(actionIntent);
    }

    if (ResourceTracker.get(ResourceType.FOOD) < FOOD_UNITS_CONSUMED_AT_ACTION_START) {
        return setForageIntent(actionIntent);
    }

    const kitchenInfo = getKitchenInfo(ecs);

    if (kitchenInfo) {
        const { id: kitchenId, transform: kitchenTransform } = kitchenInfo;
        const walkingData = actionIntent.actionData as WalkingData;

        if (locomotion.arrived &&
            actionIntent.currentPerformedAction === CharacterAction.WALKING &&
            walkingData?.type === ActionDataType.WalkingData &&
            walkingData.ultimateTargetEntityId === kitchenId) {
            // Arrived at kitchen for eating
            applyEatingBuffAndSetAction(ecs, entity, actionIntent);
        } else if (actionIntent.currentPerformedAction !== CharacterAction.WALKING || walkingData?.ultimateTargetEntityId !== kitchenId) {
            setWalkingToKitchen(actionIntent, { x: kitchenTransform.x, y: kitchenTransform.y }, kitchenId);
        }
    } else {
        // No kitchen, eat on the spot
        applyEatingBuffAndSetAction(ecs, entity, actionIntent);
    }
}

// ---

import { ECS, Entity } from "../../../../ECS";
import { ActionIntentComponent } from "../ActionIntentComponent";
import {
    CharacterAction,
    ActionDataType,
    WalkingData,
    CharacterIntent,
    ForagingActionData,
} from "../actionIntentData";
import { Transform } from "../../../../components/Transform";
import { LocomotionComponent } from "../../../locomotion/LocomotionComponent";
import { Pos } from "../../../../../utils/Math";
import { ForagableComponent } from "../../../foraging/ForagableComponent";
import { WoodDojoWorker } from "../../../buildings/wood_dojo/WoodDojoWorker";
import { HomeComponent } from "../../../buildings/dormitory/HomeComponent";
import { InteractionSlots, SlotType } from "../../../../components/InteractionSlots"; 
import { WoodDojo } from "../../../buildings/wood_dojo/WoodDojo"; // Placeholder
import { getCaveTreeLUT } from "../../../lut/getCaveTreeLUT";


function setIdleAndClearIntent(aic: ActionIntentComponent): void {
    aic.currentPerformedAction = CharacterAction.IDLE;
    aic.intentType = CharacterIntent.NONE;
    aic.actionData = null;
}

function setNoForageTargetsAvailable(aic: ActionIntentComponent): void {
    aic.intentType = CharacterIntent.REST;
    aic.currentPerformedAction = CharacterAction.IDLE;
    aic.actionData = null;
}

function setWalkingToForageSlot(aic: ActionIntentComponent, targetPosition: Pos, targetEntityId: Entity): void {
    aic.currentPerformedAction = CharacterAction.WALKING;
    aic.actionData = {
        type: ActionDataType.WalkingData,
        targetPosition,
        ultimateTargetEntityId: targetEntityId
    } as WalkingData;
}

function setForaging(aic: ActionIntentComponent, targetEntityId: Entity, slotOffset: Pos): void {
    aic.currentPerformedAction = CharacterAction.FORAGING;
    aic.actionData = {
        type: ActionDataType.ForagingActionData,
        targetForagableEntityId: targetEntityId,
        slotOffset
    } as ForagingActionData;
}

function releaseAnyForageSlotHeldByCharacter(ecs: ECS, characterEntity: Entity): void {
    // Iterate all entities that might have forage slots (e.g., those with ForagableComponent and InteractionSlots)
    const foragableEntities = ecs.getEntitiesWithComponents([ForagableComponent, InteractionSlots]);
    for (const entityId of foragableEntities) {
        ecs.getComponent(entityId, InteractionSlots)?.release(characterEntity, SlotType.FORAGE);
    }
}

function getPrimaryForagingReferencePoint(ecs: ECS, characterEntity: Entity): Entity | null {
    const workerInfo = ecs.getComponent(characterEntity, WoodDojoWorker); // Assumes WoodDojoWorker implies Kitchen access
    if (workerInfo && workerInfo.dojoId !== null && ecs.hasEntity(workerInfo.dojoId)) {
        if (ecs.hasComponent(workerInfo.dojoId, WoodDojo)) { // Replace with KitchenComponent if distinct
            return workerInfo.dojoId;
        }
    }
    const home = ecs.getComponent(characterEntity, HomeComponent);
    if (home && home.homeEntityId !== null && ecs.hasEntity(home.homeEntityId)) {
        return home.homeEntityId;
    }
    return null;
}

function findAndReserveForageTargetViaLUT(
    ecs: ECS,
    characterEntity: Entity
): { id: Entity, slotOffset: Pos } | null {
    const referenceEntityId = getPrimaryForagingReferencePoint(ecs, characterEntity);
    if (referenceEntityId === null) return null;

    const caveTreeLUTComponent = getCaveTreeLUT(ecs);
    if (!caveTreeLUTComponent || !caveTreeLUTComponent.lut) return null;

    const nearbyEntityIds = caveTreeLUTComponent.lut[referenceEntityId];

    if (nearbyEntityIds && nearbyEntityIds.length > 0) {
        for (const entityId of nearbyEntityIds) {
            if (!ecs.hasEntity(entityId)) continue;

            const foragableComponent = ecs.getComponent(entityId, ForagableComponent);
            const targetTransform = ecs.getComponent(entityId, Transform);
            const slots = ecs.getComponent(entityId, InteractionSlots);

            if (foragableComponent && foragableComponent.currentAmount > 0 && targetTransform && slots) {
                const offset = slots.reserve(characterEntity, SlotType.FORAGE); 
                if (offset) {
                    return { id: entityId, slotOffset: offset };
                }
            }
        }
    }
    return null;
}

export function handleForageIntentLogic(
    ecs: ECS,
    entity: Entity,
    actionIntent: ActionIntentComponent
): void {
    const characterTransform = ecs.getComponent(entity, Transform);
    const locomotion = ecs.getComponent(entity, LocomotionComponent);

    if (!characterTransform || !locomotion) return setIdleAndClearIntent(actionIntent);

    const currentActionData = actionIntent.actionData;

    if (actionIntent.currentPerformedAction === CharacterAction.FORAGING &&
        (currentActionData as ForagingActionData)?.type === ActionDataType.ForagingActionData) {
        const targetId = (currentActionData as ForagingActionData).targetForagableEntityId;
        if (!ecs.hasEntity(targetId) || (ecs.getComponent(targetId, ForagableComponent)?.currentAmount || 0) <= 0) {
            releaseAnyForageSlotHeldByCharacter(ecs, entity); // Release slot if target depleted
            actionIntent.actionData = null; 
        } else {
            return; 
        }
    }
    
    releaseAnyForageSlotHeldByCharacter(ecs, entity); // Ensure any old slots are cleared before finding new
    const forageTargetInfo = findAndReserveForageTargetViaLUT(ecs, entity);

    if (!forageTargetInfo) {
        return setNoForageTargetsAvailable(actionIntent);
    }

    const { id: targetId, slotOffset } = forageTargetInfo;
    const treeTransform = ecs.getComponent(targetId, Transform); 

    const exactApproachPosition = { 
        x: Math.round(treeTransform.x + slotOffset.x), 
        y: Math.round(treeTransform.y + slotOffset.y) 
    };
    
    const roundedCharX = Math.round(characterTransform.x);
    const roundedCharY = Math.round(characterTransform.y);

    if (roundedCharX !== exactApproachPosition.x || roundedCharY !== exactApproachPosition.y) {
        setWalkingToForageSlot(actionIntent, exactApproachPosition, targetId);
    } else {
        return setForaging(actionIntent, targetId, slotOffset);
    }
}

// ---

import { ECS, Entity } from "../../../../ECS";
import { ActionIntentComponent } from "../ActionIntentComponent";
import {
    CharacterAction,
    ActionDataType,
    WalkingData,
    ChoppingData,
    CharacterIntent
} from "../actionIntentData";
import { Transform } from "../../../../components/Transform";
import { Tree } from "../../../trees/Tree";
import { HarvestableComponent } from "../../../trees/HarvestableComponent";
import { InteractionSlots, SlotType } from "../../../../components/InteractionSlots";
import { Pos } from "../../../../../utils/Math";
import { WoodDojoWorker } from "../../../buildings/wood_dojo/WoodDojoWorker";
import { getCaveTreeLUT } from "../../../lut/getCaveTreeLUT";
import { HarvestingState } from "../../character-states/HarvestingState";
import { abortHarvesting } from "./abortHarvesting";
import { LocomotionComponent } from "../../../locomotion/LocomotionComponent";

function setIdle(aic: ActionIntentComponent): void {
    aic.intentType = CharacterIntent.NONE;
    aic.currentPerformedAction = CharacterAction.IDLE;
    aic.actionData = null;
}

function setWaitingOrBlocked(aic: ActionIntentComponent): void {
    aic.intentType = CharacterIntent.REST;
    aic.currentPerformedAction = CharacterAction.IDLE; 
    aic.actionData = null;
}

function setWalkingToSlot(aic: ActionIntentComponent, targetPosition: Pos, ultimateTargetId: Entity): void {
    aic.currentPerformedAction = CharacterAction.WALKING;
    aic.actionData = {
        type: ActionDataType.WalkingData,
        targetPosition,
        ultimateTargetEntityId: ultimateTargetId
    } as WalkingData;
}

function setChopping(aic: ActionIntentComponent, treeId: Entity): void {
    aic.currentPerformedAction = CharacterAction.CHOPPING;
    aic.actionData = {
        type: ActionDataType.ChoppingData,
        targetTreeEntityId: treeId
    } as ChoppingData;
}

function isTreeValidForHarvest(ecs: ECS, treeId: Entity): boolean {
    if (!ecs.hasEntity(treeId)) return false;
    const tree = ecs.getComponent(treeId, Tree);
    const harvestable = ecs.getComponent(treeId, HarvestableComponent);
    return !!(tree && tree.selectedForCutting && harvestable && harvestable.harvestable && !harvestable.harvested);
}

export function findAndReserveNewHarvestTarget(
    ecs: ECS,
    characterEntity: Entity
): boolean {
    abortHarvesting(ecs, characterEntity);

    const workerInfo = ecs.getComponent(characterEntity, WoodDojoWorker);
    if (!workerInfo || workerInfo.dojoId === null || workerInfo.dojoId === undefined) {
        return false; 
    }
    const assignedDojoId = workerInfo.dojoId;

    if (!ecs.hasEntity(assignedDojoId)) {
        return false; 
    }

    const caveTreeLUTComponent = getCaveTreeLUT(ecs); // Get the global LUT component
    if (!caveTreeLUTComponent || !caveTreeLUTComponent.lut) {
        return false; 
    }
    
    const nearbyTreeIds = caveTreeLUTComponent.lut[assignedDojoId];

    if (nearbyTreeIds && nearbyTreeIds.length > 0) {
        for (const treeId of nearbyTreeIds) {
            if (!ecs.hasEntity(treeId)) continue;

            if (isTreeValidForHarvest(ecs, treeId)) {
                const slots = ecs.getComponent(treeId, InteractionSlots);
                const transform = ecs.getComponent(treeId, Transform);

                if (!slots || !transform)
                    return false; // No interaction slots or transform, cannot harvest
                
                const offset = slots.reserve(characterEntity, SlotType.WORK);
                if (!offset) {
                    continue; // No available slot, try next tree
                }

                const targetPos = { x: offset.x + transform.x, y: offset.y + transform.y };
                const harvesting = ecs.getComponent(characterEntity, HarvestingState) ?? new HarvestingState(treeId, targetPos);
                harvesting.target = treeId;
                harvesting.targetPos = targetPos;

                !ecs.hasComponent(characterEntity, HarvestingState) && ecs.addComponent(characterEntity, harvesting);

                return true; // Successfully reserved a slot for harvesting
            }
        }
    }

    return false;
}

export function canHarvest(ecs: ECS, entity: Entity): boolean {
    const allTrees = ecs.getEntitiesWithComponents([Tree, HarvestableComponent, InteractionSlots]);
    for (const treeId of allTrees) {
        if (isTreeValidForHarvest(ecs, treeId)) {
            const slots = ecs.getComponent(treeId, InteractionSlots);
            // Check if ANY work slot is available, without reserving it.
            if (slots.getSlotsArray(SlotType.WORK).some(slot => slot.occupiedBy === null || slot.occupiedBy === entity)) {
                return true;
            }
        }
    }
    return false;
}

export function handleHarvestIntentLogic(
    ecs: ECS,
    entity: Entity,
    actionIntent: ActionIntentComponent
): void {
    const harvesting = ecs.getComponent(entity, HarvestingState);

    if (!harvesting || harvesting.target == -1){
        if (!findAndReserveNewHarvestTarget(ecs, entity)){
            setWaitingOrBlocked(actionIntent);
        }
        return;
    }

    updateActions(ecs, entity, actionIntent, harvesting);
}

function updateActions(ecs: ECS, entity:number, actionIntent: ActionIntentComponent, harvesting: HarvestingState): void {
    const { target:treeId, targetPos } = harvesting;
    if (treeId == -1 || !targetPos) {
        setIdle(actionIntent);
        return;
    }

    const locomotion = ecs.getComponent(entity, LocomotionComponent);

    if (!locomotion) {
        setIdle(actionIntent); // No locomotion component, cannot proceed
        return;
    }

    if (!locomotion.arrived) {
        setWalkingToSlot(actionIntent, targetPos, treeId);
    } else {
        // Arrived at the designated WORK slot for the target tree.
        setChopping(actionIntent, treeId);
    }
}


// ---

import { Pos, MathUtils } from "../../../../../utils/Math";
import { Entity, ECS } from "../../../../ECS";
import { Transform } from "../../../../components/Transform";
import { LocomotionComponent } from "../../../locomotion/LocomotionComponent";
import { TimeComponent, getTime } from "../../../time/TimeComponent";
import { Tree } from "../../../trees/Tree";
import { ActionIntentComponent } from "../ActionIntentComponent";
import { StrollComponent } from "../relaxation/StrollComponent";
import { CharacterAction, ActionDataType, WalkingData, StrollingAtPointData, isWalkingData, CharacterIntent } from "../actionIntentData";

const STROLL_BEHIND_TREE_OFFSET = 30;
const MAX_CANDIDATE_TREES_FOR_RANDOM_STROLL = 5;
const MIN_PAUSE_DURATION_GAME_MINUTES = 2; // e.g., 2 game minutes
const MAX_PAUSE_DURATION_GAME_MINUTES = 5; // e.g., 5 game minutes

function setIdle(aic: ActionIntentComponent): void {
    aic.intentType = CharacterIntent.NONE;
    aic.currentPerformedAction = CharacterAction.IDLE;
    aic.actionData = null;
}

function setRelaxing(aic: ActionIntentComponent): void {
    aic.currentPerformedAction = CharacterAction.RELAXING;
    aic.actionData = null;
}

function setWalkingToStrollPoint(aic: ActionIntentComponent, targetPosition: Pos, treeId?: Entity): void {
    aic.currentPerformedAction = CharacterAction.WALKING;
    aic.actionData = {
        type: ActionDataType.WalkingData,
        targetPosition,
        ultimateTargetEntityId: treeId
    } as WalkingData;
}

function setStrollingAtPoint(aic: ActionIntentComponent, treeId: Entity): void {
    aic.currentPerformedAction = CharacterAction.STROLLING;
    aic.actionData = {
        type: ActionDataType.StrollingAtPointData,
        atTreeEntityId: treeId
    } as StrollingAtPointData;
}

function findValidStrollTrees(ecs: ECS, excludeTreeId?: Entity): { id: Entity, transform: Transform }[] {
    const treeEntities = ecs.getEntitiesWithComponents([Tree, Transform]);
    const validTrees: { id: Entity, transform: Transform }[] = [];
    for (const treeId of treeEntities) {
        if (treeId === excludeTreeId) continue;
        validTrees.push({ id: treeId, transform: ecs.getComponent(treeId, Transform) });
    }
    return validTrees;
}

function selectNextStrollTarget(
    ecs: ECS,
    currentPosOrReferenceTransform: Transform,
    referenceTransformForOrientation: Transform,
    lastTargetTreeId?: Entity
): { treeId: Entity, strollTargetPos: Pos } | null {
    const availableTrees = findValidStrollTrees(ecs, lastTargetTreeId);
    if (availableTrees.length === 0) return null;

    const candidates = availableTrees.map(t => ({
        id: t.id,
        transform: t.transform,
        distSq: MathUtils.distance(currentPosOrReferenceTransform, t.transform) ** 2
    })).sort((a, b) => a.distSq - b.distSq);

    if (candidates.length === 0) return null;
    const selectionPool = candidates.slice(0, MAX_CANDIDATE_TREES_FOR_RANDOM_STROLL);
    const chosenTreeInfo = selectionPool[Math.floor(Math.random() * selectionPool.length)];
    
    const strollTargetPos = calculateBehindTreePosition(chosenTreeInfo.transform, referenceTransformForOrientation);
    return { treeId: chosenTreeInfo.id, strollTargetPos };
}

function calculateBehindTreePosition(treePos: Pos, referencePos: Pos): Pos {
    const dirVector = MathUtils.normalize(MathUtils.subtract(treePos, referencePos));
    if (dirVector.x === 0 && dirVector.y === 0) {
        return { x: treePos.x + STROLL_BEHIND_TREE_OFFSET, y: treePos.y };
    }
    return MathUtils.add(treePos, MathUtils.multiply(dirVector, STROLL_BEHIND_TREE_OFFSET));
}

export function handleRestIntentLogic(
    ecs: ECS,
    entity: Entity,
    actionIntent: ActionIntentComponent
): void {
    const locomotion = ecs.getComponent(entity, LocomotionComponent);
    const strollComp = ecs.getComponent(entity, StrollComponent);
    const characterTransform = ecs.getComponent(entity, Transform);

    if (!locomotion || !characterTransform) return setIdle(actionIntent);
    if (!strollComp) return setRelaxing(actionIntent);

    const currentGameTime = getTime(ecs).minutesElapsed;

    if (strollComp.isPausedAtTarget) {
        if (currentGameTime >= strollComp.pauseUntilTime) {
            strollComp.isPausedAtTarget = false;
            strollComp.lastTargetTreeId = strollComp.currentTargetTreeId;
            strollComp.currentTargetTreeId = undefined;
            strollComp.currentPathTargetPos = undefined;
        } else {
            if (strollComp.currentTargetTreeId) {
                setStrollingAtPoint(actionIntent, strollComp.currentTargetTreeId);
            } else { 
                setRelaxing(actionIntent);
            }
            return;
        }
    }

    if (!strollComp.currentPathTargetPos || !strollComp.currentTargetTreeId) {
        const referenceTransform = ecs.getComponent(strollComp.referencePointEntityId, Transform);
        if (!referenceTransform) {
            ecs.removeComponent(entity, StrollComponent);
            return setRelaxing(actionIntent);
        }
        
        const lastTreePosSource = strollComp.lastTargetTreeId ? ecs.getComponent(strollComp.lastTargetTreeId, Transform) : referenceTransform;
        const nextTargetInfo = selectNextStrollTarget(ecs, lastTreePosSource, referenceTransform, strollComp.lastTargetTreeId);

        if (nextTargetInfo) {
            strollComp.currentTargetTreeId = nextTargetInfo.treeId;
            strollComp.currentPathTargetPos = nextTargetInfo.strollTargetPos;
            actionIntent.actionData = null;
        } else {
            ecs.removeComponent(entity, StrollComponent);
            return setRelaxing(actionIntent);
        }
    }
    
    // We're still walking
    if (!locomotion.arrived) {
        const currentWalkData = actionIntent.actionData as WalkingData | null;
        if (actionIntent.currentPerformedAction !== CharacterAction.WALKING ||
            !isWalkingData(currentWalkData) ||
            currentWalkData.ultimateTargetEntityId !== strollComp.currentTargetTreeId) {
            
            setWalkingToStrollPoint(actionIntent, strollComp.currentPathTargetPos!, strollComp.currentTargetTreeId);
        }

        return;
    } 
    
    // We've arrived, waiting around
    if (actionIntent.currentPerformedAction != CharacterAction.STROLLING) {
        setStrollingAtPoint(actionIntent, strollComp.currentTargetTreeId!);
        strollComp.isPausedAtTarget = true;
        const pauseDuration = Math.random() * (MAX_PAUSE_DURATION_GAME_MINUTES - MIN_PAUSE_DURATION_GAME_MINUTES) + MIN_PAUSE_DURATION_GAME_MINUTES;
        strollComp.pauseUntilTime = currentGameTime + pauseDuration;
    }

    if (strollComp.pauseUntilTime >= currentGameTime){
        setWalkingToStrollPoint(actionIntent, {x:0,y:0});
    }
}

// ---

// src/game/logic/action-intent/intent-handlers/handleSleepIntentLogic.ts
import { ECS, Entity } from "../../../../ECS";
import { ActionIntentComponent } from "../ActionIntentComponent";
import {
    CharacterAction,
    ActionDataType,
    WalkingData,
    SleepingData, // This is for actionIntent.actionData
    CharacterIntent
} from "../actionIntentData";
import { Transform } from "../../../../components/Transform";
import { InteractionSlots, SlotType } from "../../../../components/InteractionSlots";
import { DormitoryComponent } from "../../../buildings/dormitory/DormitoryComponent";
import { Pos } from "../../../../../utils/Math";
import { abortSleeping } from "./abortSleeping"; // New helper
import { SleepingState } from "../../character-states/SleepingState";
import { LocomotionComponent } from "../../../locomotion/LocomotionComponent";

function setIdle(aic: ActionIntentComponent): void {
    aic.intentType = CharacterIntent.NONE;
    aic.currentPerformedAction = CharacterAction.IDLE;
    aic.actionData = null;
}

function setWalkingToSlot(aic: ActionIntentComponent, targetPosition: Pos, ultimateTargetId: Entity): void {
    aic.currentPerformedAction = CharacterAction.WALKING;
    aic.actionData = {
        type: ActionDataType.WalkingData,
        targetPosition,
        ultimateTargetEntityId: ultimateTargetId
    } as WalkingData;
}

function setSleepingAction(aic: ActionIntentComponent, bedEntityId: Entity, slotOffset: Pos): void {
    aic.currentPerformedAction = CharacterAction.SLEEPING;
    aic.actionData = {
        type: ActionDataType.SleepingData, // Ensure this is defined in ActionDataType
        bedEntityId,
        slotOffset
    } as SleepingData;
}

export function canSleep(ecs: ECS, entity: Entity): boolean {
    return true; // Placeholder for any conditions that might prevent sleeping
}

function findAndAssignBed(ecs: ECS, characterEntity: Entity): boolean {
    abortSleeping(ecs, characterEntity); // Clear previous assignment and release slot

    const allDormitories = ecs.getEntitiesWithComponents([DormitoryComponent, InteractionSlots, Transform]);
    
    for (const dormitoryId of allDormitories) {
        const slots = ecs.getComponent(dormitoryId, InteractionSlots);

        const offset = slots.reserve(characterEntity, SlotType.SLEEP);
        if (offset) {
            const transform = ecs.getComponent(dormitoryId, Transform);
            const targetPosition = {
                x: transform.x + offset.x,
                y: transform.y + offset.y
            };

            let sleeping = ecs.getComponent(characterEntity, SleepingState);
            if (!sleeping) {
                sleeping = new SleepingState(dormitoryId, targetPosition);
                ecs.addComponent(characterEntity, sleeping);
            } else {
                sleeping.targetBedEntityId = dormitoryId;
                sleeping.targetPosition = targetPosition;
            }
            return true; // Successfully assigned a bed
        }
    }
    return false; // No bed found or slot reserved
}


export function handleSleepIntentLogic(
    ecs: ECS,
    entity: Entity,
    actionIntent: ActionIntentComponent
): void {
    const sleeping = ecs.getComponent(entity, SleepingState);

    if (!sleeping) {
        if (!findAndAssignBed(ecs, entity)) {
            setIdle(actionIntent);
        }
        return;
    }

    const locomotion = ecs.getComponent(entity, LocomotionComponent);

    if (!locomotion) {
        setIdle(actionIntent); // No locomotion component, cannot proceed
        return;
    }

    if (!locomotion.arrived) {
        setWalkingToSlot(actionIntent, sleeping.targetPosition!, sleeping.targetBedEntityId);
    } else {
        setSleepingAction(actionIntent, sleeping.targetBedEntityId, sleeping.targetPosition!);
    }
}

// ---

import { Entity, System } from "../../../../ECS";
import { BuffsComponent } from "../../../buffs/BuffsComponent";
import { BuffType } from "../../../buffs/buffsData";
import { DormitoryComponent } from "../../../buildings/dormitory/DormitoryComponent";
import { HomeComponent } from "../../../buildings/dormitory/HomeComponent";
import { WoodDojo } from "../../../buildings/wood_dojo/WoodDojo";
import { getTime } from "../../../time/TimeComponent";
import { ActionIntentComponent } from "../ActionIntentComponent";
import { StrollComponent } from "./StrollComponent";
import { CharacterIntent } from "../actionIntentData";


export class RelaxBehaviorSystem extends System {
    public componentsRequired = new Set<Function>([
        ActionIntentComponent
    ]);

    public update(entities: Set<Entity>, delta: number): void {
        for (const entity of entities) {
            const actionIntent = this.ecs.getComponent(entity, ActionIntentComponent);
            const hasStrollComponent = this.ecs.hasComponent(entity, StrollComponent);

            if (actionIntent.intentType === CharacterIntent.REST) {
                if (!hasStrollComponent) {
                    // Intent is REST, but not yet strolling. Initiate stroll.
                    const referencePointEntityId: Entity | null = this.getStrollRefPointEntityId(entity);

                    if (referencePointEntityId !== null) {
                        this.ecs.addComponent(entity, new StrollComponent(referencePointEntityId));
                        const buffs = this.ecs.getComponent(entity, BuffsComponent);
                        const time = getTime(this.ecs);
                        
                        buffs?.addBuff(BuffType.STROLL_SPEED, time.minutesElapsed);
                    }
                }
                // If already has StrollComponent and intent is REST, StrollSystem/handleRestIntentLogic manages it.
            } else {
                // Intent is NOT REST. If character was strolling, clean up.
                if (hasStrollComponent) {
                    this.ecs.removeComponent(entity, StrollComponent);
                    const buffs = this.ecs.getComponent(entity, BuffsComponent);
                    buffs?.removeBuff(BuffType.STROLL_SPEED);
                }
            }
        }
    }

    private getStrollRefPointEntityId(entity: number) {
        const home = this.ecs.getComponent(entity, HomeComponent);
        if (home && home.homeEntityId !== null && this.ecs.hasEntity(home.homeEntityId)) {
            return home.homeEntityId;
        } else {
            const dorms = this.ecs.getEntitiesWithComponent(DormitoryComponent);
            if (dorms.length > 0) return dorms[0];
            else {
                const dojos = this.ecs.getEntitiesWithComponent(WoodDojo);
                if (dojos.length > 0) return dojos[0];
            }
        }
        return null;
    }
}

// ---

import { Pos } from "../../../../../utils/Math";
import { Component, Entity } from "../../../../ECS";

export class StrollComponent extends Component {
    public referencePointEntityId: Entity;
    public currentPathTargetPos?: Pos;
    public currentTargetTreeId?: Entity;
    public lastTargetTreeId?: Entity;
    public isPausedAtTarget: boolean = false;
    public pauseUntilTime: number = 0; 

    constructor(
        referencePointEntityId: Entity,
        initialTargetTreeId?: Entity,
        initialPathTargetPos?: Pos
    ) {
        super();
        this.referencePointEntityId = referencePointEntityId;
        this.currentTargetTreeId = initialTargetTreeId;
        this.currentPathTargetPos = initialPathTargetPos;
    }
}

// ---

import { ECS, Entity } from "../../../ECS";
import { ActionIntentComponent } from "../intent-to-action/ActionIntentComponent";
import { canSleep as canSleep } from "../intent-to-action/intent-handlers/handleSleepIntentLogic";
import { ScheduleComponent } from "../../characters/ScheduleComponent";
import { NeedType, NeedsComponent } from "../../needs/NeedsComponent";
import { CharacterAction } from "../intent-to-action/actionIntentData";

export function calculateEatIntentWeight(ecs: ECS, entity: Entity, intent: ActionIntentComponent, schedule: ScheduleComponent, needs: NeedsComponent, currentHour: number): number {
    let weight = 0;
    const eat = needs.need(NeedType.FOOD);

    if (!eat){
        return 0;
    }

    const eatNeed = eat.current / eat.max; // Normalized 1.0 (full) to 0.0 (empty)

    if (eatNeed < 0.3) weight += 200 * (1 - eatNeed);   // Starving!
    else if (eatNeed < 0.85) weight += 50 * (1 - eatNeed); // Hungry

    if (eatNeed >= 1){
        return 0;
    }

    if (intent.currentPerformedAction == CharacterAction.EATING){
        weight += 100;
    }

    return canSleep(ecs, entity) ? weight : 0;
}


// ---

import { ECS, Entity } from "../../../ECS";
import { CharacterIntent } from "../intent-to-action/actionIntentData";
import { canHarvest as canHarvest } from "../intent-to-action/intent-handlers/handleHarvestIntentLogic";
import { ScheduleComponent } from "../../characters/ScheduleComponent";
import { NeedsComponent } from "../../needs/NeedsComponent";

export function calculateHarvestIntentWeight(ecs: ECS, entity: Entity, schedule: ScheduleComponent, needs: NeedsComponent, currentHour: number): number {
    if (schedule.entries[currentHour] !== CharacterIntent.HARVEST) return 0;
    return canHarvest(ecs, entity) ? 100 : 0;
}


// ---

import { ECS, Entity } from "../../../ECS";
import { CharacterIntent } from "../intent-to-action/actionIntentData";
import { ScheduleComponent } from "../../characters/ScheduleComponent";
import { NeedsComponent } from "../../needs/NeedsComponent";

export function calculateRestIntentWeight(ecs: ECS, entity: Entity, schedule: ScheduleComponent, needs: NeedsComponent, currentHour: number): number {
    if (schedule.entries[currentHour] === CharacterIntent.REST) return 10;
    return 10;
}


// ---

import { ECS, Entity } from "../../../ECS";
import { ActionIntentComponent } from "../intent-to-action/ActionIntentComponent";
import { CharacterIntent } from "../intent-to-action/actionIntentData";
import { canSleep as canSleep } from "../intent-to-action/intent-handlers/handleSleepIntentLogic";
import { ScheduleComponent } from "../../characters/ScheduleComponent";
import { NeedType, NeedsComponent } from "../../needs/NeedsComponent";

export function calculateSleepIntentWeight(ecs: ECS, entity: Entity, intent: ActionIntentComponent, schedule: ScheduleComponent, needs: NeedsComponent, currentHour: number): number {
    let weight = 0;
    const sleep = needs.need(NeedType.SLEEP);

    if (!sleep){
        return 0;
    }

    const sleepNeed = sleep.current / sleep.max; // Normalized 1.0 (full) to 0.0 (empty)

    if (sleepNeed < 0.3) weight += 200 * (1 - sleepNeed); // Very high weight if very tired
    else if (sleepNeed < 0.6) weight += 50 * (1 - sleepNeed);

    if (sleepNeed >= 1){
        return 0;
    }

    if (schedule.entries[currentHour] === CharacterIntent.SLEEP) {
        weight += 20;
    }

    if (intent.intentType == CharacterIntent.SLEEP){
        weight += 100;
    }

    return canSleep(ecs, entity) ? weight : 0;
}


// ---

import { Component } from "../../ECS";

export class InsideLocationComponent extends Component {}

// ---

import { Component } from "../../ECS.ts";
import { Pos } from "../../../utils/Math.ts";

export class LocomotionComponent extends Component {
    public destination: Pos;
    public speed: number = 1;
    public arrived: boolean = false;

  constructor(
  ) {
    super();
  }
}


// ---

import { System, Entity } from "../../ECS";
import { LocationState, Transform } from "../../components/Transform";
import { ActionIntentComponent } from "../intent/intent-to-action/ActionIntentComponent";
import { CharacterAction, WalkingData} from "../intent/intent-to-action/actionIntentData";
import { getTime } from "../time/TimeComponent";
import { LocomotionComponent } from "./LocomotionComponent";
import { Pos } from "../../../utils/Math";
import { InsideLocationComponent } from "./InsideLocationComponent";
import { StatCalculator } from "../buffs/StatCalculator";
import { AffectedStat } from "../buffs/buffsData";

export class LocomotionSystem extends System {
    public componentsRequired = new Set<Function>([
        LocomotionComponent,
        Transform,
        ActionIntentComponent,
    ]);

    public update(entities: Set<Entity>, delta: number): void {
        const time = getTime(this.ecs);
        if (time.speedFactor === 0) return;

        const scaledDelta = delta * time.speedFactor;

        for (const entity of entities) {
            const locomotion = this.ecs.getComponent(entity, LocomotionComponent);
            const transform = this.ecs.getComponent(entity, Transform);
            const actionIntent = this.ecs.getComponent(entity, ActionIntentComponent);

            if (!this.isEntityActivelyWalking(actionIntent)) {
                continue;
            }

            const walkData = actionIntent.actionData as WalkingData;
            const targetPosition = { 
                x: Math.round(walkData.targetPosition.x), 
                y: Math.round(walkData.targetPosition.y) 
            };

            const isArrived = this.processArrival(locomotion, transform, targetPosition);
            
            if (isArrived) {
                this.updateLocationState(transform, walkData.ultimateTargetEntityId, isArrived);
                continue; 
            }

            transform.locationState = LocationState.OUTSIDE;
            
            const speed = StatCalculator.getEffectiveStat(this.ecs, entity, AffectedStat.LOCOMOTION_SPEED);
            this.performMovementStep(transform, targetPosition, speed * scaledDelta);
            this.updateSpriteDirection(transform, targetPosition.x - transform.x);
        }
    }

    private isEntityActivelyWalking(actionIntent: ActionIntentComponent): boolean {
        return actionIntent.currentPerformedAction == CharacterAction.WALKING && !!(actionIntent?.actionData?.targetPosition);
    }

    private processArrival(locomotion: LocomotionComponent, transform: Transform, targetPos: Pos): boolean {
        const roundedCurrentX = Math.round(transform.x);
        const roundedCurrentY = Math.round(transform.y);

        if (roundedCurrentX === targetPos.x && roundedCurrentY === targetPos.y) {
            if (!locomotion.arrived) { // Actions for first arrival at exact spot
                transform.x = targetPos.x; 
                transform.y = targetPos.y;
                locomotion.arrived = true;
            }
            return true; // Is at target
        } else if (locomotion.arrived) {
            locomotion.arrived = false; // Reset arrived state if not at target
        }

        return false; // Not at target
    }
    
    private updateLocationState(transform: Transform, ultimateTargetEntityId: Entity | undefined, isArrivedAtTarget: boolean): void {
        if (ultimateTargetEntityId && this.ecs.hasEntity(ultimateTargetEntityId) && this.ecs.hasComponent(ultimateTargetEntityId, InsideLocationComponent)) {
            transform.locationState = isArrivedAtTarget ? LocationState.INSIDE : LocationState.OUTSIDE;
        }
    }

    private performMovementStep(transform: Transform, targetPos: Pos, stepDistance: number): void {
        const dx = targetPos.x - transform.x;
        const dy = targetPos.y - transform.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist <= stepDistance || dist === 0) {
            transform.x = targetPos.x; // Snap to exact rounded target
            transform.y = targetPos.y;
            // locomotion.arrived will be set true in the next frame by processArrival
        } else {
            transform.x += (dx / dist) * stepDistance;
            transform.y += (dy / dist) * stepDistance;
        }
    }

    private updateSpriteDirection(transform: Transform, dxToTarget: number): void {
        if (dxToTarget !== 0) {
            transform.direction = dxToTarget > 0 ? -1 : 1; // Assuming -1 is right, 1 is left
        }
    }
}

// ---

import { Component } from "../../ECS";

export class CaveTreeLUTComponent extends Component {
    constructor(public lut: Record<number, number[]>) {
        super();
    }
}

// ---

import { Pos } from "../../../utils/Math";
import { View } from "../../display/setup/View";
import { ViewType } from "../../display/setup/ViewDefinition";

// Output: caveEntityId → sorted array of nearby tree entityIds
export function buildCaveTreeLUTFromViews(views: Map<number, View>): Record<number, number[]> {
    const caves: { id: number; pos: Pos }[] = [];
    const trees: { id: number; pos: Pos }[] = [];

    for (const [entity, view] of views) {
        if (view.type === ViewType.CAVE) {
            caves.push({ id: entity, pos: view.viewDefinition.position });
        } else if (view.type === ViewType.TREE) {
            trees.push({ id: entity, pos: view.viewDefinition.position });
        }
    }

    const result: Record<number, number[]> = {};

    for (const cave of caves) {
        const sortedTrees = trees
            .map(tree => ({
                id: tree.id,
                distSq: distanceSq(cave.pos, tree.pos)
            }))
            .sort((a, b) => a.distSq - b.distSq)
            .map(t => t.id);

        result[cave.id] = sortedTrees;
    }

    return result;
}

function distanceSq(a: Pos, b: Pos): number {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return dx * dx + dy * dy;
}


// ---

import { ECS } from "../../ECS";
import { getWorldEntity } from "../serialization/getWorldEntity";
import { CaveTreeLUTComponent } from "./CaveTreeLUTComponent"; 

export function getCaveTreeLUT(ecs: ECS): CaveTreeLUTComponent {
    const worldId = getWorldEntity(ecs); // Ensures world entity exists

    if (!ecs.hasComponent(worldId, CaveTreeLUTComponent)) {
        ecs.addComponent(worldId, new CaveTreeLUTComponent({})); // Initialize with empty LUT
    }
    return ecs.getComponent(worldId, CaveTreeLUTComponent);
}

// ---

import { System, Entity, ECS } from "../../ECS";
import { getDeltaInGameMinutes } from "../../display/utils/getDeltaInGameMinutes";
import { StatCalculator } from "../buffs/StatCalculator";
import { AffectedStat } from "../buffs/buffsData";
import { NeedType, NeedsComponent } from "./NeedsComponent";

export class FoodNeedSystem extends System {
    public componentsRequired = new Set<Function>([NeedsComponent]);

    public update(entities: Set<Entity>, delta: number): void {
        const gameMinutesPassedThisFrame = getDeltaInGameMinutes(this.ecs, delta);
        if (gameMinutesPassedThisFrame === 0) return;

        for (const entity of entities) {
            const needsComponent = this.ecs.getComponent(entity, NeedsComponent);
            if (!needsComponent) continue;

            const foodNeed = needsComponent.need(NeedType.FOOD);
            if (!foodNeed) {
                // This char doesn't need to eat
                continue;
            }

            const foodModificationRate = StatCalculator.getEffectiveStat(this.ecs, entity, AffectedStat.HUNGER_MODIFICATION_RATE);
            
            const newCurrent = foodNeed.current + foodModificationRate * gameMinutesPassedThisFrame;
            
            needsComponent.updateNeedCurrent(NeedType.FOOD, newCurrent);
        }
    }
}

// ---

import { Component } from "../../ECS";

export enum NeedType {
    SLEEP = "Sleep",
    FOOD = "Hunger"
}

export interface NeedData {
    current:number,
    max:number
}

export class NeedsComponent extends Component {
    public needs: Map<NeedType, NeedData>;

    constructor(initialNeeds?: Map<NeedType, NeedData>) {
        super();
        this.needs = initialNeeds || new Map<NeedType, NeedData>();
    }

    public need(type: NeedType): NeedData | undefined {
        return this.needs.get(type);
    }

    public updateNeedCurrent(type: NeedType, amount: number, delta:boolean = false): void {
        const need = this.needs.get(type);
        if (need) {
            if (delta){
                need.current = Math.max(0, Math.min(need.current + amount, need.max));
            } else {
                need.current = Math.max(0, Math.min(amount, need.max));
            }
        }
    }

    public setNeed(type: NeedType, current: number, max: number): void {
        this.needs.set(type, { current, max });
    }
}

// ---

import { System, Entity, ECS } from "../../ECS";
import { getDeltaInGameMinutes } from "../../display/utils/getDeltaInGameMinutes";
import { StatCalculator } from "../buffs/StatCalculator";
import { AffectedStat } from "../buffs/buffsData";
import { NeedType, NeedsComponent } from "./NeedsComponent";

export class SleepNeedSystem extends System {
    public componentsRequired = new Set<Function>([NeedsComponent]);


    public update(entities: Set<Entity>, delta: number): void {
        const gameMinutesPassedThisFrame = getDeltaInGameMinutes(this.ecs, delta);
        if (gameMinutesPassedThisFrame === 0) return;

        for (const entity of entities) {
            const needs = this.ecs.getComponent(entity, NeedsComponent);
            const sleep = needs.need(NeedType.SLEEP);
            if (!sleep){
                // This char doesn't need to sleep
                return;
            }
            const sleepModificationRate = StatCalculator.getEffectiveStat(this.ecs, entity, AffectedStat.SLEEP_MODIFICATION_RATE);
            const newCurrent = Math.max(0, Math.min(sleep.current + sleepModificationRate * gameMinutesPassedThisFrame, sleep.max));
            needs.updateNeedCurrent(NeedType.SLEEP, newCurrent);
        }
    }
}

// ---

import { Component } from "../../ECS";

export class SleepingComponent extends Component {

}

// ---

import { Component } from "../../ECS";
import { ResourceType } from "./ResourceType";

export class ResourceComponent extends Component {
    public amounts: Record<ResourceType, number> = {
        [ResourceType.MONEY]: 10,
        [ResourceType.WOOD]: 0,
        [ResourceType.FOOD]: 100,
        [ResourceType.TOOLS]: 0
    };
}


// ---

import { ResourceType } from "./ResourceType";

export interface ResourceDefinition {
    icon: string;         // Path to icon
    description: string;  // Human-friendly tooltip or label
}

export const ResourceConfig: Record<ResourceType, ResourceDefinition> = {
    [ResourceType.MONEY]: {
        icon: "assets/icons/money_icon.png",
        description: "Money"
    },
    [ResourceType.WOOD]: {
        icon: "assets/icons/wood_icon.png",
        description: "Wood"
    },
    [ResourceType.FOOD]: {
        icon: "assets/icons/food_icon.png",
        description: "Food"
    },
    [ResourceType.TOOLS]: {
        icon: "assets/icons/tools_icon.png",
        description: "Tools"
    }
};


// ---

import { System, Entity } from "../../ECS";
import { ResourceComponent } from "./ResourceComponent";
import { ResourceTracker } from "./ResourceTracker";
import { ResourceType } from "./ResourceType";

export class ResourceSystem extends System {
    public componentsRequired = new Set<Function>([ResourceComponent]);

    private lastState: Record<ResourceType, number> = {
        [ResourceType.MONEY]: -1,
        [ResourceType.WOOD]: -1,
        [ResourceType.FOOD]: -1,
        [ResourceType.TOOLS]: -1
    };

    update(resEntities: Set<Entity>, __: number): void {
        for (const entity of resEntities){
            const res = this.ecs.getComponent(entity, ResourceComponent);
            const changed: Partial<Record<ResourceType, number>> = {};
    
            for (const type of Object.values(ResourceType)) {
                const current = Math.max(0, Math.floor(res.amounts[type]));
                if (current !== this.lastState[type]) {
                    this.lastState[type] = current;
                    changed[type] = current;
                }
            }
    
            if (Object.keys(changed).length > 0) {
                ResourceTracker.bulkSet(changed);
            }
        }
    }
}


// ---

import { EventBus } from "../../EventBus";
import { GameEvent } from "../../consts/GameEvent";
import { ResourceType } from "./ResourceType";

type ResourceListener = (resources: Partial<Record<ResourceType, number>>) => void;

export class ResourceTracker {
    private static resources: Record<ResourceType, number> = {
        [ResourceType.MONEY]: 0,
        [ResourceType.WOOD]: 0,
        [ResourceType.FOOD]: 0,
        [ResourceType.TOOLS]: 0
    };

    private static listeners: Set<ResourceListener> = new Set();

    static get(type: ResourceType): number {
        return this.resources[type];
    }

    static set(type: ResourceType, value: number) {
        const clamped = Math.max(0, Math.floor(value));
        if (clamped !== this.resources[type]) {
            this.resources[type] = clamped;
            this.notify([type]);
        }
    }

    static add(type: ResourceType, delta: number) {
        this.set(type, this.resources[type] + delta);
    }

    static bulkSet(values: Partial<Record<ResourceType, number>>) {
        const changed: ResourceType[] = [];
        for (const type in values) {
            const t = type as ResourceType;
            const val = Math.max(0, Math.floor(values[t]!));
            if (val !== this.resources[t]) {
                this.resources[t] = val;
                changed.push(t);
            }
        }
        if (changed.length > 0) this.notify(changed);
    }

    static subscribe(fn: ResourceListener) {
        this.listeners.add(fn);
    }

    static unsubscribe(fn: ResourceListener) {
        this.listeners.delete(fn);
    }

    private static notify(changed: ResourceType[]) {
        const changedValues: Partial<Record<ResourceType, number>> = {};
        for (const type of changed) {
            changedValues[type] = this.resources[type];
        }
        this.listeners.forEach(fn => fn(changedValues));
        EventBus.emit(GameEvent.ResourcesUpdated, changedValues);
    }
}


// ---

export enum ResourceType {
    MONEY = "money",
    WOOD = "wood",
    FOOD = "food",
    TOOLS = "tools"
}


// ---


// All components should be serializable to JSON.
import {Entity} from "../../ECS.ts";

export interface GameState {
    entities: EntityState[];
}

export interface EntityState {
    id: Entity;
    components: Record<string, any>; // key = component class name, value = serialized data
}


// ---


// Registry to map component names to classes for deserialization
import {Component, ECS} from "../../ECS.ts";
import {Transform} from "../../components/Transform.ts";
import {Tree} from "../trees/Tree.ts";
import {Cave} from "../buildings/Cave.ts";
import {EntityState, GameState} from "./GameState.ts";
import {EventBus} from "../../EventBus.ts";
import {GameEvent} from "../../consts/GameEvent.ts";
import {InputComponent} from "../input/InputComponent.ts";
import {TimeComponent} from "../time/TimeComponent.ts";

const componentRegistry: Record<string, new (...args: any[]) => Component> = {
    Transform,
    Tree,
    Cave,
    InputComponent,
    TimeComponent
};

export function serializeECS(ecs: ECS): GameState {
    const entities: EntityState[] = [];

    for (const [entityId, container] of ecs["entities"].entries()) {
        const components: Record<string, any> = {};
        for (const [key, component] of container["map"].entries()) {
            components[key.name] = { ...component }; // assumes components are plain data
        }
        entities.push({ id: entityId, components });
    }

    return { entities };
}

export function loadFromState(ecs: ECS, state: GameState): void {
    // Sort by entity ID to ensure ECS assigns them in matching order
    state.entities.sort((a, b) => a.id - b.id);
    for (const entityState of state.entities) {
        const entity = ecs.addEntity(); // creates a new ID, ignores the original one
        for (const [name, data] of Object.entries(entityState.components)) {
            const CompClass = componentRegistry[name];
            if (!CompClass) {
                console.warn(`Unknown component type: ${name}`);
                continue;
            }
            const instance = Object.assign(new CompClass(), data);
            ecs.addComponent(entity, instance);
        }
    }
    EventBus.emit(GameEvent.GameLoaded);
}


// ---

import {MapDefinition} from "./MapTypes.ts";
import {ECS} from "../../ECS.ts";
import {Transform} from "../../components/Transform.ts";
import {Tree} from "../trees/Tree.ts";
import {CaveSpriteKey, PlantSpriteKey} from "../../display/setup/SpriteLibrary.ts";
import {Cave} from "../buildings/Cave.ts";
import {EventBus} from "../../EventBus.ts";
import {GameEvent} from "../../consts/GameEvent.ts";
import { ViewDefinition } from "../../display/setup/ViewDefinition.ts";
import { WoodDojo } from "../buildings/wood_dojo/WoodDojo.ts";
import { HarvestableComponent } from "../trees/HarvestableComponent.ts";
import { ResourceType } from "../resources/ResourceType.ts";
import { InteractionSlots, SlotLayout, SlotType } from "../../components/InteractionSlots.ts";
import { initWorld, createProfessorBooker } from "./init.ts";
import { DormitoryComponent } from "../buildings/dormitory/DormitoryComponent.ts";
import { InsideLocationComponent } from "../locomotion/InsideLocationComponent.ts";
import { ForagableComponent } from "../foraging/ForagableComponent.ts";

function loadMapIntoECS(ecs: ECS, map: MapDefinition): void {
    for (const [id, obj] of Object.entries(map.objects)) {
        const entity = ecs.addEntity();

        // Use view position if available, otherwise skip
        if (obj.components?.view) {
            const view = obj.components.view;
            ecs.addComponent(entity, new Transform(view.position.x, view.position.y));
        }

        const def = obj.components?.view;
        
        if (!def) {
            console.warn(`Object ${id} is missing a view component.`);
            continue;
        }
        
        switch (obj.type) {
            case "tree":
                if (def.spriteName) {
                    ecs.addComponent(entity, new Tree(def.spriteName as PlantSpriteKey));
                    ecs.addComponent(entity, new HarvestableComponent(1000, [{type:ResourceType.WOOD, amount:10}]));
                    ecs.addComponent(entity, new ForagableComponent(ResourceType.FOOD, 20, 20, 0.001, 0.02));
                    ecs.addComponent(entity, new InteractionSlots({
                        [SlotType.WORK]: { layout: SlotLayout.RADIAL, radius: 120, count: 2 },
                        [SlotType.FORAGE]: { layout: SlotLayout.RADIAL, radius: 120, count: 4 }
                      }));
                }
                else {
                    console.warn(`Tree object ${id} is missing a sprite key.`);
                }
                break;
            case "cave":
                if (def.spriteName) {
                    createCave(def, ecs, entity);
                } else {
                    console.warn(`Cave object ${id} is missing a sprite key.`);
                }
                break;

            default:
                console.warn(`Unknown object type: ${obj.type}`);
                break;
        }

        const panelDef = def.panelDefinition;
        
        if (!panelDef) {
            continue;
        }
    }
}

function createCave(def: ViewDefinition, ecs: ECS, entity: number) {
    switch (def.spriteName as CaveSpriteKey) {
        case 'cave':
            ecs.addComponent(entity, new InsideLocationComponent());
            ecs.addComponent(entity, new Cave(false));
            break;
        case 'wood_dojo':
            ecs.addComponent(entity, new InsideLocationComponent());
            ecs.addComponent(entity, new WoodDojo());
            ecs.addComponent(entity, new DormitoryComponent());
            ecs.addComponent(entity, new InteractionSlots({
                [SlotType.SLEEP]: { layout: SlotLayout.RADIAL, radius: 100, count: 5 }
              }));
            break;
        default:
            console.warn(`Unknown cave sprite key: ${def.spriteName}`);
            break;
    }
}

// =============================
// Game Entry: Load New Game
// =============================
export function loadNewGame(ecs: ECS, scene: Phaser.Scene): void {
    const rawData = scene.cache.json.get('forestMap');
    if (!rawData) {
        console.error('Failed to load forestMap from cache.');
        return;
    }

    const mapDefinition = rawData as MapDefinition;
    loadMapIntoECS(ecs, mapDefinition);
    initWorld(ecs);
    createProfessorBooker(ecs);
    EventBus.emit(GameEvent.GameLoaded);
} 


// ---

import {ViewDefinition} from "../../display/setup/ViewDefinition.ts";

export type MapObjectType = 'tree' | 'rock' | 'cave'; // extend freely

export interface MapObject {
    id: number;
    type: MapObjectType;
    name?: string;
    components?: {
        view?: ViewDefinition;
    };
    zHint?: number; // zHint is used to determine the rendering order of objects
}

export interface MapDefinition {
    name: string;
    hill: ViewDefinition;
    objects: Record<number, MapObject>;
}

// ---

// src/game/logic/world/worldUtils.ts
import { ECS, Entity } from "../../ECS"; // Adjust path as needed

let cachedWorldEntityId: Entity | null | undefined = undefined;

/**
 * Retrieves or creates the single world entity ID.
 * Ensures a consistent entity ID is used for global state components.
 * @param ecs The ECS instance.
 * @returns The world entity ID.
 */
export function getWorldEntity(ecs: ECS): Entity {
    // Check cache first, and validate if the cached entity still exists
    if (
        cachedWorldEntityId !== undefined &&
        cachedWorldEntityId !== null &&
        ecs.hasEntity(cachedWorldEntityId)
    ) {
        return cachedWorldEntityId;
    }

    // If cache is invalid or not set, create a new entity
    const newWorldEntity = ecs.addEntity();
    cachedWorldEntityId = newWorldEntity;
    return newWorldEntity;
}

/**
 * Clears the cached world entity ID.
 */
export function clearCachedWorldEntity(): void {
    cachedWorldEntityId = undefined;
}

// ---

import { EventBus } from "../../EventBus.ts";
import { GameEvent } from "../../consts/GameEvent.ts";
import { GameDisplay } from "../../display/GameDisplay.ts";
import { CameraModule } from "../../display/camera/CameraModule.ts";
import { SelectionHighlightModule } from "../../display/game/tools/selection/SelectionHighlightModule.ts";
import { DataPanelModule } from "../../display/game/data_panel/DataPanelModule.ts";
import { CloudsModule } from "../../display/game/sky/CloudsModule.ts";
import { SkyDisplayModule } from "../../display/game/sky/SkyDisplayModule.ts";
import { StarfieldModule } from "../../display/game/sky/StarfieldModule.ts";
import { TinterModule } from "../../display/game/time_tint/TinterModule.ts";
import { TreeSwayModule } from "../../display/game/trees/TreeSwayModule.ts";
import { Game } from "../../scenes/Game.ts";
import { InputSystem } from "../input/InputSystem.ts";
import { CaveExploreStory } from "../story/CaveExploreStory.ts";
import { StoryEventSystem } from "../story/StoryEventSystem.ts";
import { StoryOption } from "../story/StoryEventTypes.ts";
import { TimeSystem } from "../time/TimeSystem.ts";
import { WeatherSystem } from "../weather/WeatherSystem.ts";
import {CaveTreeLUTComponent} from "../lut/CaveTreeLUTComponent.ts";
import {buildCaveTreeLUTFromViews} from "../lut/buildCaveTreeLUTFromViews.ts";
import { GameTools } from "../../display/game/tools/GameTools.ts";
import { WoodDojoSystem } from "../buildings/wood_dojo/WoodDojoSystem.ts";
import { LocomotionSystem } from "../locomotion/LocomotionSystem.ts";
import { TreeHarvestingSystem } from "../trees/TreeHarvestingSystem.ts";
import { CaveViewModule } from "../../display/game/buildings/CaveViewModule.ts";
import { BuildingViewModule } from "../../display/game/buildings/BuildingViewModule.ts";
import { TreeViewModule } from "../../display/game/trees/TreeViewModule.ts";
import { TreeCutIconViewModule } from "../../display/game/trees/TreeCutIconViewModule.ts";
import { CharacterViewModule } from "../../display/game/characters/CharacterViewModule.ts";
import { ResourceSystem } from "../resources/ResourceSystem.ts";
import { ECS, Entity } from "../../ECS.ts";
import { Character, CharacterType } from "../characters/Character.ts";
import { Transform } from "../../components/Transform.ts";
import { WoodDojo } from "../buildings/wood_dojo/WoodDojo.ts";
import { InputComponent } from "../input/InputComponent.ts";
import { LocomotionComponent } from "../locomotion/LocomotionComponent.ts";
import { ResourceComponent } from "../resources/ResourceComponent.ts";
import { createStandardSchedule } from "../characters/ScheduleComponent.ts";
import { TimeComponent } from "../time/TimeComponent.ts";
import { WeatherComponent } from "../weather/WeatherComponent.ts";
import { HarvesterComponent } from "../trees/HarvesterComponent.ts";
import { loadPanelRegistry } from "../../display/game/data_panel/PanelRegistry.ts";
import { DormitorySystem } from "../buildings/dormitory/DormitorySystem.ts";
import { DormitoryComponent } from "../buildings/dormitory/DormitoryComponent.ts";
import { ActionIntentComponent } from "../intent/intent-to-action/ActionIntentComponent.ts";
import { ActionIntentSystem } from "../intent/intent-to-action/ActionIntentSystem.ts";
import { HomeComponent } from "../buildings/dormitory/HomeComponent.ts";
import { RelaxBehaviorSystem } from "../intent/intent-to-action/relaxation/RelaxBehaviorSystem.ts";
import { BuffsComponent } from "../buffs/BuffsComponent.ts";
import { BuffManagementSystem } from "../buffs/BuffManagementSystem.ts";
import { WorkerComponent } from "../characters/WorkerComponent.ts";
import { SleepEffectsSystem } from "../buffs/SleepEffectsSystem.ts";
import { SleepNeedSystem } from "../needs/SleepNeedSystem.ts";
import { NeedData, NeedType, NeedsComponent } from "../needs/NeedsComponent.ts";
import { IntentSelectionSystem } from "../intent/IntentSelectionSystem.ts";
import { TiredEffectSystem } from "../buffs/TiredEffectSystem.ts";
import { FoodNeedSystem } from "../needs/FoodNeedSystem.ts";
import { getWorldEntity } from "./getWorldEntity.ts";
import { ForagingSystem } from "../foraging/ForagingSystem.ts";
import { HarvestingComponentRemovalSystem } from "../trees/HarvestingComponentRemovalSystem.tsx";

export const init = (game:Game) => {
    initData(game);
    initDisplay(game);
    initSystems(game);
    EventBus.emit(GameEvent.ViewsInitialized);
}

export const initStory = (game:Game) => {
    const story = new StoryEventSystem({
        "intro": CaveExploreStory
    });

    game.ecs.addSystem(story);

    const handleStoryEvent = (opt: StoryOption) => {
        if (opt.effect) opt.effect(game.ecs);
        if (opt.close) {
            EventBus.emit(GameEvent.StoryEventEnded);
        } else {
            story.advance(opt.entity!, opt.nextPageId);
        }
    };

    EventBus.on(GameEvent.StoryEventOptionChosen, handleStoryEvent);

    game.destroyQueue.push(() => {
        EventBus.off(GameEvent.StoryEventOptionChosen, handleStoryEvent);
    });
}

export const initInput = (game:Game) => {
    const input = new InputSystem();
    game.ecs.addSystem(input);
    const destroyInput = input.initialize();
    game.destroyQueue.push(destroyInput);
}

export const initSystems = (game:Game)=>{
    game.ecs.addSystem(new TimeSystem());
    game.ecs.addSystem(new WeatherSystem());
    game.ecs.addSystem(new LocomotionSystem());

    game.ecs.addSystem(new SleepNeedSystem());
    game.ecs.addSystem(new FoodNeedSystem());

    game.ecs.addSystem(new IntentSelectionSystem());
    game.ecs.addSystem(new ActionIntentSystem());
    game.ecs.addSystem(new SleepEffectsSystem());
    game.ecs.addSystem(new TiredEffectSystem());

    game.ecs.addSystem(new TreeHarvestingSystem())
    game.ecs.addSystem(new RelaxBehaviorSystem());
    game.ecs.addSystem(new BuffManagementSystem());
    game.ecs.addSystem(new ResourceSystem());

    game.ecs.addSystem(new WoodDojoSystem());
    game.ecs.addSystem(new DormitorySystem());
    game.ecs.addSystem(new ForagingSystem());
    game.ecs.addSystem(new HarvestingComponentRemovalSystem());
    
    initInput(game);
    initStory(game);
    initLut(game);
}

const initLut = (game:Game) => {
    const handleViewsInitialized = ()=>{
        const lut = new CaveTreeLUTComponent(buildCaveTreeLUTFromViews(game.gameDisplay.viewsByEntity));
        game.ecs.addComponent(getWorldEntity(game.ecs), lut);
    }
    
    EventBus.on(GameEvent.ViewsInitialized, handleViewsInitialized);

    game.destroyQueue.push(() => {
        EventBus.off(GameEvent.ViewsInitialized, handleViewsInitialized);
    });
}

export const initData = (game:Game) => {
    loadPanelRegistry(game);
}

export const initDisplay = (game:Game)=>{
    game.gameDisplay = new GameDisplay();
    
    const modules = [
        new CameraModule(),
        new SkyDisplayModule(),
        new StarfieldModule(),
        new CloudsModule(),
        new TinterModule(),
        new TreeSwayModule(),
        new SelectionHighlightModule(),
        new GameTools(),
        new DataPanelModule(),
        new CaveViewModule(),
        new BuildingViewModule(),
        new TreeViewModule(),
        new TreeCutIconViewModule(),
        new CharacterViewModule(),
    ];
    
    game.gameDisplay.init(game, game.ecs, modules);
}

export function initWorld(ecs: ECS) {
    const world = getWorldEntity(ecs);
    ecs.addComponent(world, new TimeComponent());
    ecs.addComponent(world, new InputComponent());
    ecs.addComponent(world, new WeatherComponent());
    ecs.addComponent(world, new ResourceComponent());
}

export function createProfessorBooker(ecs: ECS): number {
    const woodDojoEntity = ecs.getEntitiesWithComponent(WoodDojo)[0];
    const woodDojoTransform = ecs.getComponent(woodDojoEntity, Transform);
    const woodDojo = ecs.getComponent(woodDojoEntity, WoodDojo);

    const dormEntity = ecs.getEntitiesWithComponent(DormitoryComponent)[0];
    const dorm = ecs.getComponent(dormEntity, DormitoryComponent);

    const booker = addBooker(ecs, woodDojoTransform, woodDojo, woodDojoEntity, dorm, dormEntity);
    
    return booker;
}

function addBooker(ecs: ECS, woodDojoTransform: Transform, woodDojo: WoodDojo, woodDojoEntity:Entity, dorm:DormitoryComponent, homeEntity:Entity) {
    const booker = ecs.addEntity();
    
    ecs.addComponent(booker, new Transform(woodDojoTransform.x - 200, woodDojoTransform.y));
    ecs.addComponent(booker, new Character({
        name: "Professor Booker",
        description: "The professor of the academy. He is a master of the wood element.",
        type: CharacterType.PROFESSOR,
    }));
    ecs.addComponent(booker, new HomeComponent(homeEntity));
    ecs.addComponent(booker, new ActionIntentComponent());
    ecs.addComponent(booker, new LocomotionComponent());
    ecs.addComponent(booker, new HarvesterComponent());
    ecs.addComponent(booker, new BuffsComponent());
    ecs.addComponent(booker, new WorkerComponent());
    ecs.addComponent(
        booker,
        new NeedsComponent(
          new Map<NeedType, NeedData>([
            [NeedType.SLEEP, { current: 75, max: 100 }],
            [NeedType.FOOD, { current: 50, max: 100 }],
          ])
        )
    );
      
      ecs.addComponent(booker, createStandardSchedule());

    woodDojo.assignCharacter(ecs, woodDojoEntity, booker);
    dorm.assignedCharacters.push(booker);

    return booker;
}


// ---

import { StoryEventDefinition } from "./StoryEventTypes";
import { ECS } from "../../ECS";

export const CaveExploreStory: StoryEventDefinition = {
    id: "cave_explore",
    startPageId: "intro",

    pages: {
        intro: {
            id: "intro",
            imagePath: "assets/story/cave_intro.png",
            text: `You stand before a mossy cave entrance. A faint rustle echoes from within, followed by a soft squeak. 
Could someone—or something—be inside? The breeze carries the scent of damp earth and mushrooms.`,
            options: [
                { label: "Leave quietly", close: true },
                { label: "Sneak in", nextPageId: "sneak" },
                { label: "Call softly into the cave", nextPageId: "call" }
            ]
        },

        sneak: {
            id: "sneak",
            imagePath: "assets/story/cave_sneak.png",
            text: `You tiptoe into the dimness, careful not to disturb the moss underfoot. Suddenly, you hear a tiny sneeze.`,
            options: [
                {
                    label: "Peek around the rock",
                    nextPageId: "reveal_sproutling"
                },
                {
                    label: "Back away politely",
                    close: true
                }
            ]
        },

        call: {
            id: "call",
            imagePath: "assets/story/cave_call.png",
            text: `"Hello?" you whisper. A soft *"honk!"* replies. Something waddles closer.`,
            options: [
                {
                    label: "Stand your ground",
                    nextPageId: "reveal_sproutling"
                },
                {
                    label: "Hide and watch",
                    nextPageId: "reveal_sproutling"
                }
            ]
        },

        reveal_sproutling: {
            id: "reveal_sproutling",
            imagePath: "assets/story/sproutling_reveal.png",
            text: `A tiny Sproutling emerges! Its leafy head shakes from side to side, trying to appear intimidating—but it stumbles on a root and tumbles forward in a squeaky puff.`,
            options: [
                {
                    label: "Help it up",
                    nextPageId: "friend"
                },
                {
                    label: "Offer it a snack",
                    nextPageId: "friend"
                }
            ]
        },

        friend: {
            id: "friend",
            imagePath: "assets/story/sproutling_friend.png",
            text: `The Sproutling beams! It flutters its leafy arms and gives you a shiny acorn as thanks. You’re now friends.`,
            options: [
                {
                    label: "Wave goodbye",
                    close: true,
                    effect: (ecs: ECS) => {
                        console.log("Friendship with sproutling recorded.");
                        // Example: Add friendship component, flag, or item
                    }
                }
            ]
        }
    }
};


// ---

import { Component } from "../../ECS";

export class StoryEventStateComponent extends Component {
    constructor(
        public eventId: string,
        public currentPageId: string
    ) {
        super();
    }
}


// ---

import { System, Entity } from "../../ECS";
import { EventBus } from "../../EventBus";
import { GameEvent } from "../../consts/GameEvent";
import { StoryEventStateComponent } from "./StoryEventComponent";
import { StoryEventDefinition } from "./StoryEventTypes";

export class StoryEventSystem extends System {
    public update(entities: Set<number>, delta: number): void {
        
    }
    
    componentsRequired = new Set<Function>([StoryEventStateComponent]);

    private activeEvent: StoryEventDefinition | null = null;
    private allEvents: Record<string, StoryEventDefinition>;

    constructor(allEvents: Record<string, StoryEventDefinition>) {
        super();
        this.allEvents = allEvents;
    }

    public start(eventId: string) {
        const event = this.allEvents[eventId];
        if (!event) return;
        this.activeEvent = event;

        const entity = this.ecs.addEntity();
        this.ecs.addComponent(entity, new StoryEventStateComponent(eventId, event.startPageId));

        EventBus.emit(GameEvent.StoryEventStarted, event.pages[event.startPageId]);
    }

    public advance(entity: Entity, nextPageId?: string) {
        const state = this.ecs.getComponent(entity, StoryEventStateComponent);
        if (!state || !this.activeEvent) return;

        if (!nextPageId) {
            this.ecs.removeEntity(entity);
            EventBus.emit(GameEvent.StoryEventEnded);
            return;
        }

        state.currentPageId = nextPageId;
        EventBus.emit(GameEvent.StoryEventPageChanged, this.activeEvent.pages[nextPageId]);
    }
}


// ---

import { ECS } from "../../ECS";

export interface StoryOption {
    label: string;
    nextPageId?: string;
    condition?: (ecs: ECS) => boolean;
    effect?: (ecs: ECS) => void;
    close?: boolean;
    entity?:number;
}

export interface StoryEventPage {
    id: string;
    imagePath: string;
    text: string;
    options: StoryOption[];
    entity?: number;
}

export interface StoryEventDefinition {
    id: string;
    pages: Record<string, StoryEventPage>;
    startPageId: string;
    entity?:number;
}


// ---

import { Component, ECS } from "../../ECS";
import { TimeConfig } from "../../config/TimeConfig";
import { getWorldEntity } from "../serialization/getWorldEntity";

export class TimeComponent extends Component {
    constructor(
        public minutesElapsed: number = 4*TimeConfig.MinutesPerHour,
        public minute: number = 0,
        public hour: number = 4,
        public day: number = 0,
        public semester: number = 0,
        public speedFactor: number = 1
    ) {
        super();
    }
}

export function getTime(ecs: ECS): TimeComponent {
    const time = ecs.getComponent(getWorldEntity(ecs), TimeComponent);
    return time!;
}


// ---

import {Entity, System} from "../../ECS";
import {InputComponent} from "../input/InputComponent.ts";
import {TimeComponent} from "./TimeComponent.ts";
import {TimeConfig} from "../../config/TimeConfig.ts";
import {EventBus} from "../../EventBus.ts";
import {GameEvent} from "../../consts/GameEvent.ts";

export class TimeSystem extends System {
    public componentsRequired = new Set<Function>([TimeComponent, InputComponent]);

    update(entities: Set<Entity>, delta: number): void {
        for (const entity of entities) {
            const time = this.ecs.getComponent(entity, TimeComponent);
            const input = this.ecs.getComponent(entity, InputComponent);

            const speedMultiplier = TimeConfig.SpeedMultipliers[input.speed];
            time.speedFactor = speedMultiplier;

            if (speedMultiplier === 0) continue;

            // Calculate how much real time has passed
            const realSecondsPassed = delta / 1000;
            const inGameHours = (realSecondsPassed / TimeConfig.RealSecondsPerHour) * speedMultiplier;
            const inGameMinutes = inGameHours * TimeConfig.MinutesPerHour;

            this.advanceTime(time, inGameMinutes);
        }
    }

    private advanceTime(time: TimeComponent, minutesToAdd: number) {
        time.minutesElapsed += minutesToAdd;
        time.minute += minutesToAdd;

        while (time.minute >= TimeConfig.MinutesPerHour) {
            time.minute -= TimeConfig.MinutesPerHour;
            time.hour += 1;
        }

        while (time.hour >= TimeConfig.HoursPerDay) {
            time.hour -= TimeConfig.HoursPerDay;
            time.day += 1;
        }

        while (time.day >= TimeConfig.DaysPerSemester) {
            time.day -= TimeConfig.DaysPerSemester;
            time.semester += 1;
        }
        
        EventBus.emit(GameEvent.SetTime, time.minutesElapsed);
    }
}


// ---

import { Component } from "../../ECS";
import { ResourceType } from "../resources/ResourceType";

export type ResourceDrop = {
    type:ResourceType,
    amount:number
}

export class HarvestableComponent extends Component {
    public maxAmount: number = 0;
    public harvestable: boolean = true;
    public harvested: boolean = false;
    
    constructor(public amount: number, public drops: ResourceDrop[]) {
        super();
        this.amount = amount;
        this.maxAmount = amount;
    }
}

// ---

import { Component } from "../../ECS";

export class HarvesterComponent extends Component {
    public harvestPerMinute: number = 5;

    constructor() {
        super();
    }
}

// ---

import { System } from "../../ECS";
import { abortHarvesting } from "../intent/intent-to-action/intent-handlers/abortHarvesting";
import { HarvestableComponent } from "./HarvestableComponent";
import { HarvestingState } from "../intent/character-states/HarvestingState";

export class HarvestingComponentRemovalSystem extends System {
    public componentsRequired: Set<Function> = new Set<Function>([HarvestingState]);

    public update(entities: Set<number>, delta: number): void {
        for (const entity of entities) {
            const harvestingComponent = this.ecs.getComponent(entity, HarvestingState);
            const harvestable = this.ecs.getComponent(harvestingComponent.target, HarvestableComponent);
            if (!harvestable || !harvestable.harvestable || harvestable.amount <= 0) {
                abortHarvesting(this.ecs, entity);
            }
        }
    }
}

// ---

import {Component} from "../../ECS.ts";
import {PlantSpriteKey} from "../../display/setup/SpriteLibrary.ts";

export class Tree extends Component {
    public selectedForCutting = false;
    
    constructor(
        public type: PlantSpriteKey
    ) {
        super();
    }
}

// ---

import { System, Entity, ECS } from "../../ECS";
import { ActionIntentComponent } from "../intent/intent-to-action/ActionIntentComponent";
import { CharacterAction, isChoppingData } from "../intent/intent-to-action/actionIntentData";
import { HarvestableComponent } from "./HarvestableComponent";
import { HarvesterComponent } from "./HarvesterComponent"; // For harvest speed/ability
import {  getTime } from "../time/TimeComponent";
import { ResourceComponent } from "../resources/ResourceComponent";
import { ResourceType } from "../resources/ResourceType";
import { InteractionSlots } from "../../components/InteractionSlots";
import { Tree } from "../trees/Tree";
import { getWorldEntity } from "../serialization/getWorldEntity";

export class TreeHarvestingSystem extends System {
    public componentsRequired = new Set<Function>([
        ActionIntentComponent,
        HarvesterComponent
    ]);

    public update(entities: Set<Entity>, delta: number): void {
        const time = getTime(this.ecs);
        if (time.speedFactor === 0) return; // Game paused
        
        const scaledDeltaSeconds = (delta / 1000) * time.speedFactor;

        for (const characterEntity of entities) {
            const actionIntent = this.ecs.getComponent(characterEntity, ActionIntentComponent);

            if (actionIntent.currentPerformedAction !== CharacterAction.CHOPPING || 
                !isChoppingData(actionIntent.actionData)) {
                continue;
            }

            const choppingData = actionIntent.actionData; // Known to be ChoppingData
            const targetTreeId = choppingData.targetTreeEntityId;

            if (!this.ecs.hasEntity(targetTreeId)) {
                this.abortHarvest(actionIntent, characterEntity, null);
                continue;
            }

            const tree = this.ecs.getComponent(targetTreeId, Tree);
            const harvestable = this.ecs.getComponent(targetTreeId, HarvestableComponent);
            const harvester = this.ecs.getComponent(characterEntity, HarvesterComponent);

            if (!tree || !harvestable || !harvester) {
                this.abortHarvest(actionIntent, characterEntity, targetTreeId);
                continue;
            }

            // Re-validate conditions, though IntentActionSystem's helper should have ensured this.
            // This is a safety check.
            if (!tree.selectedForCutting || !harvestable.harvestable || harvestable.harvested) {
                this.abortHarvest(actionIntent, characterEntity, targetTreeId);
                continue;
            }

            const harvestAmountThisFrame = harvester.harvestPerMinute * scaledDeltaSeconds;
            harvestable.amount -= harvestAmountThisFrame;

            if (harvestable.amount <= 0) {
                this.finalizeHarvest(this.ecs, harvestable, tree);
                this.finishHarvest(actionIntent, characterEntity, targetTreeId);
            }
        }
    }

    private finalizeHarvest(ecs: ECS, harvestable: HarvestableComponent, tree: Tree): void {
        harvestable.amount = 0;
        harvestable.harvested = true;
        harvestable.harvestable = false;
        tree.selectedForCutting = false;

        const resources = ecs.getComponent(getWorldEntity(ecs), ResourceComponent);
        harvestable.drops.forEach((drop) => {
            resources.amounts[drop.type as ResourceType] = (resources.amounts[drop.type as ResourceType] || 0) + drop.amount;
        });
    }

    private clearActionState(aic: ActionIntentComponent, characterEntity: Entity, treeId: Entity | null,) {
        if (treeId !== null) {
            const slots = this.ecs.getComponent(treeId, InteractionSlots);
            slots?.releaseAll(characterEntity);
        }
        aic.currentPerformedAction = CharacterAction.IDLE;
        aic.actionData = null;
    }

    private abortHarvest(aic: ActionIntentComponent, characterEntity: Entity, treeId: Entity | null): void {
        this.clearActionState(aic, characterEntity, treeId);
    }

    private finishHarvest(aic: ActionIntentComponent, characterEntity: Entity, treeId: Entity): void {
        this.clearActionState(aic, characterEntity, treeId);
    }
}

// ---

import { Component } from "../../ECS.ts";

export class WeatherComponent extends Component {
    constructor(
        public windDirection: 1 | -1 = 1,
        public windStrength: number = 0.5,
        public cloudCover: number = 0.5,
    ) {
        super();
    }
}


// ---

import { System } from "../../ECS.ts";
import { Entity } from "../../ECS.ts";
import { WeatherComponent } from "./WeatherComponent.ts";
import {SimplexNoise} from "../../../utils/SimplexNoise.ts";
import {WeatherConfig} from "../../config/WeatherConfig.ts";
import {EventBus} from "../../EventBus.ts";
import {GameEvent} from "../../consts/GameEvent.ts";
import {TimeComponent} from "../time/TimeComponent.ts";

export class WeatherSystem extends System {
    componentsRequired = new Set<Function>([WeatherComponent, TimeComponent]);
    private noise = new SimplexNoise(1); // Seed for consistent variation
    private time = 0;

    update(entities: Set<Entity>, delta: number): void {
        if (entities.size === 0) return;
        if (entities.size > 1) {
            console.warn("WeatherSystem is not designed to handle multiple entities.");
        }
        for (const entity of entities) {
            this.updateWeather(entity, delta);
        }
    }
    
    updateWeather(entity: Entity, delta: number) {
        const weather = this.ecs.getComponent(entity, WeatherComponent);
        const time = this.ecs.getComponent(entity, TimeComponent);

        this.time += delta * time.speedFactor;

        // Wind Strength
        const t = this.time * WeatherConfig.Wind.StrengthFrequency;
        const windRaw = this.noise.noise(t, 0);             // [-1, 1]
        const windNorm = (windRaw + 1) / 2;                 // [0, 1]
        const biased = this.biasedSample(windNorm, WeatherConfig.Wind.Bias);

        weather.windStrength = Phaser.Math.Linear(
            WeatherConfig.Wind.MinSpeed,
            WeatherConfig.Wind.MaxSpeed,
            biased
        ); // Result in px/game-minute


        // Wind Direction
        const t1 = this.time * WeatherConfig.Wind.DirectionFrequency;
        const dirNoise = this.noise.noise(t1, 1000);
        weather.windDirection = dirNoise > WeatherConfig.Wind.DirectionThreshold ? 1 : -1;

        // Cloud Cover (Inverted Bell)
        const t2 = this.time * WeatherConfig.CloudCover.Frequency;
        const coverNoise = this.noise.noise(t2, WeatherConfig.CloudCover.NoiseOffset);
        const coverNorm = (coverNoise + 1) / 2;
        weather.cloudCover = Phaser.Math.Clamp(
            this.biasedSample(coverNorm, 1 - WeatherConfig.CloudCover.Bias),
            0,
            1
        );

        EventBus.emit(GameEvent.SetWeather, weather);
    }

    private biasedSample(x: number, bias: number): number {
        // bias ∈ [0, 1], where 0 = favor low, 1 = favor high
        const k = Math.max(0.0001, bias); // avoid log(0)
        return x / ((1 - k) / k * (1 - x) + 1);
    }
}

// ---

import { Boot } from './scenes/Boot';
import { Game } from './scenes/Game';
import { AUTO, Game as PhaserGame } from 'phaser';
import { Preloader } from './scenes/Preloader';
import OutlinePipelinePlugin from 'phaser3-rex-plugins/plugins/outlinepipeline-plugin.js';
import {Config} from "./config/Config.ts";

//  Find out more information about the Game Config at:
//  https://newdocs.phaser.io/docs/3.70.0/Phaser.Types.Core.GameConfig
const config: Phaser.Types.Core.GameConfig = {
    type: AUTO,
    width: Config.Display.Width,
    height: Config.Display.Height,
    parent: 'game-container',
    backgroundColor: '#028af8',
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
    },
    scene: [
        Boot,
        Preloader,
        Game
    ],
    plugins: {
        global: [
            { key: 'rexOutlinePipeline', plugin: OutlinePipelinePlugin, start: true}
        ]
    },
    render: {
        pixelArt: true
    },
    physics: {
        default: 'arcade',
        arcade: {
            debug: true
        }
    },
    disableContextMenu: true
};

const StartGame = (parent: string) => {
    return new PhaserGame({ ...config, parent });
}

export default StartGame;

// ---

import {GameState} from "../logic/serialization/GameState.ts";

const SAVE_KEY = "zooniversity_save";

export interface SaveManager {
    save(state: GameState): void;
    load(): GameState | null;
    clear(): void;
}

export const saveManager: SaveManager = {
    save(state) {
        localStorage.setItem(SAVE_KEY, JSON.stringify(state));
    },
    load() {
        const raw = localStorage.getItem(SAVE_KEY);
        return raw ? JSON.parse(raw) : null;
    },
    clear() {
        localStorage.removeItem(SAVE_KEY);
    },
};


// ---

import { Scene } from 'phaser';

export class Boot extends Scene
{
    constructor ()
    {
        super('Boot');
    }

    preload ()
    {
        //  The Boot Scene is typically used to load in any assets you require for your Preloader, such as a game logo or background.
        //  The smaller the file size of the assets, the better, as the Boot Scene itself has no preloader.

        this.load.image('background', 'assets/bg.png');
    }

    create ()
    {
        this.scene.start('Preloader');
    }
}


// ---

import {EventBus} from '../EventBus';
import { Scene } from 'phaser';
import {ECS} from "../ECS.ts";
import {GameDisplay} from "../display/GameDisplay.ts";
import {setSceneType} from "../../ui/ui_switcher/useActiveSceneType.ts";
import {GameEvent} from "../consts/GameEvent.ts";
import {GameState} from "../logic/serialization/GameState.ts";
import {loadFromState} from "../logic/serialization/GameStateSerializer.ts";
import {loadNewGame} from "../logic/serialization/MapSerializer.ts";
import {TimeTintPipeline} from "../../render/pipelines/TimeTintPipeline.ts";
import { init} from '../logic/serialization/init.ts';

export class Game extends Scene
{
    gameDisplay: GameDisplay;
    ecs:ECS;
    
    destroyQueue: Array<()=>void> = [];
    
    constructor ()
    {
        super('Game');
    }
    
    update(time: number, delta: number) {
        super.update(time, delta);
        
        this.ecs?.update(delta);
        this.gameDisplay?.update(delta);
    }

    create ()
    {
        EventBus.emit('current-scene-ready', this);
        setSceneType('game');

        const pipeline = new TimeTintPipeline(this.game);
        (this.renderer as Phaser.Renderer.WebGL.WebGLRenderer)
            .pipelines
            .add('TimeTint', pipeline);
 
        this.ecs = new ECS();
        
        EventBus.on(GameEvent.NewGame, () => {
            loadNewGame(this.ecs, this);
            init(this)
        });

        EventBus.on(GameEvent.LoadGame, (state: GameState) => {
            loadFromState(this.ecs, state);
            init(this)
        });

        this.events.on('destroy', this.destroy);
    }

    private destroy() {
        this.events.off('destroy', this.destroy);

        this.destroyQueue.forEach(fn => fn());
        this.destroyQueue = [];
        
        this.gameDisplay.destroy();

        EventBus.off(GameEvent.SetTimeSpeed);
        EventBus.off(GameEvent.SetTime);
        EventBus.off(GameEvent.NewGame);
        EventBus.off(GameEvent.LoadGame);
    }
}


// ---

import { Scene } from 'phaser';
import { Config } from '../config/Config';

export class Preloader extends Scene
{
    constructor ()
    {
        super('Preloader');
    }

    init ()
    {

        //  A simple progress bar. This is the outline of the bar.
        this.add.rectangle(512, 384, 468, 32).setStrokeStyle(1, 0xffffff);

        //  This is the progress bar itself. It will increase in size from the left based on the % of progress.
        const bar = this.add.rectangle(512-230, 384, 4, 28, 0xffffff);

        //  Use the 'progress' event emitted by the LoaderPlugin to update the loading bar
        this.load.on('progress', (progress: number) => {

            //  Update the progress bar (our bar is 464px wide, so 100% = 464px)
            bar.width = 4 + (460 * progress);

        });
    }

    preload ()
    {
        this.load.json("panelRegistry", "assets/data/panels.json");

        this.load.setPath('assets/plants');

        const animFrameConfig =                 {
            frameWidth: Config.AnimImports.FrameWidth*2,
            frameHeight: Config.AnimImports.FrameHeight*2,
            endFrame: Config.AnimImports.NumberOfFrames-1
        };
        
        for (let i = 0; i < Config.AnimImports.NumberOfTrees; i++) {
            this.load.spritesheet(
                `tree${i}`, 
                `tree${i}.png`,
                animFrameConfig
            );
        }
        
        for (let i = 0; i < Config.AnimImports.NumberOfBushes; i++) {
            this.load.spritesheet(
                `bush${i}`,
                `bush${i}.png`,
                animFrameConfig
            );
        }

        this.load.setPath('assets/hill');

        const staticFrameConfig = {
            frameWidth: Config.AnimImports.StaticWidth,
            frameHeight: Config.AnimImports.StaticHeight,
            endFrame: 0
        };

        const caveFrameConfig = {
            frameWidth: Config.AnimImports.StaticHeight,
            frameHeight: Config.AnimImports.StaticHeight,
            endFrame: 0
        };
        
        this.load.spritesheet('hill', 'hill.png', staticFrameConfig);
        this.load.spritesheet('home-lvl-1', 'home-lvl-1.png', staticFrameConfig);
        this.load.spritesheet('home-lvl-1-inside', 'home-lvl-1-inside.png', staticFrameConfig);
        this.load.spritesheet('kitchen-lvl-1', 'kitchen-lvl-1.png', staticFrameConfig);
        this.load.spritesheet('kitchen-lvl-1-inside', 'kitchen-lvl-1-inside.png', staticFrameConfig);
        this.load.spritesheet('cave', 'cave.png', caveFrameConfig);
        this.load.spritesheet('wood_dojo', 'wood_dojo.png', caveFrameConfig);


        this.load.setPath('assets/maps');
        this.load.json('forestMap', 'forestMap.json');

        this.load.setPath('assets/clouds');

        for (let i = 0; i < 4; i++) {
            this.load.spritesheet(
                `cloud${i}`,
                `cloud${i}.png`,
                caveFrameConfig
            );
        }

        this.load.setPath('assets');

        this.load.spritesheet('night_sky', 'night_sky.png', caveFrameConfig);


        const charFrameConfig = {
            frameWidth: Config.AnimImports.StaticHeight,
            frameHeight: Config.AnimImports.StaticWidth,
            endFrame: 0
        };

        this.load.setPath('assets/characters/booker');
        this.load.spritesheet('booker_char', 'booker_char.png', charFrameConfig);
        this.load.spritesheet('booker_icon', 'booker_icon.png', caveFrameConfig);

        this.load.setPath('assets/icons');
        this.load.spritesheet('axe_icon', 'axe_icon.png', caveFrameConfig);
    }

    create ()
    {
        this.scene.start(Config.EntryScene);
    }
}


// ---

import React from 'react';
import ReactDOM from 'react-dom/client';
import {App} from './App.tsx';

ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)


// ---

// TimeTintPipeline.ts
import Phaser from 'phaser';
import fragShader from '../../shaders/tint.frag?raw';

export class TimeTintPipeline extends Phaser.Renderer.WebGL.Pipelines.SinglePipeline {
    constructor(game: Phaser.Game) {
        super({
            game,
            fragShader,
        });
    }

    setTintColor(color: Phaser.Display.Color) {
        this.set4f(
            'uTimeTint',
            color.redGL,
            color.greenGL,
            color.blueGL,
            1.0
        );
    }

    setCloudAlpha(alpha: number) {
        this.set1f('uCloudAlpha', Phaser.Math.Clamp(alpha, 0, 1));
    }

    setResolution(width: number, height: number) {
        this.set2f('uResolution', width, height);
    }

    setLightingTexture(rt: Phaser.GameObjects.RenderTexture | null) {
        const glTex = (rt as any)?._renderer?.glTexture;

        if (glTex) {
            this.setBoolean('uUseLighting', true);
            this.setTexture2D(glTex);
        } else {
            this.setBoolean('uUseLighting', false);
        }
    }
}


// ---

import React, { useEffect, useState } from "react";
import {GameEvent} from "../../game/consts/GameEvent.ts";
import {EventBus} from "../../game/EventBus.ts";
import {MainMenu} from "./main_menu/MainMenu.tsx";
import {TimeControls} from "../v2/elements/time/TimeControls.tsx";
import {WeatherPanel} from "./weather/WeatherPanel.tsx";
import { ResourceDisplay } from "./resources/ResourceDisplay.tsx";
import { TopCharacterBar } from "../v2/elements/top-char-bar/TopCharactersBar.tsx";
import { BottomBar } from "../v2/elements/bottom-bar/BottomBar.tsx";
import { CharacterPortraitsLayer } from "./character_portaits/CharacterPortraitsLayer.tsx";
import { useToolCursor } from "../v2/hooks/useToolCursor.tsx";

export const GameContainer: React.FC = () => {
    const [gameLoaded, setGameLoaded] = useState(false);

    useEffect(() => {
        const handler = () => setGameLoaded(true);
        EventBus.on(GameEvent.GameLoaded, handler);
        return () => {
            EventBus.off(GameEvent.GameLoaded, handler);
        };
    }, []);

    useToolCursor();
    
    return !gameLoaded ? <MainMenu /> : 
    <>
        <TimeControls/>
        <WeatherPanel/>
        <BottomBar/>
        <ResourceDisplay/>
        <CharacterPortraitsLayer/>
        <TopCharacterBar/>
    </>
};


// ---

import React from 'react';
import './CharacterPortraits.css';
import { EventBus } from '../../../game/EventBus';
import { UIEvent } from '../../../game/consts/UIEvent';

type CharacterPortraitProps = {
  data: {
    entity: number;
    pos: { x: number; y: number };
    character: {
      icon: string;
      type: string;
    };
  };
};

export const CharacterPortrait: React.FC<CharacterPortraitProps> = ({ data }) => {
  return (
    <div
      className="character-portrait"
      style={{
        left: `${data.pos.x}px`,
        top: `${data.pos.y}px`,
        pointerEvents: 'all',
      }}
      onClick={() => {
        EventBus.emit(UIEvent.PortraitClicked, data.entity);
    }}
    >
      <img src={data.character.icon} alt={`${data.character.type} Icon`} />
    </div>
  );
};


// ---

.character-portrait {
    position: absolute;
    width: 48px;
    height: 48px;
    border-radius: 50%;
    overflow: hidden;
    pointer-events: none;
    transform: translate(-50%, -50%);
  }
  
  .character-portrait img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  

// ---

import React, { useEffect, useRef, useState } from 'react';
import './CharacterPortraits.css';
import { CharacterPortrait } from './CharacterPortrait';
import { EventBus } from '../../../game/EventBus';
import { GameEvent } from '../../../game/consts/GameEvent';

type CharacterUpdateData = {
  id: number;
  pos: { x: number; y: number };
  character: {
    icon: string;
    type: string;
  };
};

export const CharacterPortraitsLayer: React.FC = () => {
  const [portraits, setPortraits] = useState<Record<number, CharacterUpdateData>>({});
  const seenThisFrameRef = useRef<Set<number>>(new Set());
  const tickRef = useRef(0);

  // Reset seenThisFrame every animation frame
  useEffect(() => {
    let raf: number;
    const loop = () => {
      seenThisFrameRef.current.clear();
      tickRef.current++;
      raf = requestAnimationFrame(loop);
    };
    raf = requestAnimationFrame(loop);
    return () => cancelAnimationFrame(raf);
  }, []);

  useEffect(() => {
    const handleUpdate = (data: CharacterUpdateData) => {
      seenThisFrameRef.current.add(data.id);

      setPortraits(prev => ({
        ...prev,
        [data.id]: data
      }));
    };

    EventBus.on(GameEvent.CharacterUpdate, handleUpdate);
    return () => {
      EventBus.off(GameEvent.CharacterUpdate, handleUpdate);
    };
  }, []);

  return (
    <>
      {Object.entries(portraits).map(([id, data]) => (
        <CharacterPortrait key={id} data={{ ...data, entity: +id }} />
      ))}
    </>
  );
};

// ---

@import url('https://fonts.googleapis.com/css2?family=Chewy&display=swap');

.main-menu {
    position: static;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
}

.menu-background {
    background: #000000 !important;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: contain; /* Preserve aspect ratio */
    object-position: center;
    z-index: 0;
    pointer-events: none; /* So it doesn't block buttons */
}

.menu-buttons {
    position: absolute;
    bottom: 40px;
    width: 100%;
    display: flex;
    justify-content: center;
    gap: 32px;
    z-index: 10;
}


.menu-button {
    font-family: 'Chewy', cursive;
    font-size: 1.6rem;
    padding: 24px 56px;
    background-color: #fce8c6; /* soft parchment tone */
    border: 3px solid #6b4c3b; /* rich brown */
    border-radius: 12px;
    color: #2f1f16; /* darker brown text */
    cursor: pointer;
    transition:
        transform 0.2s ease-out,
        box-shadow 0.2s ease-out,
        background-color 0.2s ease-in;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.menu-button:hover:not(.disabled) {
    transform: translateY(-4px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
}

.menu-button:active:not(.disabled) {
    transform: scale(0.96);
}

.menu-button.disabled {
    opacity: 0.5;
    cursor: not-allowed;
    pointer-events: none;
}


// ---

import {MenuButton} from "./MenuButton.tsx";
import {EventBus} from "../../../game/EventBus.ts";
import {GameEvent} from "../../../game/consts/GameEvent.ts";
import {useSaveManager} from "./useSaveManager.tsx";
import "./MainMenu.css";

export const MainMenu: React.FC = () => {
    const { current } = useSaveManager();

    return (
        <div className="main-menu">
            <img src="assets/splash.png" alt="Main Menu" className="menu-background" />
            <div className="menu-buttons">
                <MenuButton title="NEW GAME" onClick={() => EventBus.emit(GameEvent.NewGame)} />
                <MenuButton title="CONTINUE" onClick={() => EventBus.emit(GameEvent.LoadGame, current)} enabled={!!current} />
                <MenuButton title="LOAD" onClick={() => {}} enabled={true} />
            </div>
        </div>
    );
};


// ---

import React from "react";

interface MenuButtonProps {
    title: string;
    onClick: () => void;
    enabled?: boolean;
}

export const MenuButton: React.FC<MenuButtonProps> = ({ title, onClick, enabled = true }) => {
    return (
        <button
            className={`menu-button${enabled ? "" : " disabled"}`}
            onClick={enabled ? onClick : undefined}
            disabled={!enabled}>
            {title}
            </button>
        );
};


// ---

import { useState, useEffect } from 'react';
import {GameState} from "../../../game/logic/serialization/GameState.ts";
import {saveManager} from "../../../game/save_manager/SaveManager.ts";

export function useSaveManager() {
    const [current, setCurrent] = useState<GameState | undefined>();

    useEffect(() => {
        const loaded = saveManager.load();
        if (loaded) setCurrent(loaded);
    }, []);

    return { current };
}


// ---

.resource-display {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 100;
    display: flex;
    flex-direction: column;
    gap: 8px;
    background-color: rgba(24, 24, 24, 0.6);
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 0 8px rgba(0,0,0,0.3);
    pointer-events: none;
}

.resource-row {
    display: flex;
    align-items: center;
    gap: 8px;
}

.resource-icon {
    width: 24px;
    height: 24px;
    image-rendering: pixelated;
}

.resource-value {
    font-size: 1.1rem;
    font-weight: bold;
    color: #fff;
    min-width: 40px;
    text-align: right;
}


// ---

import React, { useEffect, useState } from "react";
import "./ResourceDisplay.css";
import { ResourceConfig } from "../../../game/logic/resources/ResourceConfig";
import { ResourceTracker } from "../../../game/logic/resources/ResourceTracker";
import { ResourceType } from "../../../game/logic/resources/ResourceType";
import { formatResourceNumber } from "./formatResourceNumber";

export const ResourceDisplay: React.FC = () => {
    const [values, setValues] = useState<Record<ResourceType, number>>(() =>
        Object.fromEntries(Object.values(ResourceType).map(key => [key, 0])) as Record<ResourceType, number>
    );

    useEffect(() => {
        const handle = (update: Partial<Record<ResourceType, number>>) => {
            setValues(prev => ({ ...prev, ...update }));
        };
        ResourceTracker.subscribe(handle);
        return () => ResourceTracker.unsubscribe(handle);
    }, []);

    return (
        <div className="resource-display">
            {Object.values(ResourceType).map((type) => {
                const { icon, description } = ResourceConfig[type];
                const value = values[type];
                return (
                    <div className="resource-row" key={type} title={description}>
                        <img src={icon} alt={type} className="resource-icon" />
                        <span className="resource-value">{formatResourceNumber(value)}</span>
                    </div>
                );
            })}
        </div>
    );
};


// ---

export function formatResourceNumber(value: number): string {
    if (value < 1000) return `${value}`;
    if (value < 1_000_000) return `${(value / 1000).toFixed(1)}K`;
    if (value < 1_000_000_000) return `${(value / 1_000_000).toFixed(1)}M`;
    return `${(value / 1_000_000_000).toFixed(1)}B`;
}


// ---

import React, { useEffect, useState } from "react";
import { StoryEventPage, StoryOption } from "../../../game/logic/story/StoryEventTypes";
import { GameEvent } from "../../../game/consts/GameEvent";
import { EventBus } from "../../../game/EventBus";
import "./StoryEventUI.css";

export const StoryEventUI: React.FC = () => {
    const [page, setPage] = useState<StoryEventPage | null>(null);

    useEffect(() => {
        EventBus.on(GameEvent.StoryEventStarted, setPage);
        EventBus.on(GameEvent.StoryEventPageChanged, setPage);
        EventBus.on(GameEvent.StoryEventEnded, () => setPage(null));

        return () => {
            EventBus.off(GameEvent.StoryEventStarted, setPage);
            EventBus.off(GameEvent.StoryEventPageChanged, setPage);
            EventBus.off(GameEvent.StoryEventEnded, () => setPage(null));
        };
    }, []);

    if (!page) return null;

    return (
        <div className="story-event-ui" style={{ backgroundImage: `url(${page.imagePath})` }}>
            <div className="story-text">{page.text}</div>
            <div className="story-options">
                {page.options.map((opt, idx) => (
                    <button key={idx} onClick={() => EventBus.emit(GameEvent.StoryEventOptionChosen, opt)}>
                        {opt.label}
                    </button>
                ))}
            </div>
        </div>
    );
};


// ---

.weather-panel {
    background-color: rgba(255, 255, 255, 0.9);
    border: 2px solid #888;
    border-radius: 8px;
    padding: 12px 16px;
    width: 200px;
    font-family: sans-serif;
    font-size: 0.95rem;
    color: #333;
    box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
}

.weather-panel h3 {
    margin-top: 0;
    font-size: 1.1rem;
    margin-bottom: 8px;
}

.weather-row {
    display: flex;
    justify-content: space-between;
    margin-bottom: 4px;
}


// ---

import React from "react";
import { useWeather } from "./useWeather.ts";
import "./WeatherPanel.css";

export const WeatherPanel: React.FC = () => {
    const weather = useWeather();

    if (!weather) return null;

    return (
        <div className="weather-panel">
            <h3>Weather</h3>
            <div className="weather-row">
                <label>🌬️ Wind Strength:</label>
                <span>{weather.windStrength.toFixed(2)}</span>
            </div>
            <div className="weather-row">
                <label>🧭 Wind Direction:</label>
                <span>{weather.windDirection === 1 ? "→" : "←"}</span>
            </div>
            <div className="weather-row">
                <label>☁️ Cloud Cover:</label>
                <span>{weather.cloudCover.toFixed(2)}</span>
            </div>
        </div>
    );
};


// ---

import { useEffect, useState } from "react";
import {WeatherComponent} from "../../../game/logic/weather/WeatherComponent.ts";
import {GameEvent} from "../../../game/consts/GameEvent.ts";
import {EventBus} from "../../../game/EventBus.ts";

export function useWeather(): WeatherComponent | null {
    const [weather, setWeather] = useState<WeatherComponent | null>(null);

    // @ts-ignore
    useEffect(() => {
        const handler = (payload: WeatherComponent) => {
            setWeather({ ...payload });
        };

        EventBus.on(GameEvent.SetWeather, handler);
        return () => EventBus.off(GameEvent.SetWeather, handler);
    }, []);

    return weather;
}


// ---

import React, { useRef } from 'react';

interface FileManagementUiProps {
    name: string;
    validExtensions: string[];
    save: (name: string) => void;
    onLoad: (e: ProgressEvent<FileReader>) => void;
    onNameChange: (newName: string) => void;
}

export function FileManagementUi({
                                     name,
                                     validExtensions,
                                     save,
                                     onLoad,
                                     onNameChange
                                 }: FileManagementUiProps) {
    const fileInputRef = useRef<HTMLInputElement>(null);

    const handleLoadClick = () => {
        fileInputRef.current?.click();
    };

    const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (!file) return;

        const ext = file.name.slice(file.name.lastIndexOf('.'));
        if (!validExtensions.includes(ext)) {
            alert(`Invalid file type: ${ext}`);
            return;
        }

        const reader = new FileReader();
        reader.onload = onLoad;
        reader.readAsText(file);
    };

    const handleSaveClick = () => {
        if (!name.trim()) {
            alert('Please enter a name.');
            return;
        }
        save(name.trim());
    };

    return (
        <div className="file-management-ui">
            <input
                type="text"
                placeholder="Name..."
                value={name}
                onChange={(e) => onNameChange(e.target.value)}
            />
            <div className="file-actions">
                <button onClick={handleSaveClick}>💾 Save</button>
                <button onClick={handleLoadClick}>📂 Load</button>
                <input
                    type="file"
                    accept={validExtensions.join(',')}
                    ref={fileInputRef}
                    style={{ display: 'none' }}
                    onChange={handleFileChange}
                />
            </div>
        </div>
    );
}


// ---

.sidebar {
    width: 60px;
    background-color: #2c2c2c;
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-top: 12px;
    box-shadow: 2px 0 4px rgba(0,0,0,0.1);
    pointer-events: all;
    box-sizing: border-box;
}

.sidebar-title {
    font-size: 14px;
    margin-bottom: 16px;
    text-align: center;
    font-weight: 600;
    letter-spacing: 0.05em;
}


.sidebar-buttons {
    display: flex;
    flex-direction: column;
    gap: 8px;
    width: 100%;
    height: 100%;
    padding: 0 4px;
}

.sidebar-button {
    background: none;
    border: none;
    color: white;
    width: 100%;
    padding: 8px 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    font-size: 12px;
    cursor: pointer;
    transition: background-color 0.2s;
    border-radius: 4px;
}

.sidebar-button:hover {
    background-color: #3c3c3c;
}

.sidebar-button.active {
    background-color: #4c4c8f;
}

.sidebar-icon {
    font-size: 20px;
    margin-bottom: 4px;
    width: 24px;
    height: 24px;
}

.sidebar-icon img {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

.undo-redo-controls {
    display: flex;
    flex-direction: column;
    gap: 6px;
    margin-top: auto; /* Push to bottom */
    padding-top: 12px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.undo-redo-controls button {
    background: none;
    border: 1px solid rgba(255, 255, 255, 0.15);
    color: white;
    font-size: 12px;
    padding: 6px;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.15s ease;
}

.undo-redo-controls button:hover {
    background: rgba(255, 255, 255, 0.1);
}


// ---

import React, { ReactNode } from 'react';
import './Sidebar.css';

interface SidebarProps {
    title: string;
    children: ReactNode;
}

export const Sidebar: React.FC<SidebarProps> = ({ title, children }) => {
    return (
        <aside className="sidebar">
            <h2 className="sidebar-title">{title}</h2>
            <div className="sidebar-buttons">
                {children}
            </div>
        </aside>
    );
};


// ---

import React from 'react';
import './Sidebar.css';

interface SidebarButtonProps {
    label: string;
    icon?: string; // Emoji or URL path
    isActive: boolean;
    onClick: () => void;
}

export const SidebarButton: React.FC<SidebarButtonProps> = ({ label, icon, isActive, onClick }) => {
    return (
        <button className={`sidebar-button ${isActive ? 'active' : ''}`} onClick={onClick}>
            {icon && (
                icon.startsWith('http') || icon.includes('/') ? (
                    <img src={icon} alt="" className="sidebar-icon" />
                ) : (
                    <span className="sidebar-icon">{icon}</span>
                )
            )}
            <span>{label}</span>
        </button>
    );
};


// ---

import React from 'react';
import {EventBus} from "../../../game/EventBus.ts";

export const UndoRedo: React.FC = () => {
    return (
        <div className="undo-redo-controls">
            <button onClick={() => EventBus.emit('editor-undo')}>↩ Undo</button>
            <button onClick={() => EventBus.emit('editor-redo')}>↪ Redo</button>
        </div>
    );
};


// ---

import React from 'react';
import {SpriteKey, SpriteLibrary} from "../../../game/display/setup/SpriteLibrary.ts";

interface Props {
    spriteKey: SpriteKey;
    selected: boolean;
    onClick: () => void;
}

export const PaletteEntry: React.FC<Props> = ({ spriteKey, selected, onClick }) => {
    const def = SpriteLibrary[spriteKey];
    
    const imageSrc = def.path ?? `assets/${spriteKey}.png`;

    return (
        <button className={`palette-entry ${selected ? 'selected' : ''}`} onClick={onClick}>
            <img src={imageSrc} alt={spriteKey} draggable={false} />
        </button>
    );
};

// ---

.sprite-palette {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(36px, 1fr));
    gap: 6px;
    padding: 8px;
    width: 100%;
    box-sizing: border-box;
}

.palette-entry {
    border: 1px solid transparent;
    background: none;
    padding: 2px;
    border-radius: 4px;
    cursor: pointer;
    width: 100%;
    aspect-ratio: 1 / 1;
    display: flex;
    align-items: center;
    justify-content: center;
}

.palette-entry.selected {
    border-color: white;
    background: rgba(255, 255, 255, 0.1);
}

.palette-entry img {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
}


// ---

import React from 'react';
import './SpritePalette.css';
import {PaletteEntry} from "./PaletteEntry.tsx";
import {SpriteKey} from "../../../game/display/setup/SpriteLibrary.ts";

interface SpritePaletteProps {
    spriteKeys: string[];
    onSelect: (key: SpriteKey) => void;
    selectedKey?: string;
}

export function SpritePalette({ spriteKeys, onSelect, selectedKey }: SpritePaletteProps) {
    return (
        <div className="sprite-palette">
            {spriteKeys.map((key) => (
                <PaletteEntry
                    key={key}
                    spriteKey={key as SpriteKey}
                    selected={selectedKey === key}
                    onClick={() => onSelect(key as SpriteKey)}
                />
            ))}
        </div>
    );
}


// ---

import React from 'react';
import {useActiveSceneType} from "./useActiveSceneType.ts";
import {GameContainer} from "../game/GameContainer.tsx";

export const UISwitcher: React.FC = () => {
    const sceneType = useActiveSceneType();

    switch (sceneType) {
        case 'editor':
            return <></>;
        case 'game':
            return <GameContainer />;
        default:
            return null; // or a <LoadingScreen /> or <ErrorFallback />
    }
};


// ---

import React from "react";

type SceneType = 'editor' | 'game';

const listeners = new Set<(type: SceneType) => void>();
let currentSceneType: SceneType = 'game';

export function setSceneType(type: SceneType) {
    currentSceneType = type;
    listeners.forEach(fn => fn(type));
}

export function useActiveSceneType(): SceneType {
    const [sceneType, setSceneTypeState] = React.useState(currentSceneType);

    // @ts-ignore
    React.useEffect(() => {
        const fn = (type: SceneType) => setSceneTypeState(type);
        listeners.add(fn);
        return () => listeners.delete(fn);
    }, []);

    return sceneType;
}


// ---

// Fillbar.tsx
import React from 'react';
import styled from '@emotion/styled';

interface FillbarProps {
  currentValue: number;
  maxValue: number;
  label?: string;
  fillColor?: string; 
  barBackgroundColor?: string; 
  height?: string;
  width?: string;
  className?: string; // For Emotion's className passthrough or external styling
  labelColor?: string;
}

const FillbarContainer = styled.div<{ barWidth: string }>`
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  margin-bottom: 4px;
  width: ${props => props.barWidth};
`;

const FillbarLabel = styled.span<{ labelColor: string }>`
  font-size: 0.8rem;
  color: ${props => props.labelColor};
  margin-bottom: 2px;
`;

const FillbarBackground = styled.div<{ barHeight: string; bgColor: string }>`
  width: 100%;
  height: ${props => props.barHeight};
  background-color: ${props => props.bgColor};
  border-radius: 4px;
  overflow: hidden;
  position: relative;
`;

const FillbarFill = styled.div<{
  fillColor: string;
  barHeight: string;
}>`
  height: ${props => props.barHeight};
  background-color: ${props => props.fillColor};
  border-radius: 4px; /* Can be same as background or slightly less */
`;

export const Fillbar: React.FC<FillbarProps> = ({
  currentValue,
  maxValue,
  label,
  fillColor = '#4CAF50', // Default fill color
  barBackgroundColor = '#E0E0E0', // Default background color
  height = '10px',
  width = '100px',
  className,
  labelColor = '#FFFFFF', // Default label color
}) => {
  const percentage = maxValue > 0 ? (currentValue / maxValue) * 100 : 0;
  const cappedPercentage = Math.max(0, Math.min(percentage, 100));

  return (
    <FillbarContainer barWidth={width} className={className}>
      {label && <FillbarLabel labelColor={labelColor}>{label}</FillbarLabel>}
      <FillbarBackground barHeight={height} bgColor={barBackgroundColor}>
        <FillbarFill
          style={{"width": `${cappedPercentage}%`}}
          fillColor={fillColor}
          barHeight={height}
        />
      </FillbarBackground>
    </FillbarContainer>
  );
};

// ---

import React from 'react';
import styled from '@emotion/styled';
import { SelectionPanel } from '../panel/SelectionPanel';
import { ToolBar } from './ToolBar';

const HUDWrapper = styled.div`
  position: absolute;
  bottom: 0;
  left: 0;
  /* width: 100%; // Removed to allow intrinsic sizing from children */
  display: inline-flex; /* So the wrapper itself shrinks to content */
  flex-direction: row;
  align-items: flex-end;
  pointer-events: none;

  & > * {
    pointer-events: auto;
  }
`;

const SelectionPanelWrapper = styled.div`
  /* flex-grow: 1; // Removed */
  /* min-width: 0; // Removed or adjust if specific min needed */
  width: auto; /* Allow content to dictate width */
`;

const ToolBarWrapper = styled.div`
  flex-shrink: 0;
`;


export const BottomBar: React.FC = () => {
  return (
    <HUDWrapper>
      <SelectionPanelWrapper>
        <SelectionPanel />
      </SelectionPanelWrapper>
      <ToolBarWrapper>
        <ToolBar />
      </ToolBarWrapper>
    </HUDWrapper>
  );
};

// ---

import React from 'react';
import styled from '@emotion/styled';
import { EventBus } from '../../../../game/EventBus';
import { GameEvent } from '../../../../game/consts/GameEvent';
import { ToolType } from '../../../../game/display/game/tools/GameTools';
import { useSelectedTool } from '../../hooks/useSelectedTool';
import { ToolButton } from '../buttons/ToolButton';

const BarWrapper = styled.div`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px;
`;

export const ToolBar: React.FC = () => {
  const activeTool = useSelectedTool();

  const handleTreeCuttingToolClick = () => {
    EventBus.emit(GameEvent.ToolSelected, ToolType.TreeCutting);
  };

  return (
    <BarWrapper>
      <ToolButton
        toolType={ToolType.TreeCutting}
        isActive={activeTool === ToolType.TreeCutting}
        onClick={handleTreeCuttingToolClick}
        title="Select Trees for Cutting"
      />
    </BarWrapper>
  );
};

// ---

// PinButton.tsx
import React from 'react';
import styled from '@emotion/styled';

export enum PinIconType {
  LOOKING_GLASS = 'LOOKING_GLASS',
  CHEVRON = 'CHEVRON',
}

export type ChevronDirection = 'up' | 'down' | 'left' | 'right';

const pinIconMap: Record<PinIconType, string> = {
  [PinIconType.CHEVRON]: 'assets/pins/chevron.png',
  [PinIconType.LOOKING_GLASS]: 'assets/pins/looking_glass.png',
};

interface PinButtonProps extends React.ButtonHTMLAttributes<HTMLDivElement> {
  iconType: PinIconType;
  title: string;
  onClick: (event: React.MouseEvent<HTMLDivElement>) => void;
  direction?: ChevronDirection; 
  size?: string;
}

const getRotationForDirection = (direction?: ChevronDirection): number => {
  switch (direction) {
    case 'up':
      return 0;
    case 'down':
      return 180;
    case 'left':
      return -90;
    case 'right':
      return 90;
    default:
      return 0; // Default to 'up' if undefined or for non-chevron
  }
};

const StyledPinButton = styled.div<{
  buttonSize: string;
}>`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: ${props => props.buttonSize};
  height: ${props => props.buttonSize};
  padding: 0;
  border-radius: 50%;
  cursor: pointer;
`;

const IconImage = styled.img<{ rotation: number }>`
  width: 100%;
  height: 100%;
  object-fit: contain;
  transform: rotate(${props => props.rotation}deg);
  transition: transform 0.25s ease-in-out; /* Animation for rotation */
`;

export const PinButton: React.FC<PinButtonProps> = ({
  iconType,
  title,
  onClick,
  direction = 'up',
  size = '24px',
  disabled,
  className,
  ...rest
}) => {
  const iconSrc = pinIconMap[iconType];

  if (!iconSrc) {
    console.warn(`PinButton: Icon for type "${iconType}" not found.`);
    return null;
  }

  const rotation = iconType === PinIconType.CHEVRON ? getRotationForDirection(direction) : 0;

  return (
    <StyledPinButton
      type="button"
      title={title}
      aria-label={title}
      buttonSize={size}
      onClick={onClick}
      className={className}
      {...rest}
    >
      <IconImage src={iconSrc} alt="" rotation={rotation} />
    </StyledPinButton>
  );
};

// ---

// TabButton.tsx
import React from 'react';
import styled from '@emotion/styled';
import { Icon } from './../icons/Icon';

interface TabButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  /** Text label for the tab. Optional. */
  label?: string;
  /** Optional: Source path for an icon. Required if label is not provided. */
  iconSrc?: string;
  /** True if this tab is currently active/selected. */
  isActive: boolean;
  /** Accessible name for the button, defaults to the label or a generic tab description. */
  title?: string;
  /** CSS height string (e.g., '40px'). */
  height?: string;
  /** Min CSS width string (e.g., '40px' for icon-only, '100px' for text). */
  minWidth?: string;
  /** Padding for the button content. */
  padding?: string;
  /** Color for the border/background when the button is active. */
  activeColor?: string;
  /** Default text color. */
  textColor?: string;
  /** Text color when active. */
  activeTextColor?: string;
  /** Default background color for the active tab. */
  activeTabBackgroundColor?: string;
  /** Background color for inactive tabs. */
  inactiveTabBackgroundColor?: string;
}

const StyledTabButton = styled.button<{
  isActive: boolean;
  buttonHeight: string;
  buttonMinWidth: string;
  buttonPadding: string;
  activeColor: string;
  textColor: string;
  activeTextColor: string;
  activeBgColor: string;
  inactiveBgColor: string;
  hasLabel: boolean;
  hasIcon: boolean;
}>`
  display: inline-flex;
  align-items: center;
  justify-content: ${props => (props.hasLabel && props.hasIcon ? 'flex-start' : 'center')}; /* Center if icon-only or label-only */
  height: ${props => props.buttonHeight};
  min-width: ${props => props.buttonMinWidth};
  padding: ${props => props.buttonPadding};
  border-radius: 6px 6px 0 0;
  cursor: pointer;
  font-weight: 500;
  font-size: 0.9rem;
  text-align: center;
  white-space: nowrap;

  border: 1px solid ${props => (props.isActive ? props.activeColor : 'transparent')};
  border-bottom: none;
  background-color: ${props => (props.isActive ? props.activeBgColor : props.inactiveBgColor)};
  color: ${props => (props.isActive ? props.activeTextColor : props.textColor)};

  transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;

  &:hover:not(:disabled):not(.isActive) {
    background-color: ${props => props.isActive ? props.activeBgColor : 'rgba(255, 255, 255, 0.1)'};
    color: ${props => props.activeTextColor};
  }

  &:disabled {
    cursor: not-allowed;
    opacity: 0.5;
  }

  .tab-icon-element { /* Renamed class for clarity */
    margin-right: ${props => (props.hasLabel ? '8px' : '0')}; /* Space only if label exists */
  }
`;

export const TabButton: React.FC<TabButtonProps> = ({
  label,
  iconSrc,
  isActive,
  title,
  height = '36px',
  minWidth, // Default will be conditional
  padding = '0 12px',
  activeColor = '#FFD700',
  textColor = 'rgba(255, 255, 255, 0.7)',
  activeTextColor = '#FFFFFF',
  activeTabBackgroundColor = 'rgba(0, 0, 0, 0.9)',
  inactiveTabBackgroundColor = 'rgba(0, 0, 0, 0.3)',
  onClick,
  disabled,
  className,
  ...rest
}) => {
  if (!label && !iconSrc) {
    console.warn("TabButton: Either 'label' or 'iconSrc' must be provided.");
    return null;
  }

  const defaultMinWidth = label ? '80px' : `calc(${height} + 8px)`; // Adjust icon-only width based on height

  return (
    <StyledTabButton
      type="button"
      title={title || label || 'Tab'}
      aria-label={title || label || 'Tab'}
      aria-selected={isActive}
      role="tab"
      isActive={isActive}
      buttonHeight={height}
      buttonMinWidth={minWidth || defaultMinWidth}
      buttonPadding={label ? padding : '0'} // No padding if icon-only and centered
      activeColor={activeColor}
      textColor={textColor}
      activeTextColor={activeTextColor}
      activeBgColor={activeTabBackgroundColor}
      inactiveBgColor={inactiveTabBackgroundColor}
      onClick={onClick}
      disabled={disabled}
      className={`${className || ''} ${isActive ? 'isActive' : ''}`}
      hasLabel={!!label}
      hasIcon={!!iconSrc}
      {...rest}
    >
      {iconSrc && (
        <Icon
          iconSrc={iconSrc}
          shape="square" // Or 'circle' if preferred
          size={`calc(${height} * 0.55)`}
          backgroundColor="transparent"
          borderColor="transparent"
          className="tab-icon-element" // Added class for specific styling if needed
        />
      )}
      {label && <span>{label}</span>}
    </StyledTabButton>
  );
};

// ---

// ToolButton.tsx
import React from 'react';
import styled from '@emotion/styled';
import { Icon } from './../icons/Icon'; 
import { ToolType } from '../../../../game/display/game/tools/GameTools';


const toolIconMap: Partial<Record<ToolType, string>> = {
  [ToolType.Selection]: 'assets/icons/selection_tool.svg',
  [ToolType.TreeCutting]: 'assets/icons/axe_icon.png',
};

interface ToolButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  /** The type of tool this button represents. Used for icon lookup. */
  toolType: ToolType;
  /** True if this tool is currently active/selected. */
  isActive: boolean;
  /** Accessible label for the button, also used for tooltip. */
  title: string;
  /** CSS size string (e.g., '48px', '3rem'). Defines width and height. */
  size?: string;
  /** Color for the border when the button is active. */
  activeBorderColor?: string;
  /** Background color when the button is active. */
  activeBackgroundColor?: string;
  /** Default background color for the icon (passed to base Icon). */
  iconBackgroundColor?: string;
  /** Default border color for the icon (passed to base Icon if not active). */
  iconBorderColor?: string;
}

const StyledToolButton = styled.button<{
  buttonSize: string;
  isActive: boolean;
  activeBgColor: string;
  activeBdrColor: string;
  // Normal state colors are handled by the Icon component's defaults or passed props
}>`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: ${props => props.buttonSize};
  height: ${props => props.buttonSize};
  padding: 0; /* Icon component will have its own padding/sizing */
  border: none; /* Reset browser default button border */
  background-color: transparent; /* Wrapper is transparent, Icon handles its own background */
  cursor: pointer;
  transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;

  /* Styling for the Icon component based on isActive can be done by passing different props
     or the Icon component itself could be made aware of an isActive prop.
     Here, we mainly style the button wrapper if needed.
     The primary visual change for active state will be on the Icon's border/bg.
  */

  &:hover:not(:disabled):not(:active) {
    /* Subtle hover effect on the button wrapper if desired, e.g., a slight scale or shadow */
    /* transform: scale(1.05); */
  }

  &:active:not(:disabled) {
    transform: scale(0.95);
  }

  &:disabled {
    cursor: not-allowed;
    opacity: 0.5; /* Applied to the whole button including the Icon */
  }

  /* For an inset shadow effect on the button itself when active, similar to .action-button.active */
  ${({ isActive, activeBgColor }) =>
    isActive &&
    `
    box-shadow: inset 0 0 6px 2px rgba(255, 255, 255, 0.7); /* Example active style */
    /* background-color: ${activeBgColor}; // Optionally change wrapper background */
  `}
`;

export const ToolButton: React.FC<ToolButtonProps> = ({
  toolType,
  isActive,
  title,
  size = '48px',
  activeBorderColor = '#FFD700',
  activeBackgroundColor = 'rgba(0, 0, 0, 0.2)',
  iconBackgroundColor,
  iconBorderColor,
  onClick,
  disabled,
  className,
  ...rest
}) => {
  const iconSrc = toolIconMap[toolType] || 'assets/icons/unknown_tool.svg';

  return (
    <StyledToolButton
      type="button"
      title={title}
      aria-label={title}
      aria-pressed={isActive}
      buttonSize={size}
      isActive={isActive}
      activeBgColor={activeBackgroundColor}
      activeBdrColor={activeBorderColor}
      onClick={onClick}
      disabled={disabled}
      className={className}
      {...rest}
    >
      <Icon
        iconSrc={iconSrc}
        shape="square"
        size="100%"
        backgroundColor={isActive ? activeBackgroundColor : iconBackgroundColor}
        borderColor={isActive ? activeBorderColor : iconBorderColor}
        alt=""
      />
    </StyledToolButton>
  );
};

// ---

// ActionIcon.tsx
import React from 'react';
import { Icon } from './Icon';
import { CharacterAction } from '../../../../game/logic/intent/intent-to-action/actionIntentData';
import { actionIconMap } from './actionIconMap';

interface ActionIconProps {
  /** The type of action to display an icon for. */
  actionType: CharacterAction;
  /** CSS size string (e.g., '24px', '2rem'). Will be applied to width and height. */
  size: string;
  /** Optional additional CSS class name(s). */
  className?: string;
  /** Optional override for background color. */
  backgroundColor?: string;
  /** Optional override for border color. */
  borderColor?: string;
  /** Optional override for border width. */
  borderWidth?: string;
  /** Alt text for the icon image. Defaults to the action type. */
  alt?: string;
}

export const ActionIcon: React.FC<ActionIconProps> = ({
  actionType,
  size,
  className,
  backgroundColor, // Allow overriding base Icon defaults if needed
  borderColor,
  borderWidth,
  alt,
}) => {
  const iconSrc = actionIconMap[actionType] || 'assets/icons/unknown_action_icon.png'; // Fallback icon

  return (
    <Icon
      iconSrc={iconSrc}
      shape="circle"
      size={size}
      backgroundColor={backgroundColor} // Pass down or use Icon's default
      borderColor={borderColor}         // Pass down or use Icon's default
      borderWidth={borderWidth}         // Pass down or use Icon's default
      className={className}
      alt={alt || actionType.toString()} // Default alt text to the action type
    />
  );
};

// ---

import React from 'react';
import { Icon } from './Icon';

export interface BuffDebuffIconProps {
  /** Direct path to the icon asset, from DisplayableBuffData.iconAssetKey. */
  iconAssetKey: string;
  /** Alt text for accessibility, from DisplayableBuffData.displayName or description. */
  altText: string;
  /** Remaining duration of the effect in minutes. */
  remainingDurationMinutes?: number;
  /** Total original duration of the effect in minutes. */
  totalDurationMinutes?: number;
  /** True if the effect is a buff, false if it's a debuff. */
  isBuff: boolean;
  /** CSS size string for the icon (e.g., '24px', '2rem'). */
  size: string;

  /** Optional additional CSS class name(s). */
  className?: string;
  /** Optional override for the icon's background color. */
  backgroundColor?: string;
  /** Optional override for the icon's border color. */
  borderColor?: string;
  /** Optional override for the icon's border width. */
  borderWidth?: string;
  /** Optional override for the foreground fill color for buffs. */
  buffFillColor?: string;
  /** Optional override for the foreground fill color for debuffs. */
  debuffFillColor?: string;
}

export const BuffDebuffIcon: React.FC<BuffDebuffIconProps> = ({
  iconAssetKey,
  altText,
  remainingDurationMinutes,
  totalDurationMinutes,
  isBuff,
  size,
  className,
  backgroundColor,
  borderColor,
  borderWidth,
  buffFillColor = 'rgba(76, 175, 80, 0.7)', // Default green for buff fill
  debuffFillColor = 'rgba(244, 67, 54, 0.7)', // Default red for debuff fill
}) => {
  let foregroundFillPercent: number | undefined = undefined;

  if (
    typeof remainingDurationMinutes === 'number' &&
    typeof totalDurationMinutes === 'number' &&
    totalDurationMinutes > 0
  ) {
    foregroundFillPercent = Math.max(0, Math.min(remainingDurationMinutes / totalDurationMinutes, 1));
  } else if (typeof remainingDurationMinutes === 'number' && remainingDurationMinutes > 0 && typeof totalDurationMinutes !== 'number') {
    // If it has a remaining duration but no total, assume it's fully filled (e.g., persistent toggle buffs)
    // or for buffs that don't deplete/have indefinite visual representation.
    foregroundFillPercent = 1;
  } else if (typeof remainingDurationMinutes === 'number' && remainingDurationMinutes <=0 && typeof totalDurationMinutes !== 'number') {
    // If remaining is zero or less, and no total duration, assume empty.
    foregroundFillPercent = 0;
  }


  const currentForegroundColor = isBuff ? buffFillColor : debuffFillColor;

  return (
    <Icon
      iconSrc={iconAssetKey}
      shape="circle"
      size={size}
      backgroundColor={backgroundColor}
      borderColor={borderColor}
      borderWidth={borderWidth}
      foregroundColor={currentForegroundColor}
      foregroundFillPercent={foregroundFillPercent}
      className={className}
      alt={altText}
    />
  );
};

// ---

// Icon.tsx
import React from 'react';
import styled from '@emotion/styled';

interface IconProps {
  /** Source path for the icon image/SVG. */
  iconSrc: string;
  /** Shape of the icon's bounding box. */
  shape: 'circle' | 'square';
  /** CSS size string (e.g., '24px', '2rem'). */
  size: string;
  /** Background color of the icon. */
  backgroundColor?: string;
  /** Border color of the icon. */
  borderColor?: string;
  /** CSS border width string (e.g., '1px', '0.1rem'). */
  borderWidth?: string;
  /** Color for the foreground fill/overlay. */
  foregroundColor?: string;
  /** Percentage (0.0 to 1.0) for the foreground fill. Fill originates from the bottom. */
  foregroundFillPercent?: number;
  /** Additional CSS class name(s). */
  className?: string;
  /** Alt text for the icon image. */
  alt?: string;

  opacity?: number;
}

const IconWrapper = styled.div<{
  shape: 'circle' | 'square';
  size: string;
  bgColor: string;
  bColor: string;
  bWidth: string;
  opacity: number;
}>`
  opacity: ${props => props.opacity}; 
  width: ${props => props.size};
  height: ${props => props.size};
  background-color: ${props => props.bgColor};
  border: ${props => props.bWidth} solid ${props => props.bColor};
  border-radius: ${props => (props.shape === 'circle' ? '50%' : '4px')};
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
  box-sizing: border-box;
  flex-shrink: 0; /* Prevent shrinking in flex containers */
`;

const IconImage = styled.img`
  width: 70%; /* Default scaling, adjust as needed */
  height: 70%; /* Default scaling, adjust as needed */
  object-fit: contain;
  position: relative;
  z-index: 2; /* Ensures icon is above the fill */
`;

const ForegroundFill = styled.div<{
  fillAmount: number; // Percentage 0-100
  fillFgColor: string;
}>`
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: ${props => props.fillAmount}%;
  background-color: ${props => props.fillFgColor};
  z-index: 1; /* Behind the icon image */
  transition: height 0.2s linear;
`;

export const Icon: React.FC<IconProps> = ({
  iconSrc,
  shape,
  size,
  backgroundColor = 'rgba(0, 0, 0, 0.3)',
  borderColor = 'rgba(255, 255, 255, 0.5)',
  borderWidth = '1px',
  foregroundColor,
  foregroundFillPercent, // Expects 0.0 to 1.0
  className,
  alt = '', 
  opacity = 1
}) => {
  const showFill =
    typeof foregroundFillPercent === 'number' &&
    foregroundColor &&
    foregroundFillPercent >= 0 &&
    foregroundFillPercent <= 1;

  const fillPercentageForCSS = showFill ? foregroundFillPercent * 100 : 0;

  return (
    <IconWrapper
      shape={shape}
      size={size}
      bgColor={backgroundColor}
      bColor={borderColor}
      bWidth={borderWidth}
      className={className}
      opacity={opacity}
      title={alt}
    >
      {showFill && (
        <ForegroundFill
          fillAmount={fillPercentageForCSS}
          fillFgColor={foregroundColor}
        />
      )}
      <IconImage src={iconSrc} alt={alt} />
    </IconWrapper>
  );
};

// ---

// ScheduleIcon.tsx
import React from 'react';
// import styled from '@emotion/styled'; // Not strictly needed if all styling is handled by Icon component
import { Icon } from './Icon'; // Assuming Icon.tsx is in the same directory or adjust path
import { CharacterIntent } from '../../../../game/logic/intent/intent-to-action/actionIntentData'; // Adjust path as needed

export type ScheduleActivityType = CharacterIntent;

const scheduleIconMap: Partial<Record<ScheduleActivityType, string>> = {
  [CharacterIntent.NONE]: 'assets/icons/idle_icon.png',
  [CharacterIntent.HARVEST]: 'assets/icons/axe_icon.png',
  [CharacterIntent.BUILD]: 'assets/icons/build_icon.png',
  [CharacterIntent.SLEEP]: 'assets/icons/sleep_icon.png',
  [CharacterIntent.REST]: 'assets/icons/relax_icon.png',
  [CharacterIntent.STUDY]: 'assets/icons/book_icon.png',
};

interface ScheduleIconProps {
  /** The type of scheduled activity to display an icon for. */
  activityType: ScheduleActivityType;
  /** True if this schedule slot is currently active or highlighted. */
  isActive: boolean;
  /** CSS size string (e.g., '24px', '2rem'). Will be applied to width and height. */
  size: string;
  /** Optional additional CSS class name(s). */
  className?: string;
  /** Optional override for background color. */
  backgroundColor?: string;
  /** Optional override for border color when inactive. */
  borderColor?: string;
  /** Optional override for border width. */
  borderWidth?: string;
  /** Color for the border when the icon is active. */
  activeBorderColor?: string;
  /** Opacity when the icon is not active (e.g. for past/future schedule items) */
  inactiveOpacity?: number;
  /** Alt text for the icon image. Defaults to the activity type. */
  alt?: string;
}

export const ScheduleIcon: React.FC<ScheduleIconProps> = ({
  activityType,
  isActive,
  size,
  className,
  backgroundColor, // Default from Icon component if not provided
  borderColor,     // Default from Icon component if not provided
  borderWidth,     // Default from Icon component if not provided
  activeBorderColor = 'rgba(255, 215, 0, 0.9)', // Default gold for active
  inactiveOpacity = 0.7,
  alt,
}) => {
  const iconSrc = scheduleIconMap[activityType] || 'assets/icons/unknown_schedule_icon.png'; // Fallback icon

  const currentBorderColor = isActive ? activeBorderColor : borderColor;
  const currentOpacity = isActive ? 1 : inactiveOpacity;

  return (
    <Icon
      iconSrc={iconSrc}
      shape="square"
      size={size}
      backgroundColor={backgroundColor}
      borderColor={currentBorderColor}
      borderWidth={borderWidth}
      className={className}
      opacity={currentOpacity }
      alt={alt || CharacterIntent[activityType] || 'Scheduled Activity'} // Default alt text
    />
  );
};

// ---

import { CharacterAction } from '../../../../game/logic/intent/intent-to-action/actionIntentData';

export const actionIconMap: Partial<Record<CharacterAction, string>> = {
    [CharacterAction.IDLE]: 'assets/icons/idle_icon.png',
    [CharacterAction.WALKING]: 'assets/icons/walk_icon.png',
    [CharacterAction.CHOPPING]: 'assets/icons/axe_icon.png',
    [CharacterAction.SLEEPING]: 'assets/icons/sleep_icon.png',
    [CharacterAction.RELAXING]: 'assets/icons/relax_icon.png',
    [CharacterAction.STUDYING]: 'assets/icons/book_icon.png',
    [CharacterAction.BUILDING]: 'assets/icons/build_icon.png',
    [CharacterAction.STROLLING]: 'assets/icons/relax_icon.png',
    [CharacterAction.EATING]: 'assets/icons/eat_icon.png',
};


// ---

// src/ui/needs/NeedBar.tsx
import React from 'react'; // Removed useState, useEffect
import styled from '@emotion/styled';
import { Fillbar } from '../Fillbar';
import { NeedType, needDisplayInfoMap, formatChangeRate } from './NeedTypes';

interface NeedColorConfig {
  fillColor: string;       // Primary color for the Fillbar fill
  backgroundColor?: string; // Optional: Specific background for this need's Fillbar
  labelColor?: string;      // Optional: Specific color for this need's label text
}

const needVisualConfigMap: Record<NeedType, NeedColorConfig> = {
  [NeedType.SLEEP]: {
    fillColor: "#5DADE2", // A calm blue
    // backgroundColor: "#2C3E50",
    // labelColor: "#ECF0F1",
  },
  [NeedType.FOOD]: {
    fillColor: "#F39C12", // A warm orange/yellow
    // backgroundColor: "#4A2E0D",
    // labelColor: "#ECF0F1",
  },
  [NeedType.FUN]: {
    fillColor: "#58D68D", // A pleasant green
  },
};

export interface NeedUIData {
  type: NeedType;
  current: number;
  max: number;
  changeRatePerHour: number;
  fillColorOverride?: string;
}

interface NeedBarProps {
  needData: NeedUIData;
  isCollapsed: boolean;
  barOverallHeight?: string;
  fillbarWidth?: string;
  positiveRateColor?: string;
  negativeRateColor?: string;
  neutralRateColor?: string;
  labelColor?: string;
}

const NeedBarWrapper = styled.div<{ height: string }>`
  display: flex;
  align-items: center;
  margin-bottom: 4px;
  width: 100%;
  height: ${props => props.height};
`;

const FillbarContainer = styled.div<{ width: string }>`
  display: flex;
  align-items: baseline;
  width: ${props => props.width};
  flex-shrink: 0;
`;

const InfoRow = styled.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  margin-left: 8px;
  flex-grow: 1;
  min-width: 0;
`;

const NeedLabel = styled.span<{ color: string }>`
  font-size: 0.8rem;
  font-weight: 500;
  color: ${props => props.color};
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
`;

const ChangeRateText = styled.span<{ color: string }>`
  font-size: 0.7rem;
  font-style: italic;
  color: ${props => props.color};
`;

export const NeedBar: React.FC<NeedBarProps> = ({
  needData,
  isCollapsed,
  barOverallHeight = '24px',
  fillbarWidth = '60%',
  positiveRateColor = '#2ECC71',
  negativeRateColor = '#E74C3C',
  neutralRateColor = '#BDC3C7',
  labelColor = '#ECF0F1',
}) => {
  // Directly use needData.current and needData.max from props
  const { current, max, type, changeRatePerHour, fillColorOverride } = needData;
  const visualConfig = needVisualConfigMap[needData.type];
  const fillColorForBar = needData.fillColorOverride || visualConfig?.fillColor || '#7F8C8D'; // Fallback

  const displayInfo = needDisplayInfoMap[type] || {
    label: type.toString(),
    defaultFillColor: '#7F8C8D',
  };

  const rateColor =
    changeRatePerHour > 0 ? positiveRateColor :
    changeRatePerHour < 0 ? negativeRateColor :
    neutralRateColor;

  const fillbarVisualHeight = isCollapsed ? `calc(${barOverallHeight} * 0.7)` : `calc(${barOverallHeight} * 0.5)`;

  return (
    <NeedBarWrapper height={barOverallHeight}>
      <FillbarContainer width={isCollapsed ? '100%' : fillbarWidth}>
        <Fillbar
          currentValue={current} 
          maxValue={max}
          fillColor={fillColorForBar}
          height={fillbarVisualHeight}
          width="50%"
        />
        {!isCollapsed && (
          <div style={{width:"24px"}}/>)
        }
        {!isCollapsed && (
          <NeedLabel color={labelColor} title={displayInfo.label}>
            {displayInfo.label}
          </NeedLabel>
        )}
      </FillbarContainer>
      {!isCollapsed && (
        <InfoRow>
          <ChangeRateText color={rateColor}>
            {current}/{max} {formatChangeRate(changeRatePerHour)}
          </ChangeRateText>
        </InfoRow>
      )}
    </NeedBarWrapper>
  );
};

// ---

// src/ui/common/NeedTypes.ts (example path)

export enum NeedType {
    SLEEP = "Sleep",
    FOOD = "Hunger",
    FUN = "Fun"
}

export interface NeedDisplayInfo {
    label: string;
    defaultFillColor: string;
}

export const needDisplayInfoMap: Record<NeedType, NeedDisplayInfo> = {
    [NeedType.SLEEP]: { label: "Sleep", defaultFillColor: "#3498DB"},
    [NeedType.FOOD]: { label: "Food", defaultFillColor: "#E67E22"},
    [NeedType.FUN]: { label: "Fun", defaultFillColor: "#2ECC71"},
};

// Utility function to format the change rate
export const formatChangeRate = (rate: number): string => {
    if (rate === 0) return "0/hr";
    return `${rate > 0 ? '+' : rate < 0 ? '-' : ''}${rate}/hr`;
};

// ---

import React from 'react';
import styled from '@emotion/styled';
import { NeedBar, NeedUIData } from './NeedBar';

interface NeedsDisplayProps {
  needs: NeedUIData[];
  isCollapsed: boolean;
  className?: string;

  // --- Styling props passed down to NeedBar ---
  // Overall height for each NeedBar row
  openBarOverallHeight?: string;
  collapsedBarOverallHeight?: string;

  // Width for the Fillbar part within NeedBar when open
  openFillbarWidth?: string; // When collapsed, NeedBar makes its fillbar 100%

  // Colors for changeRatePerHour text and labels
  positiveRateColor?: string;
  negativeRateColor?: string;
  neutralRateColor?: string;
  labelColor?: string;
}

const NeedsDisplayWrapper = styled.div`
  display: flex;
  flex-direction: column;
  width: 100%;
  padding: 2px 0; /* Minimal vertical padding */
  box-sizing: border-box;
`;

export const NeedsDisplay: React.FC<NeedsDisplayProps> = ({
  needs,
  isCollapsed,
  className,
  openBarOverallHeight = '24px',    // Default for open state
  collapsedBarOverallHeight = '8px', // Default for collapsed state
  openFillbarWidth = '60%',       // Default fillbar width in open state
  // Colors for rate/label are passed to NeedBar, which has its own defaults
  positiveRateColor,
  negativeRateColor,
  neutralRateColor,
  labelColor,
}) => {
  const currentBarOverallHeight = isCollapsed ? collapsedBarOverallHeight : openBarOverallHeight;
  // In collapsed mode, NeedBar itself will set its fillbar container to 100% width.
  // In open mode, we pass the specified openFillbarWidth.
  const currentFillbarWidthForChild = isCollapsed ? '100%' : openFillbarWidth;


  if (!needs || needs.length === 0) {
    return null;
  }

  return (
    <NeedsDisplayWrapper className={className}>
      {needs.map((needData) => (
        <NeedBar
          key={needData.type} // Assuming NeedType is unique per character's need list
          needData={needData}
          isCollapsed={isCollapsed}
          barOverallHeight={currentBarOverallHeight}
          fillbarWidth={currentFillbarWidthForChild} // This prop is used by NeedBar for its FillbarContainer
          positiveRateColor={positiveRateColor}
          negativeRateColor={negativeRateColor}
          neutralRateColor={neutralRateColor}
          labelColor={labelColor}
        />
      ))}
    </NeedsDisplayWrapper>
  );
};

// ---

import React, { useState, useEffect, useCallback } from 'react';
import styled from '@emotion/styled';

import { EventBus } from '../../../../game/EventBus';
import { PanelType } from '../../../../game/display/setup/ViewDefinition';
import { PinButton, PinIconType, ChevronDirection } from '../buttons/PinButton';
import { SelectionTabBar } from './SelectionTabBar';
import { TABS_CONFIG } from './TabTypes'; // Ensure this path is correct
import { GameUIEvent } from '../../../../game/consts/UIEvent'; // Using your GameUIEvent
import { CharacterThoughtsContentCollapsed } from './character/CharacterThoughtsContentCollapsed';
import { CharacterThoughtsContent } from './character/CharacterThoughtsContent';
import { CharacterInfoContent } from './character/CharacterInfoContent';
import { CharacterInfoContentCollapsed } from './character/CharcterInfoContentCollapsed';
import { TreePanelContent } from './tree/TreePanelContent';

export interface SelectedEntityPayload {
  id: string | number;
  title: string;
  panelType: PanelType;
  panelTypeData: any;
  findAction?:()=>void;
}

export interface EntityContentViewProps<TData = any> {
  data: TData;
  isContentAreaCollapsed: boolean;
}
export type EntityContentView<TData = any> = React.FC<EntityContentViewProps<TData>>;

type ContentByTab = Partial<Record<string, EntityContentView>>;

const charContentRegistry: ContentByTab = {
  ['thoughts']: ({ data, isContentAreaCollapsed }) => isContentAreaCollapsed ? <CharacterThoughtsContentCollapsed data={data}/> : <CharacterThoughtsContent  data={data}/>,
  ['info']: ({ data, isContentAreaCollapsed }) => isContentAreaCollapsed ? <CharacterInfoContentCollapsed data={data}/> : <CharacterInfoContent  data={data}/>,
};

const treeContentRegistry: ContentByTab = {
  "info": ({ data, isContentAreaCollapsed }) => {
    return <TreePanelContent data={data} />;
  }
};

const contentViewRegistry: Partial<Record<PanelType, ContentByTab>> = {
    [PanelType.CHARACTER]: charContentRegistry,
    [PanelType.TREE]: treeContentRegistry,
};

const PanelOuterWrapper = styled.div`
  position: relative;
  bottom: 0;
  left: 0;
  width: 100%;
  display: flex;
  flex-direction: column;
  width: 400px;
  z-index: 800;
  background-color: transparent; /* Outer wrapper is transparent */
`;

const PlaceholderText = styled.div<{ height: string }>`
  display: flex;
  align-items: center;
  justify-content: center;
  height: ${props => props.height};
  font-size: 0.8rem;
  color: #777;
  font-style: italic;
  background-color: rgba(30, 32, 35, 0.98); /* Background for placeholder only */
  flex-shrink: 0;
`;

const MainContentWrapper = styled.div`
  background-color: rgba(30, 32, 35, 0.98); /* Main panel background, below tabs if tabs are styled separately */
  color: #dde;
  display: flex;
  flex-direction: column;
  flex-grow: 1; /* Allows it to expand if PanelOuterWrapper uses flex for height */
  min-height: 0; /* For flex children */
  padding-left: 8px;
`;


const ThinControlBar = styled.div`
  font-size: 0.8rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  height: 24px; /* Slightly smaller */
  flex-shrink: 0;
  border-bottom: 1px solid #2a2c2e;
`;

const TabContentArea = styled.div`
  background-color: transparent;
  flex-grow: 1;
  overflow-y: auto;
  overflow-x: hidden;
  min-height: 0; /* Important for flex context */
  &::-webkit-scrollbar { width: 5px; }
  &::-webkit-scrollbar-thumb { background-color: rgba(255,255,255,0.15); border-radius: 3px; }
  &::-webkit-scrollbar-track { background-color: transparent; }
`;

const MINIMAL_PANEL_HEIGHT_NO_SELECTION = '36px';
const TAB_BAR_HEIGHT = '30px';

export const SelectionPanel: React.FC = () => {
  const [currentEntity, setCurrentEntity] = useState<SelectedEntityPayload | null>(null);
  const [isContentAreaCollapsed, setIsContentAreaCollapsed] = useState<boolean>(true);
  const [activeTabId, setActiveTabId] = useState<string | null>(null);

  useEffect(() => {
    const handleSelectedEntityUpdate = (data: SelectedEntityPayload | null) => {
      setCurrentEntity(data);

      const tabs = TABS_CONFIG[data?.panelType as PanelType];
      if (!tabs) {
        setActiveTabId(null);
        return;
      }
      
      const currentIndex = tabs.findIndex((value)=>value.id == activeTabId);
      
      currentIndex == -1 && setActiveTabId(tabs[0].id);
    };
    EventBus.on(GameUIEvent.ShowPanelCalled, handleSelectedEntityUpdate);
    return () => {
      EventBus.off(GameUIEvent.ShowPanelCalled, handleSelectedEntityUpdate);
    };
  }, [activeTabId]);

  const toggleContentCollapse = useCallback(() => {
    setIsContentAreaCollapsed(prev => !prev);
  }, []);

  const handleTabSelect = useCallback((tabId: string) => {
    setActiveTabId(tabId);
  }, []);

  const currentPanelType = currentEntity?.panelType as PanelType | null;
  const ContentComponentToRender = currentPanelType ? contentViewRegistry[currentPanelType]?.[activeTabId ?? ''] : null;
  const hasTabs = !!(currentPanelType && TABS_CONFIG[currentPanelType] && TABS_CONFIG[currentPanelType]!.length > 0);

  if (!currentEntity) {
    return (
      <PanelOuterWrapper>
        <PlaceholderText height={MINIMAL_PANEL_HEIGHT_NO_SELECTION}>
          Nothing Selected
        </PlaceholderText>
      </PanelOuterWrapper>
    );
  }

  const chevronDirection: ChevronDirection = !isContentAreaCollapsed ? 'up' : 'down';

  return (
    <PanelOuterWrapper>
      {hasTabs && currentPanelType && (
        <SelectionTabBar
          panelType={currentPanelType}
          activeTabId={activeTabId}
          onTabSelect={handleTabSelect}
          tabButtonHeight={TAB_BAR_HEIGHT}
        />
      )}
      <MainContentWrapper>
        <ThinControlBar>
          {currentEntity.title}
          <div>
          {
            currentEntity?.findAction ? 
            <PinButton
              iconType={PinIconType.LOOKING_GLASS}
              title="Inspect Selected"
              onClick={currentEntity.findAction}
              size="16px"
            /> : null
          }
          {hasTabs && (
            <PinButton
              iconType={PinIconType.CHEVRON}
              direction={chevronDirection}
              title={isContentAreaCollapsed ? "Open Details" : "Collapse Details"}
              onClick={toggleContentCollapse}
              size="16px"
            />
          )}
          </div>
        </ThinControlBar>
        {ContentComponentToRender && activeTabId && (
          <TabContentArea>
            <ContentComponentToRender
              data={currentEntity.panelTypeData}
              isContentAreaCollapsed={isContentAreaCollapsed}
            />
          </TabContentArea>
        )}
      </MainContentWrapper>
    </PanelOuterWrapper>
  );
};

// ---

import React from 'react';
import styled from '@emotion/styled';
import { TabButton } from '../buttons/TabButton';
import { PanelType } from '../../../../game/display/setup/ViewDefinition';
import { TABS_CONFIG } from './TabTypes';

interface SelectionTabBarProps {
  panelType: PanelType | null;
  activeTabId: string | null;
  onTabSelect: (tabId: string) => void;
  className?: string;
  tabButtonHeight?: string;
  tabButtonPadding?: string;
}

const TabBarWrapper = styled.div`
  display: flex;
  flex-direction: row;
  flex-shrink: 0;
  padding: 0 4px; /* Horizontal padding for the bar */
  gap: 2px; /* Small gap between tabs */
  overflow-x: auto; /* If many tabs, allow horizontal scrolling */
  scrollbar-width: thin; /* For Firefox */
  scrollbar-color: rgba(255,255,255,0.2) rgba(0,0,0,0.1); /* For Firefox */

  &::-webkit-scrollbar {
    height: 6px; /* Height of horizontal scrollbar */
  }
  &::-webkit-scrollbar-thumb {
    background-color: rgba(255,255,255,0.2);
    border-radius: 3px;
  }
  &::-webkit-scrollbar-track {
    background-color: rgba(0,0,0,0.1);
  }
`;

export const SelectionTabBar: React.FC<SelectionTabBarProps> = ({
  panelType,
  activeTabId,
  onTabSelect,
  className,
  tabButtonHeight = '30px',
  tabButtonPadding = '0 8px'
}) => {
  if (!panelType) {
    return null;
  }

  const availableTabs = TABS_CONFIG[panelType] || [];

  if (availableTabs.length === 0) {
    return null; // No tabs defined for this panel type
  }

  return (
    <TabBarWrapper className={className}>
      {availableTabs.map(tab => (
        <TabButton
          key={tab.id}
          label={tab.label}
          iconSrc={tab.iconSrc}
          isActive={activeTabId === tab.id}
          onClick={() => onTabSelect(tab.id)}
          height={tabButtonHeight}
          padding={tabButtonPadding}
        />
      ))}
    </TabBarWrapper>
  );
};

// ---

import { PanelType } from "../../../../game/display/setup/ViewDefinition";

export interface TabDefinition {
    id: string; 
    label?: string;
    iconSrc?: string;
  }

  export const TABS_CONFIG: Partial<Record<PanelType, TabDefinition[]>> = {
    [PanelType.CHARACTER]: [
      { id: 'info', label: 'Info'},
      { id: 'thoughts', label: 'Thoughts'},
    ],
    [PanelType.WOOD_DOJO]: [
      { id: 'dojo_overview', label: 'Details' }
    ],
    [PanelType.TREE]: [
      { id: 'info', label: 'Details' },
    ],
    [PanelType.CAVE]: [
      { id: 'cave_details', label: 'Details' },
    ]
  };

// ---

// src/ui/panel/content_views/character/CharacterInfoContent.tsx
import React from 'react';
import styled from '@emotion/styled';
import { CharacterAction } from '../../../../../game/logic/intent/intent-to-action/actionIntentData';
import { ActionIcon } from '../../icons/ActionIcon';
import { NeedUIData } from '../../needs/NeedBar';
import { NeedsDisplay } from '../../needs/NeedsDisplay';
import { ScheduleUIData, ScheduleDisplay } from '../../schedule/ScheduleDisplay';
import { StatusEffectsDisplay } from '../../status/StatusEffectsDisplay';
import { DisplayableBuffData } from '../../../../../game/display/game/data_panel/character/deriveBuffs';


// Data structure expected for this component
export interface CharacterInfoData {
  schedule: ScheduleUIData;
  currentAction: { type: CharacterAction; description: string }; // Or CurrentActionUIData
  needs: NeedUIData[];
  statusEffects: DisplayableBuffData[];
}

interface CharacterInfoContentProps {
  data: CharacterInfoData;
}

const InfoContentWrapper = styled.div`
  display: flex;
  flex-direction: column;
  gap: 10px; /* Space between major sections */
  height: 100%;
  padding: 5px;
`;

const Section = styled.div`
  display: flex;
  flex-direction: column;
  gap: 4px; /* Space between header and content within a section */
`;

const SectionHeader = styled.h4`
  margin: 0 0 2px 0;
  font-size: 0.75rem;
  font-weight: 600;
  color: #888c99; /* Muted header color */
  text-transform: uppercase;
  padding-bottom: 2px;
  border-bottom: 1px solid #3a3c3e;
`;

const TopRow = styled.div`
  display: flex;
  flex-direction: row;
  gap: 10px; /* Space between Schedule and Current Action sections */
  min-height: 0; /* For flex children */
`;

const TopRowSection = styled(Section)`
  flex: 1; /* Distribute space, or use fixed widths */
  min-width: 0; /* For flex children */
  &:first-of-type {
    flex-basis: 60%; /* Schedule takes more space */
  }
  &:last-of-type {
    flex-basis: 25%; /* Current Action takes less */
  }
`;

const CurrentActionDisplay = styled.div`
  display: flex;
  align-items: center;
  height: 100%;
  gap: 6px;
  font-size: 0.85rem;
  color: #c0c0c0;
  line-height: 1.3;
`;

const ActionDescription = styled.span`
  white-space: normal; /* Allow wrapping */
`;


export const CharacterInfoContent: React.FC<CharacterInfoContentProps> = ({ data }) => {
  const { schedule, currentAction, needs, statusEffects } = data;

  return (
    <InfoContentWrapper>
      <TopRow>
        <TopRowSection>
          <SectionHeader>Schedule</SectionHeader>
          <ScheduleDisplay scheduleData={schedule} iconSize="24px" />
        </TopRowSection>
        <TopRowSection>
          <SectionHeader>Current Action</SectionHeader>
          <CurrentActionDisplay>
            <ActionIcon actionType={currentAction.type} size="24px" />
            <ActionDescription>{currentAction.description}</ActionDescription>
          </CurrentActionDisplay>
        </TopRowSection>
      </TopRow>

      <Section>
        <SectionHeader>Needs</SectionHeader>
        <NeedsDisplay needs={needs} isCollapsed={false} openBarOverallHeight='20px' />
      </Section>

      <Section>
        <SectionHeader>Status Effects</SectionHeader>
        <StatusEffectsDisplay isCollapsed={false} effects={statusEffects} iconSize="18px" />
      </Section>
    </InfoContentWrapper>
  );
};

// ---

import React from 'react';
import styled from '@emotion/styled';
import { divideTime } from '../../../hooks/useGameTime';

export interface CharacterThoughtsData {
  currentStatusText: string;
  thoughtsLog?: { timestamp: number; value: string }[];
}

interface CharacterThoughtsContentProps {
  data: CharacterThoughtsData;
}

const ThoughtsContentWrapper = styled.div`
  display: flex;
  flex-direction: column;
  height: 100%;
  gap: 12px;
`;

const CurrentStatusText = styled.p`
  margin: 0;
  font-size: 0.9rem;
  line-height: 1.4;
  color: #c0c0c0;
  font-style: italic;
`;

const ThoughtsLogWrapper = styled.div`
  flex-grow: 1;
  min-height: 50px;
  border: 1px solid #2a2c2e;
  border-radius: 4px;
  padding: 8px;
  overflow-y: auto;
  background-color: rgba(0,0,0,0.1);

  &::-webkit-scrollbar { width: 5px; }
  &::-webkit-scrollbar-thumb { background-color: rgba(255,255,255,0.15); border-radius: 3px; }
  &::-webkit-scrollbar-track { background-color: transparent; }
`;

const NoThoughtsMessage = styled.p`
  margin: 0;
  font-size: 0.85rem;
  color: #666;
  font-style: italic;
  text-align: center;
  padding-top: 10px;
`;

export const CharacterThoughtsContent: React.FC<CharacterThoughtsContentProps> = ({ data }) => {
  const { currentStatusText, thoughtsLog } = data;

  return (
    <ThoughtsContentWrapper>
      <CurrentStatusText>{currentStatusText}</CurrentStatusText>
      <ThoughtsLogWrapper>
        {(!thoughtsLog || thoughtsLog.length === 0) ? (
          <NoThoughtsMessage>No recent thoughts.</NoThoughtsMessage>
        ) : (
          thoughtsLog.map((thought, index) => {
            const t = divideTime(thought.timestamp);
            return <div key={index}>
                {`${t.minute}|${t.day}|${t.hour}|${t.minute}`}: {thought.value}
            </div>
            }
          )
        )}
      </ThoughtsLogWrapper>
    </ThoughtsContentWrapper>
  );
};

// ---

import React from 'react';
import styled from '@emotion/styled';

export interface CharacterThoughtsCollapsedData {
  currentStatusText: string;
}

interface CharacterThoughtsContentCollapsedProps {
  data: CharacterThoughtsCollapsedData;
}

const CollapsedStatusText = styled.p`
  margin: 0;
  font-size: 0.85rem; /* Slightly smaller for collapsed view */
  line-height: 1.3;
  color: #b0b0b0; /* Slightly muted color */
  font-style: italic;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis; /* Truncate if too long */
  padding: 0px;
`;

export const CharacterThoughtsContentCollapsed: React.FC<CharacterThoughtsContentCollapsedProps> = ({ data }) => {
  const { currentStatusText } = data;

  return (
    <CollapsedStatusText title={currentStatusText}>
      {currentStatusText}
    </CollapsedStatusText>
  );
};

// ---

// src/ui/panel/content_views/character/CharacterInfoContentCollapsed.tsx
import React from 'react';
import styled from '@emotion/styled';
import { CharacterAction } from '../../../../../game/logic/intent/intent-to-action/actionIntentData';
import { ActionIcon } from '../../icons/ActionIcon';
import { NeedUIData } from '../../needs/NeedBar';
import { NeedsDisplay } from '../../needs/NeedsDisplay';
import { ScheduleUIData, ScheduleDisplay } from '../../schedule/ScheduleDisplay';
import { StatusEffectsDisplay } from '../../status/StatusEffectsDisplay';
import { UIStatusEffectData } from '../../status/StatusLine';

// Data structure expected for this component (subset of CharacterInfoData)
export interface CharacterInfoCollapsedData {
  schedule: ScheduleUIData;
  currentAction: { type: CharacterAction; description: string }; // Description might be used for tooltip
  statusEffects: UIStatusEffectData[];
  needs: NeedUIData[];
}

interface CharacterInfoContentCollapsedProps {
  data: CharacterInfoCollapsedData;
}

const CollapsedContentWrapper = styled.div`
  display: flex;
  align-items: center; /* Vertically align all items in the row */
  justify-content: space-between; /* Distribute space between major groups */
  gap: 8px; /* Gap between major groups */
  padding: 2px 4px; /* Minimal padding for the entire line */
  height: 100%; /* Take full height of its container (e.g., a fixed small height from TabContentArea) */
  width: 100%;
  overflow: hidden; /* Prevent internal elements from overflowing the fixed height */
`;

const CollapsedSection = styled.div`
  display: flex;
  align-items: center;
  gap: 4px; /* Gap within a section (e.g., between icons in schedule or buffs) */
  /* flex-shrink: 0; // Prevent sections from shrinking too much if space is tight */
  min-width: 0; /* Allows flex items to shrink below their content size */
`;

const ActionSection = styled(CollapsedSection)`
  /* Action might need a bit more space or specific alignment if text is shown */
  flex-shrink: 1; /* Allow action text to shrink/truncate if needed */
  overflow: hidden;
`;

const NeedsStackCollapsed = styled.div`
  display: flex;
  flex-direction: column; /* Stack needs vertically */
  align-items: flex-end; /* Align to the right if desired */
  gap: 1px; /* Minimal gap between tiny need bars */
  width: 40px;
  margin-right:8px;
`;

export const CharacterInfoContentCollapsed: React.FC<CharacterInfoContentCollapsedProps> = ({ data }) => {
  const { schedule, currentAction, statusEffects, needs } = data;

  return (
    <CollapsedContentWrapper title={currentAction.description}>
      <CollapsedSection className="schedule-collapsed-section">
        <ScheduleDisplay
          scheduleData={{ slots: schedule.slots, currentSlotIndex: schedule.currentSlotIndex }}
          iconSize="16px" // Smaller icons for collapsed view
        />
      </CollapsedSection>

      <ActionSection className="action-collapsed-section">
        <ActionIcon actionType={currentAction.type} size="18px" />
        {/* Optionally display a very short version of action text, or rely on tooltip */}
        {/* <ActionDescriptionCollapsed>{currentAction.description}</ActionDescriptionCollapsed> */}
      </ActionSection>

      <CollapsedSection className="buffs-collapsed-section">
        {/* StatusEffectsDisplay will render multiple BuffDebuffIcons horizontally */}
        <StatusEffectsDisplay isCollapsed={true} effects={statusEffects} iconSize="16px"/>
      </CollapsedSection>

      <CollapsedSection className="needs-collapsed-section">
        {/* NeedsDisplay will render multiple Fillbars (collapsed version) vertically */}
        <NeedsStackCollapsed>
            <NeedsDisplay
                needs={needs}
                isCollapsed={true}
                collapsedBarOverallHeight="4px" // Very thin bars
            />
        </NeedsStackCollapsed>
      </CollapsedSection>
    </CollapsedContentWrapper>
  );
};

// ---

// src/ui/panel/content_views/tree/ForagingSection.tsx
import React from 'react';
import styled from '@emotion/styled';
import { TreeForagableUIData } from '../../../../../game/display/game/data_panel/tree/treePanelReducer';
import { ResourceConfig } from '../../../../../game/logic/resources/ResourceConfig';
import { Fillbar } from '../../Fillbar';
import { Icon } from '../../icons/Icon';

interface ForagingSectionProps {
  data: TreeForagableUIData;
  isMarkedForForaging?: boolean;
  resourceIconSize?: string;
  fillbarHeight?: string;
  fillbarWidth?: string; // Width for the fillbar element itself
  titleColor?: string;
  textColor?: string;
  regenTextColor?: string;
}

const markedForForagingIconSrc = 'assets/icons/forage_icon.png'; // Example path

const SectionWrapper = styled.div`
  display: flex;
  flex-direction: column;
  gap: 4px;
`;

const TitleLine = styled.div`
  display: flex;
  align-items: center;
  gap: 6px;
`;

const SectionHeader = styled.h4`
  margin: 0;
  font-size: 0.75rem;
  font-weight: 600;
  text-transform: uppercase;
  flex-grow: 1;
`;

const ContentLine = styled.div`
  display: flex;
  align-items: center;
  gap: 6px; /* Reduced gap for tighter layout */
  justify-content: flex-start; /* Align all items to the left */
  font-size: 0.85rem;
`;

const ResourceIconWrapper = styled.div`
  flex-shrink: 0;
`;

const FillbarInLineWrapper = styled.div<{ width: string }>`
  width: ${props => props.width};
  flex-shrink: 0; /* Fillbar has a defined width */
`;

const AmountText = styled.span`
  flex-shrink: 0;
  min-width: 35px; /* Space for X/Y text */
  text-align: left;
`;

const RegenText = styled.span`
  font-size: 0.8rem;
  white-space: nowrap;
  flex-shrink: 0;
`;

export const ForagingSection: React.FC<ForagingSectionProps> = ({
  data,
  isMarkedForForaging = false,
  resourceIconSize = '24px',
  fillbarHeight = '10px',
  fillbarWidth = '80px', // "Rather short fillbar"
  titleColor = '#888c99',
  textColor = '#c0c0c0',
  regenTextColor = '#7f8c8d',
}) => {
  const {
    resourceType,
    currentAmount,
    maxAmount,
    regenRatePerMinute,
  } = data;

  const resourceConf = ResourceConfig[resourceType];
  const resourceIconSrc = resourceConf?.icon;
  // const resourceLabelForTitle = resourceConf?.description || resourceType.toString();

  const regenRatePerHour = (regenRatePerMinute * 60).toFixed(1);
  const amountText = `${Math.floor(currentAmount)}/${maxAmount}`;

  const foodFillColor = "#2ECC71"; // Green for food

  return (
    <SectionWrapper>
      <TitleLine>
        <SectionHeader style={{ color: titleColor }}>
          FORAGING {/* Static title as per new layout */}
        </SectionHeader>
        {isMarkedForForaging && markedForForagingIconSrc && (
          <Icon iconSrc={markedForForagingIconSrc} shape="square" size="14px" alt="Marked for Foraging" backgroundColor="transparent" borderColor="transparent"/>
        )}
      </TitleLine>
      <ContentLine style={{ color: textColor }}>
        {resourceIconSrc && (
          <ResourceIconWrapper>
            <Icon iconSrc={resourceIconSrc} shape="square" size={resourceIconSize} alt={resourceType.toString()} backgroundColor="transparent" borderColor="transparent" />
          </ResourceIconWrapper>
        )}
        <FillbarInLineWrapper width={fillbarWidth}>
          <Fillbar
            currentValue={currentAmount}
            maxValue={maxAmount}
            height={fillbarHeight}
            width="100%" // Fillbar takes full width of its short wrapper
            fillColor={foodFillColor} // Example color for food
            barBackgroundColor="#4A2E0D" // Darker, earthy background
            // No label prop for Fillbar here
          />
        </FillbarInLineWrapper>
        <AmountText>{amountText}</AmountText>
        <RegenText style={{ color: regenTextColor }}>
          (+{regenRatePerHour}/hr)
        </RegenText>
      </ContentLine>
    </SectionWrapper>
  );
};

// ---

// src/ui/panel/content_views/tree/TimberSection.tsx
import React from 'react';
import styled from '@emotion/styled';
import { TreeHarvestableUIData } from '../../../../../game/display/game/data_panel/tree/treePanelReducer';
import { ResourceType } from '../../../../../game/logic/resources/ResourceType';
import { ResourceConfig } from '../../../../../game/logic/resources/ResourceConfig';
import { Fillbar } from '../../Fillbar';
import { Icon } from '../../icons/Icon';

interface TimberSectionProps {
  data: TreeHarvestableUIData;
  resourceIconSize?: string;
  fillbarHeight?: string;
  fillbarWidth?: string; // Width for the fillbar itself
  titleColor?: string;
  textColor?: string;
}

const markedForCuttingIconSrc = 'assets/icons/axe_icon.png'; // Path to the small icon for "marked for cutting"

const SectionWrapper = styled.div`
  display: flex;
  flex-direction: column;
  gap: 4px;
`;

const TitleLine = styled.div`
  display: flex;
  align-items: center;
  gap: 6px;
  height: 24px; // Fixed height for the title line
`;

const SectionHeader = styled.h4`
  margin: 0;
  font-size: 0.75rem;
  font-weight: 600;
  text-transform: uppercase;
`;

const ContentLine = styled.div`
  display: flex;
  align-items: baseline;
  gap: 6px;
  font-size: 0.85rem;
  width: 100%;
`;

const LabelText = styled.span`
  flex-shrink: 0;
  width: 24px;
`;

const HitpointsText = styled.span`
  flex-shrink: 0;
  min-width: 40px; // To prevent jumpiness with 1/2/3 digit numbers
  text-align: right;
`;

const FillbarInLineWrapper = styled.div<{ width: string }>`
  width: ${props => props.width};
  flex-shrink: 1; // Allow fillbar to shrink if space is needed
  min-width: 50px; // Minimum width for the fillbar
`;

const YieldGroup = styled.div`
  display: flex;
  align-items: center;
  gap: 4px;
  margin-left: 64px;
  flex-shrink: 0;
`;


export const TimberSection: React.FC<TimberSectionProps> = ({
  data,
  resourceIconSize = '24px',
  fillbarHeight = '10px',
  fillbarWidth = '80px', // Default width for the fillbar element itself
  titleColor = '#888c99',
  textColor = '#c0c0c0',
}) => {
  const {
    hitpointsCurrent,
    hitpointsMax,
    yield: woodYieldData,
    isSelectedForCutting,
  } = data;

  const primaryWoodYield = woodYieldData.find(drop => drop.type === ResourceType.WOOD) || (woodYieldData.length > 0 ? woodYieldData[0] : null);
  const woodResourceDetails = primaryWoodYield ? ResourceConfig[primaryWoodYield.type as ResourceType] : null;

  return (
    <SectionWrapper>
      <TitleLine>
        <SectionHeader style={{ color: titleColor }}>TIMBER</SectionHeader>
        {isSelectedForCutting && markedForCuttingIconSrc && (
          <Icon iconSrc={markedForCuttingIconSrc} shape="square" size="24px" alt="Marked for Cutting" backgroundColor="transparent" borderColor="transparent"/>
        )}
      </TitleLine>
      <ContentLine style={{ color: textColor }}>
        <LabelText>Cut</LabelText>
        <FillbarInLineWrapper width={fillbarWidth}>
          <Fillbar
            currentValue={hitpointsCurrent}
            maxValue={hitpointsMax}
            height={fillbarHeight}
            width="100%" // Fillbar takes full width of its wrapper
            fillColor="#A0522D"
            barBackgroundColor="#593622"
            // No label prop for Fillbar here
          />
        </FillbarInLineWrapper>
        <HitpointsText>{hitpointsCurrent}/{hitpointsMax}</HitpointsText>
        
        {primaryWoodYield && woodResourceDetails && (
          <YieldGroup>
            <LabelText style={{paddingRight:"8px"}}>Yield</LabelText>
            <Icon iconSrc={woodResourceDetails.icon} shape="square" size={resourceIconSize} alt={primaryWoodYield.type} backgroundColor="transparent" borderColor="transparent" />
            <span>{primaryWoodYield.amount}</span>
          </YieldGroup>
        )}
      </ContentLine>
    </SectionWrapper>
  );
};

// ---

// src/ui/panel/content_views/tree/TreeInfoContent.tsx
import React from 'react';
import styled from '@emotion/styled';
import { TimberSection } from './TimberSection'; // Adjust path
import { ForagingSection } from './ForagingSection'; // Adjust path
import { TreePanelUIData } from '../../../../../game/display/game/data_panel/tree/treePanelReducer';

interface TreeInfoContentProps {
  data: TreePanelUIData;
}

const ContentWrapper = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px; /* Space between sections */
  height: 100%;
  padding: 5px 2px; /* Minimal padding to align with section internal paddings */
`;

const NoDataMessage = styled.div`
  font-size: 0.9rem;
  color: #888;
  font-style: italic;
  text-align: center;
  padding: 20px;
`;

export const TreePanelContent: React.FC<TreeInfoContentProps> = ({ data }) => {
  const { harvestableInfo, foragableInfo, displayName } = data;

  if (!harvestableInfo && !foragableInfo) {
    return <NoDataMessage>{displayName} has no current actions or yields.</NoDataMessage>;
  }

  return (
    <ContentWrapper>
      {harvestableInfo && (
        <TimberSection
          data={harvestableInfo}
        />
      )}
      {foragableInfo && (
        <ForagingSection
          data={foragableInfo}
        />
      )}
    </ContentWrapper>
  );
};

// ---

import React from 'react';
import styled from '@emotion/styled';
import { ScheduleIcon, ScheduleActivityType } from '../icons/ScheduleIcon'; 

export interface ScheduleUIData {
  slots: ScheduleActivityType[]; // Array representing each hour/block of the day
  currentSlotIndex?: number; // Optional: Index of the current time slot to highlight
}

interface ScheduleDisplayProps {
  scheduleData: ScheduleUIData;
  className?: string;
  iconSize?: string; // Size for each ScheduleIcon
  activeIconSize?: string; // Size for each ScheduleIcon
  activeBorderColor?: string; // Border color for the active ScheduleIcon
  inactiveOpacity?: number; // Opacity for inactive ScheduleIcons
}

const ScheduleDisplayWrapper = styled.div`
  display: flex;
  flex-direction: row;
  justify-content: space-around; /* Or 'flex-start' with gap */
  align-items: center;
  width: 100%;
  padding: 4px; /* Optional padding around the strip */
  box-sizing: border-box;
  gap: 2px; /* Optional gap between icons */
`;

export const ScheduleDisplay: React.FC<ScheduleDisplayProps> = ({
  scheduleData,
  className,
  iconSize = '24px', // Default size for schedule icons
  activeIconSize = '24px',
  activeBorderColor, // Uses ScheduleIcon's default if not provided
  inactiveOpacity,   // Uses ScheduleIcon's default if not provided
}) => {
  const { slots, currentSlotIndex } = scheduleData;

  if (!slots || slots.length === 0) {
    return null;
  }

  return (
    <ScheduleDisplayWrapper className={className}>
      {slots.map((activityType, index) => (
        <ScheduleIcon
          key={index} // Using index as key is acceptable if schedule order is stable and has no unique IDs per slot
          activityType={activityType}
          isActive={index === currentSlotIndex}
          size={index == currentSlotIndex ? activeIconSize : iconSize}
          activeBorderColor={activeBorderColor}
          inactiveOpacity={inactiveOpacity}
          // alt text for accessibility can be derived if needed, ScheduleIcon has a default
        />
      ))}
    </ScheduleDisplayWrapper>
  );
};

// ---

import React from 'react';
import styled from '@emotion/styled';
import { StatusLine, UIStatusEffectData } from './StatusLine';

interface StatusEffectsDisplayProps {
  effects: UIStatusEffectData[];
  className?: string;
  maxHeight?: string;
  iconSize?: string;
  positiveTextColor?: string;
  negativeTextColor?: string;
  buffIconFillColor?: string;
  debuffIconFillColor?: string;
  iconBackgroundColor?: string;
  iconBorderColor?: string;
  emptyStateText?: string;
  isCollapsed?: boolean;
}

const DisplayWrapper = styled.div<{ maxHeight?: string }>`
  display: flex;
  flex-direction: column;
  width: 100%;
  padding: 0 4px; /* Horizontal padding for the list */
  box-sizing: border-box;
  overflow-y: ${props => (props.maxHeight ? 'auto' : 'visible')};
  max-height: ${props => props.maxHeight || 'none'};

  /* Styling for scrollbar if needed */
  &::-webkit-scrollbar {
    width: 6px;
  }
  &::-webkit-scrollbar-thumb {
    background-color: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
  }
  &::-webkit-scrollbar-track {
    background-color: rgba(0, 0, 0, 0.1);
  }
`;

const EmptyStateMessage = styled.div`
  padding: 8px;
  font-size: 0.85rem;
  color: #888; /* Or your theme's muted text color */
  text-align: center;
  font-style: italic;
`;

export const StatusEffectsDisplay: React.FC<StatusEffectsDisplayProps> = ({
  effects,
  className,
  maxHeight,
  iconSize, // Will be passed to StatusLine, which has its own default
  positiveTextColor,
  negativeTextColor,
  buffIconFillColor,
  debuffIconFillColor,
  iconBackgroundColor,
  iconBorderColor,
  isCollapsed,
  emptyStateText = "No active effects.",
}) => {
  if (!effects || effects.length === 0) {
    return (
      <DisplayWrapper className={className} maxHeight={maxHeight}>
        <EmptyStateMessage>{emptyStateText}</EmptyStateMessage>
      </DisplayWrapper>
    );
  }

  return (
    <DisplayWrapper className={className} maxHeight={maxHeight}>
      {effects.map((effectData) => (
        <StatusLine
          key={effectData.key}
          effectData={effectData}
          iconSize={iconSize}
          positiveTextColor={positiveTextColor}
          negativeTextColor={negativeTextColor}
          buffIconFillColor={buffIconFillColor}
          debuffIconFillColor={debuffIconFillColor}
          iconBackgroundColor={iconBackgroundColor}
          iconBorderColor={iconBorderColor}
          isCollapsed={isCollapsed}
        />
      ))}
    </DisplayWrapper>
  );
};

// ---

// src/ui/status/StatusLine.tsx
import React from 'react';
import styled from '@emotion/styled';
import { BuffDebuffIcon } from '../icons/BuffDebuffIcon'; // Adjust path as needed
import { AffectedStat, BuffEffectApplicationType } from '../../../../game/logic/buffs/buffsData';


export interface UIBuffEffect {
  stat: AffectedStat;
  value: number;
  applicationType: BuffEffectApplicationType;
  effectText: string; 
}

export interface UIStatusEffectData {
  iconAssetKey: string;
  displayName: string;
  description?: string;
  effects: UIBuffEffect[];
  remainingDurationMinutes?: number;
  totalDurationMinutes?: number;
  isBuff: boolean;
  key: string; 
}

interface StatusLineProps {
  effectData: UIStatusEffectData;
  className?: string;
  iconSize?: string;
  positiveTextColor?: string;
  negativeTextColor?: string;
  buffIconFillColor?: string;
  debuffIconFillColor?: string;
  iconBackgroundColor?: string;
  iconBorderColor?: string;
  isCollapsed?: boolean;
}

const StatusLineWrapper = styled.div`
  display: flex;
  align-items: center;
  padding: 4px 0;
  gap: 8px;
  width: 100%;
`;

const EffectsText = styled.span<{ textColor: string }>`
  font-size: 0.85rem;
  color: ${props => props.textColor};
  line-height: 1.3;
  flex-grow: 1;
  white-space: normal;
`;

export const StatusLine: React.FC<StatusLineProps> = ({
  effectData,
  className,
  iconSize = '20px',
  positiveTextColor = '#2ECC71',
  negativeTextColor = '#E74C3C',
  buffIconFillColor,
  debuffIconFillColor,
  iconBackgroundColor,
  iconBorderColor,
  isCollapsed
}) => {
  const {
    iconAssetKey,
    displayName,
    effects,
    remainingDurationMinutes,
    totalDurationMinutes,
    isBuff,
  } = effectData;

  const fullEffectText = effects.map(eff => eff.effectText).join(', ');
  const textColor = isBuff ? positiveTextColor : negativeTextColor;

  return (
    <StatusLineWrapper className={className} title={displayName || effectData.description}>
      <BuffDebuffIcon
        iconAssetKey={iconAssetKey}
        altText={displayName || 'Status Effect'}
        remainingDurationMinutes={remainingDurationMinutes}
        totalDurationMinutes={totalDurationMinutes}
        isBuff={isBuff}
        size={iconSize}
        buffFillColor={buffIconFillColor}
        debuffFillColor={debuffIconFillColor}
        backgroundColor={iconBackgroundColor}
        borderColor={iconBorderColor}
      />
      {!isCollapsed ? <EffectsText textColor={textColor}>
        {displayName} : {fullEffectText || displayName}
      </EffectsText> : null}
    </StatusLineWrapper>
  );
};

// ---

// src/ui/time_controls/TimeControls.tsx
import React, { useCallback, useMemo } from "react";
import styled from '@emotion/styled';
import { useGameTime } from "../../hooks/useGameTime"; // Assuming this path is correct relative to the new file
import { TimeSpeed } from "../../../../game/logic/input/InputComponent"; // Adjust path
import { EventBus } from "../../../../game/EventBus"; // Adjust path
import { GameEvent } from "../../../../game/consts/GameEvent"; // Adjust path

const SPEEDS_CONFIG: { label: string; value: TimeSpeed; title: string }[] = [
    { label: "⏸", value: "paused", title: "Pause" },
    { label: "1x", value: "normal", title: "Normal Speed" },
    { label: "12x", value: "fast", title: "Fast Speed" },
    { label: "60x", value: "veryfast", title: "Very Fast Speed" },
];

const ControlsWrapper = styled.div`
  position: absolute;
  top: 10px;
  left: 10px;
  height: 32px;
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 0 4px;
  background-color: rgba(30, 32, 35, 0.5);
  color: #dde;
  border-radius: 6px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
  z-index: 1010;
  pointer-events: auto;
`;

const TimeButtonStyled = styled.button<{ isActive: boolean }>`
  background-color: ${props => (props.isActive ? 'rgba(70, 90, 120, 0.9)' : 'rgba(50, 52, 55, 0)')};
  color: ${props => (props.isActive ? '#FFFFFF' : '#a0a0a0')};
  border: 1px solid ${props => (props.isActive ? 'rgba(100, 120, 150, 0.9)' : '#2a2c2e')};
  font-size: 0.8rem;
  padding: 0;
  width: 24px;
  height: 24px;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.15s ease, color 0.15s ease, border-color 0.15s ease;

  &:hover:not(:disabled) {
    background-color: ${props => (props.isActive ? 'rgba(80, 100, 130, 0.9)' : 'rgba(60, 62, 65, 0.9)')};
    color: #FFFFFF;
  }
`;

const TimeDisplayStyled = styled.div`
  font-family: 'Consolas', 'Menlo', monospace;
  font-size: 0.8rem;
  font-weight: 600;
  color: #e0e0e0;
  padding: 0 0px;
  min-width: 72px;
  text-align: center;
  white-space: nowrap;
`;

export const TimeControls: React.FC = () => {
    const { speed, hour, minute, day, semester } = useGameTime();

    const timeRaw = useMemo(() => {
        return `${Math.round(minute)}|${Math.round(hour)}|${Math.round(day)}|${Math.round(semester)}`;
    }, [minute, hour, day, semester]);

    const handleClick = useCallback(
        (newSpeed: TimeSpeed) => {
            if (newSpeed !== speed) {
                EventBus.emit(GameEvent.SetTimeSpeed, newSpeed);
            }
        },
        [speed]
    );

    return (
        <ControlsWrapper>
            {SPEEDS_CONFIG.map(({ label, value, title }) => (
                <TimeButtonStyled
                    key={value}
                    isActive={speed === value}
                    onClick={() => handleClick(value)}
                    title={title}
                >
                    {label}
                </TimeButtonStyled>
            ))}
            <TimeDisplayStyled>{timeRaw}</TimeDisplayStyled>
        </ControlsWrapper>
    );
};

// ---

// CharacterPortraitDisplay.tsx
import React from 'react';
import styled from '@emotion/styled';
import { ActionIcon } from '../icons/ActionIcon'; 
import { CharacterType } from '../../../../game/logic/characters/Character';
import { CharacterAction } from '../../../../game/logic/intent/intent-to-action/actionIntentData';

const characterPortraitIconMap: Partial<Record<CharacterType, string>> = {
  [CharacterType.PROFESSOR]: 'assets/characters/booker/booker_icon.png'
};

export interface CharacterUIData {
  id: string | number; // Entity ID
  characterType: CharacterType;
  currentAction: CharacterAction;
  // actionProgress?: number; // For potential future use with a fill on the action icon itself
  // vitalityPercent?: number; // For the main portrait fill, deferred for now
  onClick?: (id: string | number) => void;
  isSelected?: boolean; // To indicate if this portrait matches a globally selected character
}

interface CharacterPortraitDisplayProps extends CharacterUIData {
  size?: string; // Overall size of the portrait display
  actionIconSize?: string; // Size of the action icon overlay
  backgroundColor?: string;
}

const PortraitWrapper = styled.div<{
  size: string;
  isSelected: boolean;
  backgroundColor: string;
}>`
  width: ${props => props.size};
  height: ${props => props.size};
  border-radius: 50%;
  position: relative;
  cursor: pointer;
  background-color: ${props=>props.backgroundColor};
  border: 2px solid ${props => (props.isSelected ? '#FFD700' : '#555')}; // Highlight if selected
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  transition: border-color 0.2s ease-in-out, transform 0.1s ease-out;

  &:hover {
    border-color: ${props => (props.isSelected ? '#FFEA00' : '#777')};
    transform: scale(1.05);
  }
`;

const PortraitImage = styled.img`
  width: 100%;
  height: 100%;
  border-radius: 50%;
  object-fit: cover;
  display: block;
`;

const ActionIconOverlay = styled.div<{ iconSize: string }>`
  position: absolute;
  bottom: -10px; /* Adjust for slight overlap or precise cornering */
  left: -10px;   /* Adjust for slight overlap or precise cornering */
  width: ${props => props.iconSize};
  height: ${props => props.iconSize};
  /* Add a small background or border to the overlay itself if needed for contrast */
  /* background-color: rgba(0,0,0,0.3); */
  /* border-radius: 50%; */
`;

export const CharacterPortraitDisplay: React.FC<CharacterPortraitDisplayProps> = ({
  id,
  characterType,
  currentAction,
  onClick,
  isSelected = false,
  size = '48px', // Default size for the portrait
  actionIconSize, // Default size for the action icon relative to portrait size
  backgroundColor = "white"
}) => {
  const portraitSrc = characterPortraitIconMap[characterType] || 'assets/icons/unknown_character.png'; // Fallback
  const finalActionIconSize = actionIconSize || `calc(${size} * 0.55)`; // Action icon is ~55% of portrait size

  const handleClick = () => {
    if (onClick) {
      onClick(id);
    }
  };

  return (
    <PortraitWrapper
      backgroundColor={backgroundColor}
      size={size}
      isSelected={isSelected}
      onClick={handleClick}
      title={`${characterType}`}
    >
      <PortraitImage src={portraitSrc} alt={`${characterType}`} />
        {
        currentAction ? <ActionIconOverlay iconSize={finalActionIconSize}>
          <ActionIcon
            actionType={currentAction}
            size="100%"
            backgroundColor='#000000'
          />
        </ActionIconOverlay> : null
        }
    </PortraitWrapper>
  );
};

// ---

// TopCharacterBar.tsx
import React, { useState, useEffect, useCallback } from 'react';
import styled from '@emotion/styled';
import { EventBus } from '../../../../game/EventBus';
import { GameEvent } from '../../../../game/consts/GameEvent';
import { CharacterAction } from '../../../../game/logic/intent/intent-to-action/actionIntentData';
import { CharacterType } from '../../../../game/logic/characters/Character';
import { CharacterPortraitDisplay } from './CharacterPortraitDisplay';
import { GameUIEvent } from '../../../../game/consts/UIEvent';

interface CharacterUpdateEventPayload {
  id: string | number;
  character: {
    type: CharacterType;
  };
  currentAction: CharacterAction;
}

interface InternalCharacterUIData {
  id: string | number;
  characterType: CharacterType;
  currentAction: CharacterAction;
}


interface TopCharacterBarProps {
  className?: string;
}

const BarWrapper = styled.div`
  position: absolute;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  flex-direction: row;
  gap: 8px;
  padding: 4px;
  border-radius: 8px;
  z-index: 1000;
  pointer-events: all;
`;

export const TopCharacterBar: React.FC<TopCharacterBarProps> = ({
  className,
}) => {
  const [portraitsState, setPortraitsState] = useState<Record<string | number, InternalCharacterUIData>>({});
  const [globallySelectedCharacterId, setGloballySelectedCharacterId] = useState<string | number | null>(null);

  const handleCharacterUpdate = useCallback((data: CharacterUpdateEventPayload) => {
    setPortraitsState(prev => ({
      ...prev,
      [data.id]: {
        id: data.id,
        characterType: data.character.type,
        currentAction: data.currentAction,
      },
    }));
  }, []);

  useEffect(() => {
    const handleSelectionChange = (entityId: string | number | null) => {
      setGloballySelectedCharacterId(entityId === -1 ? null : entityId);
    };

    EventBus.on(GameEvent.CharacterUpdate, handleCharacterUpdate);
    EventBus.on(GameEvent.SelectionChanged, handleSelectionChange);

    return () => {
      EventBus.off(GameEvent.CharacterUpdate, handleCharacterUpdate);
      EventBus.off(GameEvent.SelectionChanged, handleSelectionChange);
    };
  }, [handleCharacterUpdate]);

  const handlePortraitClick = (characterId: string | number) => {
    EventBus.emit(GameUIEvent.PortraitClicked, characterId);
  };

  // Convert the record to an array for rendering
  const charactersToDisplay = Object.values(portraitsState);

  if (charactersToDisplay.length === 0) {
    return <></>;
  }

  return (
    <BarWrapper className={className}>
      {charactersToDisplay.map((charData) => (
        <CharacterPortraitDisplay
          key={charData.id}
          id={charData.id}
          characterType={charData.characterType}
          currentAction={charData.currentAction}
          onClick={() => handlePortraitClick(charData.id)}
          isSelected={globallySelectedCharacterId === charData.id}
        />
      ))}
    </BarWrapper>
  );
};


// ---

import { useEffect, useState } from "react";
import {TimeSpeed} from "../../../game/logic/input/InputComponent.ts";
import {EventBus} from "../../../game/EventBus.ts";
import {GameEvent} from "../../../game/consts/GameEvent.ts";
import {TimeConfig} from "../../../game/config/TimeConfig.ts";

export interface GameTime {
    minute: number;
    hour: number;
    day: number;
    semester: number;
    speed: TimeSpeed;
}

export function useGameTime(): GameTime {
    const [time, setTime] = useState<GameTime>({
        minute: 0,
        hour: 0,
        day: 0,
        semester: 0,
        speed: "normal" as TimeSpeed,
    });

    useEffect(() => {
        EventBus.on(GameEvent.SetTimeSpeed, (speed: TimeSpeed) =>
            setTime(prev => ({ ...prev, speed }))
        );
        
        EventBus.on(GameEvent.SetTime, (time: number) =>
            setTime(prev => ({ ...prev, ...divideTime(time) }))
        );
    }, []);

    return time;
}


export function divideTime(totalMinutes: number): Partial<GameTime> {
    const minutesPerHour = TimeConfig.MinutesPerHour;
    const hoursPerDay = TimeConfig.HoursPerDay;
    const daysPerSemester = TimeConfig.DaysPerSemester;

    let minutes = totalMinutes;

    const semester = Math.floor(minutes / (daysPerSemester * hoursPerDay * minutesPerHour));
    minutes %= daysPerSemester * hoursPerDay * minutesPerHour;

    const day = Math.floor(minutes / (hoursPerDay * minutesPerHour));
    minutes %= hoursPerDay * minutesPerHour;

    const hour = Math.floor(minutes / minutesPerHour);
    minutes %= minutesPerHour;

    return {
        semester,
        day,
        hour,
        minute: minutes
    };
}


// ---

import { useEffect, useState } from "react";
import { EventBus } from "../../../game/EventBus";
import { GameEvent } from "../../../game/consts/GameEvent";
import { ToolType } from "../../../game/display/game/tools/GameTools";

export function useSelectedTool(): ToolType | null {
    const [selectedTool, setSelectedTool] = useState<ToolType | null>(null);

    useEffect(() => {
        const handle = (tool: ToolType) => {
            setSelectedTool(tool)
        };

        EventBus.on(GameEvent.ToolSelected, handle);
        return () => {
            EventBus.off(GameEvent.ToolSelected, handle);
        };
    }, []);

    return selectedTool;
}


// ---

// src/ui/hooks/useToolCursor.ts
import { useEffect } from 'react';
import { ToolType } from '../../../game/display/game/tools/GameTools'; 
import { useSelectedTool } from './useSelectedTool';

const PHASER_GAME_CONTAINER_ID = 'game-container';

export function useToolCursor(gameContainerId: string = PHASER_GAME_CONTAINER_ID): void {
  const selectedTool = useSelectedTool();

  useEffect(() => {
    const gameContainer = document.getElementById(gameContainerId);
    if (!gameContainer) {
      console.warn(`useToolCursor: Game container with ID "${gameContainerId}" not found.`);
      return;
    }

    const classesToRemove = ['game-cursor-default', 'game-cursor-tree-cutting'];
    // Add other cursor classes here if they exist

    gameContainer.classList.remove(...classesToRemove);

    switch (selectedTool) {
      case ToolType.TreeCutting:
        gameContainer.classList.add('game-cursor-tree-cutting');
        break;
      case ToolType.Selection:
      case ToolType.None:
      default:
        gameContainer.classList.add('game-cursor-default');
        break;
    }

    return () => {
      if (gameContainer) {
        gameContainer.classList.remove(...classesToRemove);
      }
    };
  }, [selectedTool, gameContainerId]);
}

// ---

export function lerpColor(c1: number, c2: number, t: number): number {
    const r1 = (c1 >> 16) & 0xff;
    const g1 = (c1 >> 8) & 0xff;
    const b1 = c1 & 0xff;

    const r2 = (c2 >> 16) & 0xff;
    const g2 = (c2 >> 8) & 0xff;
    const b2 = c2 & 0xff;

    const r = Math.round(r1 + (r2 - r1) * t);
    const g = Math.round(g1 + (g2 - g1) * t);
    const b = Math.round(b1 + (b2 - b1) * t);

    return (r << 16) | (g << 8) | b;
}

// ---

export interface Pos {x:number; y:number}

export class MathUtils {
    static weightedRand(weightedValues: { [key: number]: number }): number {
        // Calculate the total weight
        let totalWeight = 0;
        for (let key in weightedValues) {
            totalWeight += weightedValues[key];
        }

        // Generate a random number in the range [0, totalWeight)
        let random = Math.random() * totalWeight;

        // Determine which key corresponds to the random number
        for (let key in weightedValues) {
            random -= weightedValues[key];
            if (random <= 0) {
                return parseInt(key);
            }
        }

        // Fallback, should theoretically never be reached
        return -1;
    }

    /**
     * Selects a random key from an object based on the numerical weights assigned to each key.
     *
     * @param weightedValues - An object where keys are the items to choose from (string)
     * and values are their corresponding weights (number).
     * @returns A randomly selected key (string) based on the provided weights.
     * Returns an empty string if the input object is empty or total weight is zero.
     */
    public static weightedRandString(weightedValues: { [key: string]: number }): string {
        let totalWeight = 0;

        // Calculate the sum of all weights
        for (const key in weightedValues) {
            // Ensure the property belongs to the object itself, not its prototype
            if (Object.prototype.hasOwnProperty.call(weightedValues, key)) {
                // Ensure weight is a positive number
                const weight = Math.max(0, weightedValues[key]);
                weightedValues[key] = weight; // Store the sanitized weight back
                totalWeight += weight;
            }
        }

        // Handle edge case: no items or zero total weight
        if (totalWeight <= 0) {
            console.warn("weightedRand called with empty or zero-weight items.");
            // Attempt to return the first key if any exist, otherwise empty string
            const keys = Object.keys(weightedValues);
            return keys.length > 0 ? keys[0] : '';
        }

        // Generate a random number between 0 (inclusive) and totalWeight (exclusive)
        let random = Math.random() * totalWeight;

        // Iterate through the items again to find the chosen one
        for (const key in weightedValues) {
            if (Object.prototype.hasOwnProperty.call(weightedValues, key)) {
                // If the random number falls within the current item's weight range
                if (random < weightedValues[key]) {
                    return key; // Return the key of the selected item
                }
                // Subtract the current item's weight from the random number
                random -= weightedValues[key];
            }
        }

        // Fallback: Should theoretically not be reached if totalWeight > 0
        // Return the last key as a safeguard
        const keys = Object.keys(weightedValues);
        console.warn("weightedRand fallback triggered.");
        return keys.length > 0 ? keys[keys.length - 1] : '';
    }
    
    static weightedRandIndex(weights:number[]): number {
        // Calculate the total weight
        let totalWeight = 0;
        for (let i = 0; i < weights.length; i++) {
            totalWeight += weights[i];
        }

        // Generate a random number in the range [0, totalWeight)
        let random = Math.random() * totalWeight;

        // Determine which key corresponds to the random number
        for (let i = 0; i < weights.length; i++) {
            random -= weights[i];
            if (random <= 0) {
                return i;
            }
        }

        // Fallback, should theoretically never be reached
        return -1;
    }

    static remapNoiseToUnit(value: number): number {
        return (value + 1) / 2;
    }

    static distance(pos1: Pos, pos2: Pos): number {
        // Simple Euclidean distance calculation
        return Math.sqrt(Math.pow(pos2.x - pos1.x, 2) + Math.pow(pos2.y - pos1.y, 2));
    }

    static normalize(pos: Pos): Pos {
        const length = Math.sqrt(pos.x * pos.x + pos.y * pos.y);
        if (length == 0) return { x: 0, y: 0 };
        return { x: pos.x / length, y: pos.y / length };
    }

    static multiply(pos: Pos, scalar: number): Pos {
        return { x: pos.x * scalar, y: pos.y * scalar };
    }

    static add(pos1: Pos, pos2: Pos): Pos {
        return { x: pos1.x + pos2.x, y: pos1.y + pos2.y };
    }

    static subtract(pos1: Pos, pos2: Pos): Pos {
        return { x: pos1.x - pos2.x, y: pos1.y - pos2.y };
    }

    static randomPointOnCircumference(position: Pos, radius: number): Pos {
        const angle = Math.random() * 2 * Math.PI;
        const x = position.x + radius * Math.cos(angle);
        const y = position.y + radius * Math.sin(angle);
        return { x, y };
    }

    static closestValue(position: Pos, values: Set<number>, positions: Map<number, Pos>): number | undefined {
        let closest = Number.MAX_VALUE;
        let target = undefined;

        values.forEach(value => {
            const pos = positions.get(value);
            if (!pos) {
                return;
            }
            const distance = MathUtils.distance(position, pos);
            if (distance < closest) {
                closest = distance;
                target = value;
            }
        });

        return target;
    }
}

// ---

export class SimplexNoise {
    private grad3 = [
        [1,1], [-1,1], [1,-1], [-1,-1],
        [1,0], [-1,0], [0,1], [0,-1],
    ];
    private grad3D = [
        [1,1,0], [-1,1,0], [1,-1,0], [-1,-1,0],
        [1,0,1], [-1,0,1], [1,0,-1], [-1,0,-1],
        [0,1,1], [0,-1,1], [0,1,-1], [0,-1,-1]
    ];

    private p: number[] = [];
    private perm: number[] = [];
    private dot3(g: number[], x: number, y: number, z: number): number {
        return g[0] * x + g[1] * y + g[2] * z;
    }

    constructor(seed: number = 0) {
        this.buildPermutationTable(seed);
    }

    private buildPermutationTable(seed: number) {
        this.p = new Array(256);
        for (let i = 0; i < 256; i++) {
            this.p[i] = i;
        }

        let random = this.xorshift(seed);
        for (let i = 255; i > 0; i--) {
            const n = Math.floor((random() * (i + 1)));
            [this.p[i], this.p[n]] = [this.p[n], this.p[i]];
        }

        this.perm = new Array(512);
        for (let i = 0; i < 512; i++) {
            this.perm[i] = this.p[i & 255];
        }
    }

    private xorshift(seed: number): () => number {
        let x = seed || 123456789;
        return function () {
            x ^= x << 13;
            x ^= x >> 17;
            x ^= x << 5;
            return (x >>> 0) / 0xFFFFFFFF;
        };
    }

    private dot(g: number[], x: number, y: number): number {
        return g[0] * x + g[1] * y;
    }

    public noise(xin: number, yin: number): number {
        const F2 = 0.5 * (Math.sqrt(3) - 1);
        const G2 = (3 - Math.sqrt(3)) / 6;

        let n0 = 0, n1 = 0, n2 = 0;

        const s = (xin + yin) * F2;
        const i = Math.floor(xin + s);
        const j = Math.floor(yin + s);

        const t = (i + j) * G2;
        const X0 = i - t;
        const Y0 = j - t;
        const x0 = xin - X0;
        const y0 = yin - Y0;

        let i1, j1;
        if (x0 > y0) {
            i1 = 1; j1 = 0;
        } else {
            i1 = 0; j1 = 1;
        }

        const x1 = x0 - i1 + G2;
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1 + 2 * G2;
        const y2 = y0 - 1 + 2 * G2;

        const ii = i & 255;
        const jj = j & 255;
        const gi0 = this.perm[ii + this.perm[jj]] % 8;
        const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 8;
        const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 8;

        let t0 = 0.5 - x0*x0 - y0*y0;
        if (t0 >= 0) {
            t0 *= t0;
            n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
        }

        let t1 = 0.5 - x1*x1 - y1*y1;
        if (t1 >= 0) {
            t1 *= t1;
            n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
        }

        let t2 = 0.5 - x2*x2 - y2*y2;
        if (t2 >= 0) {
            t2 *= t2;
            n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
        }

        return 70.0 * (n0 + n1 + n2); // Output range: [-1, 1]
    }

    public noise3D(xin: number, yin: number, zin: number): number {
        const F3 = 1 / 3;
        const G3 = 1 / 6;

        let n0 = 0, n1 = 0, n2 = 0, n3 = 0;

        const s = (xin + yin + zin) * F3;
        const i = Math.floor(xin + s);
        const j = Math.floor(yin + s);
        const k = Math.floor(zin + s);

        const t = (i + j + k) * G3;
        const X0 = i - t;
        const Y0 = j - t;
        const Z0 = k - t;

        const x0 = xin - X0;
        const y0 = yin - Y0;
        const z0 = zin - Z0;

        let i1 = 0, j1 = 0, k1 = 0;
        let i2 = 0, j2 = 0, k2 = 0;

        if (x0 >= y0) {
            if (y0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
            else if (x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
            else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
        } else {
            if (y0 < z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
            else if (x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
            else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
        }

        const x1 = x0 - i1 + G3;
        const y1 = y0 - j1 + G3;
        const z1 = z0 - k1 + G3;
        const x2 = x0 - i2 + 2 * G3;
        const y2 = y0 - j2 + 2 * G3;
        const z2 = z0 - k2 + 2 * G3;
        const x3 = x0 - 1 + 3 * G3;
        const y3 = y0 - 1 + 3 * G3;
        const z3 = z0 - 1 + 3 * G3;

        const ii = i & 255;
        const jj = j & 255;
        const kk = k & 255;

        const gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
        const gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
        const gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;
        const gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;

        let t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
        if (t0 < 0) n0 = 0;
        else {
            t0 *= t0;
            n0 = t0 * t0 * this.dot3(this.grad3D[gi0], x0, y0, z0);
        }

        let t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
        if (t1 < 0) n1 = 0;
        else {
            t1 *= t1;
            n1 = t1 * t1 * this.dot3(this.grad3D[gi1], x1, y1, z1);
        }

        let t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
        if (t2 < 0) n2 = 0;
        else {
            t2 *= t2;
            n2 = t2 * t2 * this.dot3(this.grad3D[gi2], x2, y2, z2);
        }

        let t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
        if (t3 < 0) n3 = 0;
        else {
            t3 *= t3;
            n3 = t3 * t3 * this.dot3(this.grad3D[gi3], x3, y3, z3);
        }

        return 32.0 * (n0 + n1 + n2 + n3); // Output range: ~[-1, 1]
    }

}


// ---

/// <reference types="vite/client" />
