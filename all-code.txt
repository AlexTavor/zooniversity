import React, { useRef } from 'react';
import { IRefPhaserGame, PhaserGame } from './game/PhaserGame';
import {UISwitcher} from "./ui/ui_switcher/UISwitcher.tsx"; 

export function App() {
    const phaserRef = useRef<IRefPhaserGame | null>(null);

    return (
        <div id="app">
            <div id="game-wrapper">
                <PhaserGame ref={phaserRef} />
                <UISwitcher/>
            </div>
        </div>
    );
}


// ---

/**
 * An entity is just an ID. This is used to look up its associated
 * Components.
 */
export type Entity = number

/**
 * A Component is a bundle of state. Each instance of a Component is
 * associated with a single Entity.
 *
 * Components have no API to fulfill.
 */
export abstract class Component { }

/**
 * A System cares about a set of Components. It will run on every Entity
 * that has that set of Components.
 *
 * A System must specify two things:
 *
 *  (1) The immutable set of Components it needs at compile time. (Its
 *      immutability isn't enforced by anything but my wrath.) We use the
 *      type `Function` to refer to a Component's class; i.e., `Position`
 *      (class) rather than `new Position()` (instance).
 *
 *  (2) An update() method for what to do every frame (if anything).
 */
export abstract class System {

    /**
     * Set of Component classes, ALL of which are required before the
     * system is run on an entity.
     *
     * This should be defined at compile time and should never change.
     */
    public abstract componentsRequired: Set<Function>

    /**
     * update() is called on the System every frame.
     */
    public abstract update(entities: Set<Entity>, delta: number): void

    /**
     * The ECS is given to all Systems. Systems contain most of the game
     * code, so they need to be able to create, mutate, and destroy
     * Entities and Components.
     */
    public ecs: ECS
}

/**
 * This type is so functions like the ComponentContainer's get(...) will
 * automatically tell TypeScript the type of the Component returned. In
 * other words, we can say get(Position) and TypeScript will know that an
 * instance of Position was returned. This is amazingly helpful.
 */
type ComponentClass<T extends Component> = new (...args: any[]) => T

/**
 * This custom container is so that calling code can provide the
 * Component *instance* when adding (e.g., add(new Position(...))), and
 * provide the Component *class* otherwise (e.g., get(Position),
 * has(Position), delete(Position)).
 *
 * We also use two different types to refer to the Component's class:
 * `Function` and `ComponentClass<T>`. We use `Function` in most cases
 * because it is simpler to write. We use `ComponentClass<T>` in the
 * `get()` method, when we want TypeScript to know the type of the
 * instance that is returned. Just think of these both as referring to
 * the same thing: the underlying class of the Component.
 *
 * You might notice a footgun here: code that gets this object can
 * directly modify the Components inside (with add(...) and delete(...)).
 * This would screw up our ECS bookkeeping of mapping Systems to
 * Entities! We'll fix this later by only returning callers a view onto
 * the Components that can't change them.
 */
class ComponentContainer {
    private map = new Map<Function, Component>()

    public add(component: Component): void {
        this.map.set(component.constructor, component);
    }

    public get<T extends Component>(
        componentClass: ComponentClass<T>
    ): T {
        return this.map.get(componentClass) as T;
    }

    public has(componentClass: Function): boolean {
        return this.map.has(componentClass);
    }

    public hasAll(componentClasses: Iterable<Function>): boolean {
        for (let cls of componentClasses) {
            if (!this.map.has(cls)) {
                return false;
            }
        }
        return true;
    }

    public delete(componentClass: Function): void {
        this.map.delete(componentClass);
    }
}

/**
 * The ECS is the main driver; it's the backbone of the engine that
 * coordinates Entities, Components, and Systems. You could have a single
 * one for your game, or make a different one for every level, or have
 * multiple for different purposes.
 */
export class ECS {
    // Main state
    private entities = new Map<Entity, ComponentContainer>();
    private components = new Map<Function, Entity[]>(); // Key must be a Component class
    private systems = new Map<System, Set<Entity>>();

    // Bookkeeping for entities.
    private nextEntityID = 1
    private entitiesToDestroy = new Array<Entity>()

    // API: Entities

    public addEntity(): Entity {
        let entity = this.nextEntityID;
        this.nextEntityID++;
        this.entities.set(entity, new ComponentContainer());
        return entity;
    }

    /**
     * Marks `entity` for removal. The actual removal happens at the end
     * of the next `update()`. This way we avoid subtle bugs where an
     * Entity is removed mid-`update()`, with some Systems seeing it and
     * others not.
     */
    public removeEntity(entity: Entity): void {
        this.entitiesToDestroy.push(entity);
    }

    // API: Components

    public addComponent(entity: Entity, component: Component): void {
        this.components.has(component.constructor) ?
            this.components.get(component.constructor)!.push(entity) :
            this.components.set(component.constructor, [entity]);
        this.entities.get(entity)!.add(component);
        this.checkE(entity);
    }

    public getEntitiesWithComponent(componentClass: Function): Entity[] {
        return this.components.get(componentClass) ?? [];
    }

    public getEntitiesWithComponents(componentClasses: Function[]): Entity[] {
        const entities = this.getEntitiesWithComponent(componentClasses[0]);
        return entities.filter(entity => componentClasses.every(componentClass => this.entities.get(entity)!.has(componentClass)));
    }

    public getComponents(entity: Entity): ComponentContainer {
        return this.entities.get(entity)!;
    }

    public getComponent<T extends Component>(entity: Entity, componentClass: ComponentClass<T>): T {
        return this.entities.get(entity)?.get(componentClass)!;
    }

    public removeComponent(
        entity: Entity, componentClass: Function
    ): void {
        this.entities.get(entity)?.delete(componentClass);
        this.components.get(componentClass)?.splice(
            this.components.get(componentClass)!.indexOf(entity), 1
        );

        this.checkE(entity);
    }

    // API: Systems

    public addSystem(system: System): void {
        // Checking invariant: systems should not have an empty
        // Components list, or they'll run on every entity. Simply remove
        // or special case this check if you do want a System that runs
        // on everything.
        if (system.componentsRequired.size == 0) {
            console.warn("System not added: empty Components list.");
            console.warn(system);
            return;
        }

        // Give system a reference to the ECS so it can actually do
        // anything.
        system.ecs = this;

        // Save system and set who it should track immediately.
        this.systems.set(system, new Set());
        for (let entity of this.entities.keys()) {
            this.checkES(entity, system);
        }
    }

    /**
     * Note: I never actually had a removeSystem() method for the entire
     * time I was programming the game Fallgate (2 years!). I just added
     * one here for a specific testing reason (see the next post).
     * Because it's just for demo purposes, this requires an actual
     * instance of a System to remove (which would be clunky as a real
     * API).
     */
    public removeSystem(system: System): void {
        this.systems.delete(system);
    }

    /**
     * This is ordinarily called once per tick (e.g., every frame). It
     * updates all Systems, then destroys any Entities that were marked
     * for removal.
     */
    public update(delta:number): void {
        // Update all systems. (Later, we'll add a way to specify the
        // update order.)
        for (let [system, entities] of this.systems.entries()) {
            system.update(entities, delta)
        }

        // Remove any entities that were marked for deletion during the
        // update.
        while (this.entitiesToDestroy.length > 0) {
            this.destroyEntity(this.entitiesToDestroy.pop()!);
        }
    }

    // Private methods for doing internal state checks and mutations.

    private destroyEntity(entity: Entity): void {
        for (let componentClass of this.components.keys()) {
            if (this.entities.get(entity)?.has(componentClass)) {
                this.removeComponent(entity, componentClass);
            }
        }

        this.entities.delete(entity);
        for (let entities of this.systems.values()) {
            entities.delete(entity);  // no-op if doesn't have it
        }

    }

    private checkE(entity: Entity): void {
        for (let system of this.systems.keys()) {
            this.checkES(entity, system);
        }
    }

    private checkES(entity: Entity, system: System): void {
        let have = this.entities.get(entity);
        let need = system.componentsRequired;
        if (have!.hasAll(need)) {
            // should be in system
            this.systems.get(system)!.add(entity); // no-op if in
        } else {
            // should not be in system
            this.systems.get(system)!.delete(entity); // no-op if out
        }
    }

    hasEntity(enemy: number) {
        return this.entities.has(enemy);
    }

    hasComponent(entity: Entity, componentClass: Function) {
        return this.entities.get(entity)?.has(componentClass) ?? false;
    }
}

// ---

import { Events } from 'phaser';

// Used to emit events between React components and Phaser scenes
// https://newdocs.phaser.io/docs/3.70.0/Phaser.Events.EventEmitter
export const EventBus = new Events.EventEmitter();

// ---

import React, { forwardRef, useEffect, useLayoutEffect, useRef } from 'react';
import StartGame from './main';
import { EventBus } from './EventBus';

export interface IRefPhaserGame
{
    game: Phaser.Game | null;
    scene: Phaser.Scene | null;
}

interface IProps
{
    currentActiveScene?: (scene_instance: Phaser.Scene) => void
}

export const PhaserGame = forwardRef<IRefPhaserGame, IProps>(function PhaserGame({ currentActiveScene }, ref)
{
    const game = useRef<Phaser.Game | null>(null!);

    useLayoutEffect(() =>
    {
        if (game.current === null)
        {
            game.current = StartGame("game-container");

            if (typeof ref === 'function')
            {
                ref({ game: game.current, scene: null });
            } else if (ref)
            {
                ref.current = { game: game.current, scene: null };
            }

        }

        return () =>
        {
            if (game.current)
            {
                try {
                    game.current.plugins.destroy();
                } finally {
                    game.current.canvas.remove();
                    game.current.destroy(true);
                    game.current = null;
                }
            }
        }
    }, [ref]);

    useEffect(() =>
    {
        EventBus.on('current-scene-ready', (scene_instance: Phaser.Scene) =>
        {
            if (currentActiveScene && typeof currentActiveScene === 'function')
            {
                currentActiveScene(scene_instance);
            }

            if (typeof ref === 'function')
            {
                ref({ game: game.current, scene: scene_instance });
            } else if (ref)
            {
                ref.current = { game: game.current, scene: scene_instance };
            }

        });
        return () =>
        {
            EventBus.removeListener('current-scene-ready');
        }
    }, [currentActiveScene, ref]);

    return <div id='game-container'/>;
});

// ---

import { Entity } from "../ECS";

export enum SlotType {
    WORK = "work",
    SLEEP = "sleep"
}

export enum SlotLayout {
  RADIAL = "radial",
  GRID = "grid"
}

export interface Slot {
  x: number;
  y: number;
  occupiedBy: Entity | null;
}

interface BaseSlotDefinition {
  layout: SlotLayout;
  count: number;
}

interface RadialSlotDefinition extends BaseSlotDefinition {
  layout: SlotLayout.RADIAL;
  radius: number; // Distance from center for RADIAL layout
}

interface GridSlotDefinition extends BaseSlotDefinition {
  layout: SlotLayout.GRID;
  spacing: number; // Distance between slot centers for GRID layout
}

export type SlotDefinition = RadialSlotDefinition | GridSlotDefinition;

export class InteractionSlots {
  private slots: Map<SlotType, Slot[]> = new Map();

  constructor(definitions: Partial<Record<SlotType, SlotDefinition>>) {
    for (const [type, def] of Object.entries(definitions) as [SlotType, SlotDefinition][]) {
      if (def) { // Ensure def is not undefined if Record value can be optional
        this.slots.set(type, createSlots(def));
      }
    }
  }

  public reserve(entity: Entity, slotType: SlotType = SlotType.WORK): { x: number; y: number } | null {
    const group = this.slots.get(slotType);
    if (!group) return null;

    for (const slot of group) {
      if (slot.occupiedBy === null) {
        slot.occupiedBy = entity;
        return { x: slot.x, y: slot.y };
      }
    }
    return null;
  }

  public releaseAll(entity: Entity): void {
    for (const group of this.slots.values()) {
      for (const slot of group) {
        if (slot.occupiedBy === entity) {
          slot.occupiedBy = null;
        }
      }
    }
  }

  public release(entity: Entity, slotType: SlotType): void {
    const group = this.slots.get(slotType);
    if (!group) return;

    for (const slot of group) {
      if (slot.occupiedBy === entity) {
        slot.occupiedBy = null;
      }
    }
  }

  public getSlotsArray(type: SlotType): ReadonlyArray<Slot> {
    return this.slots.get(type) || [];
  }
}

function createSlots(definition: SlotDefinition): Slot[] {
  const slots: Slot[] = [];
  const { count } = definition;

  if (definition.layout === SlotLayout.RADIAL) {
    // radius is guaranteed to exist due to the RadialSlotDefinition type
    const { radius } = definition;
    if (count <= 0) return slots; // No slots to create

    for (let i = 0; i < count; i++) {
      const angle = (i / count) * Math.PI * 2;
      slots.push({
        x: Math.round(Math.cos(angle) * radius),
        y: Math.round(Math.sin(angle) * radius),
        occupiedBy: null
      });
    }
  } else if (definition.layout === SlotLayout.GRID) {
    // spacing is guaranteed to exist due to the GridSlotDefinition type
    const { spacing } = definition;
    if (count <= 0) return slots; // No slots to create

    const gridSize = Math.ceil(Math.sqrt(count));
    // This offset centers the grid around the local (0,0) point
    const offsetAmount = (gridSize - 1) / 2;

    for (let i = 0; i < count; i++) {
      const row = Math.floor(i / gridSize);
      const col = i % gridSize;

      slots.push({
        x: Math.round((col - offsetAmount) * spacing),
        y: Math.round((row - offsetAmount) * spacing),
        occupiedBy: null
      });
    }
  }
  return slots;
}

// ---

import {Component} from "../ECS.ts";

export class Transform extends Component {
    locationState: LocationState = LocationState.OUTSIDE;
    direction: number = 0; // -1 for right, 1 for left
    constructor(
        public x: number,
        public y: number
    ) {
        super();
    }
}

export enum LocationState {
    AWAY,
    OUTSIDE,
    INSIDE
}


// ---

export class AnimImportsConfig {
    public readonly FrameWidth = 256;
    public readonly FrameHeight = 256;
    public readonly StaticWidth = 1536;
    public readonly StaticHeight = 1024;
    public readonly NumberOfTrees = 6;
    public readonly NumberOfBushes = 2;
    public readonly NumberOfFrames = 4;
}

// ---

export class CameraConfig {
    public readonly MaxTimeBetweenClicksMs: number = 200;
    public readonly MaxZoom: number = 8;
    public readonly MinZoom: number = 0.14;
    public readonly DefaultZoom: number = 1;
    public readonly DragDamping: number = 0.95;
    public readonly InertiaThreshold: number = 0.05;
    public readonly ZoomDurationMs: number = 300;
    public readonly PanDurationMs: number = 300;
    public readonly WheelZoomFactorIncrement: number = 1.5;
    public readonly WheelZoomFactorDecrement: number = 0.5;
    public readonly BackgroundColor: number = 0x0000ff;
    public readonly PanEasing: string = 'Linear';
}

// ---

import {AnimImportsConfig} from "./AnimImportsConfig.ts";
import {MapConfig} from "./MapConfig.ts";
import {Display} from "./Display.ts";
import {CameraConfig} from "./CameraConfig.ts";

export class Config {
    public static readonly Display:Display = new Display();
    public static readonly Map:MapConfig = new MapConfig();
    public static readonly AnimImports:AnimImportsConfig = new AnimImportsConfig();
    public static readonly Camera = new CameraConfig();
    public static readonly GameWidth = Config.Display.Width*(Config.Camera.MaxZoom-1);
    public static readonly GameHeight = Config.Display.Height*(Config.Camera.MaxZoom-1);
    public static readonly EntryScene = "Game"; // "GameEditorTools"
}

// ---

export class Display {
    public readonly Width = 1280;
    public readonly Height = 720;
    public readonly PixelsPerUnit = 256;
}

// ---

export class MapConfig {
    public readonly WidthInTiles = 128;
    public readonly HeightInTiles = 72;
}


// ---

export class TimeConfig {
    static HoursPerDay = 8;
    static DaysPerSemester = 30;
    static MinutesPerHour = 60;

    // In real-world seconds, 1 hour of in-game time takes 1 minute IRL
    static RealSecondsPerHour = 60;

    static SpeedMultipliers = {
        paused: 0,
        normal: 1,
        fast: 12,
        veryfast: 60,
    } as const;
}


// ---

export namespace WeatherConfig {
    
    const timeMultiplier = 10000;
    const freq = 0.0005 / timeMultiplier; 
    
    // Wind behavior
    export const Wind = {
        StrengthFrequency: freq,   // How fast wind strength changes (lower = slower)
        DirectionFrequency: 0.00000005,   // How often direction noise updates
        DirectionThreshold: 0,        // Threshold for flipping direction (uses noise > 0)
        Bias: 0.3,                  // 0 = favor calm, 1 = favor wind, 0.5 = uniform,
        MinSpeed: 100,                 // Minimum wind speed
        MaxSpeed: 1000,               // Maximum wind speed
    };

    // Cloud cover behavior
    export const CloudCover = {
        Frequency: freq,           // How fast cloud cover changes
        NoiseOffset: 5000,            // Offset for sampling different noise axis
        MinAlpha: 0,                // Minimum cloud alpha (when cover is low)
        MaxAlpha: 1.0,                // Maximum cloud alpha (full cover)
        Bias: 0  //  0 = usually clear, 1 = usually cloudy    
    };
}


// ---

export class DnDEvent {
    public static readonly DragControlStart = 'drag-control-start';
    public static readonly DragControlEnd = 'drag-control-end';
    
    public static readonly DragStart = 'drag:start';
    public static readonly DragDrop = 'drag:drop';
    public static readonly DragCancel = 'drag:cancel';
    public static readonly DragDrag = 'drag:drag';
}

// ---

export class EditorEvent {
    public static readonly MapUpdated: string = 'map-updated';
    public static readonly MapLoaded: string = 'map-loaded';
    public static readonly PaletteTypeSelected: string = 'palette-type-selected';
}

export enum PaletteType {
    none = 'none',
    trees = 'trees',
    caves = 'caves',
}

// ---

export enum GameEvent {
    NewGame = "new-game",
    LoadGame = "load-game",
    GameLoaded = "game-loaded",
    SetTimeSpeed = "set-time-speed",
    SetTime = "set-time",
    SetWeather = "set-weather",
    SelectionChanged = "selection-changed",
    StoryEventEnded = "StoryEventEnded",
    StoryEventOptionChosen = "StoryEventOptionChosen",
    StoryEventStarted = "StoryEventStarted",
    StoryEventPageChanged = "StoryEventPageChanged",
    ViewsInitialized = "ViewsInitialized",
    ResourcesUpdated = "ResourcesUpdated",
    InitGame = "init-game",
    CharacterUpdate = "character-update",
    ViewSelected = "ViewSelected",
    TreeSelectedForCutting = "TreeSelectedForCutting",
    ToolSelected = "ToolSelected",
}


// ---

export class Naming {
    public static readonly VIEW: string = 'view-';
    public static readonly SPRITE: string = 'sprite-';
    public static readonly SEPARATOR: string = '-';
}

// ---

export class PointerEvent {
    public static readonly PointerDown: string = 'pointerdown';
    public static readonly PointerUp: string = 'pointerup';
    public static readonly PointerMove: string = 'pointermove';
    public static readonly Wheel: string = 'wheel';
    public static readonly DoubleClick: string = 'dblclick';
}

// ---

export const UIConfig = {
    PanelTransitionMs: 100,
};

// ---

export enum UIEvent {
    ShowPanelCalled = "show-panel",
    PortraitClicked = "portrait-clicked",
    FindViewRequested = "find-view-requested",
}


// ---

import { DisplayModule } from "./setup/DisplayModule.ts";
import {ECS, Entity} from "../ECS.ts";
import { Layers } from "./setup/Layers.ts";
import {Config} from "../config/Config.ts";
import {createView} from "./setup/ViewStore.ts";
import {View} from "./setup/View.ts";
import { EffectType } from "./setup/ViewEffectController.ts";

export interface GameDisplayContext {
    scene: Phaser.Scene;
    layers: Layers;
    ecs: ECS;
    viewsByEntity: Map<Entity, View>;
    iconsByEntity: Map<Entity, View>;
}

export type GameDisplayModule = DisplayModule<GameDisplayContext>;

export class GameDisplay implements GameDisplayContext {
    modules: GameDisplayModule[];
    scene: Phaser.Scene;
    ecs: ECS;
    layers: Layers;
    hill: View;
    
    viewsByEntity:Map<Entity, View> = new Map();
    iconsByEntity:Map<Entity, View> = new Map();

    init(
        scene: Phaser.Scene, 
        ecs: ECS, 
        modules: GameDisplayModule[])
    {
        this.scene = scene;
        this.ecs = ecs;
        this.layers = new Layers(scene);
        this.modules = modules;
        
        for (const module of this.modules) {
            module.init(this);
        }
        
        this.setHill();
    }
    
    public setHill(): void {
        // Why offset?
        const hOffset = 100;
        const wOffset = 100;

        const hillPosition = {
            x: Math.round(Config.GameWidth / 2 + wOffset),
            y: Math.round(Config.GameHeight / 2 + hOffset)
        };


        const hillDef = createView({
            position: hillPosition,
            spriteName: 'hill',
            selectable: false,
        });
        
        this.hill = new View(0, {}, hillDef, this.layers.Ground, this.scene);
        this.hill.applyEffect(EffectType.Shader, { shader: "TimeTint" });
    }

    public destroy() {
        this.modules.forEach(module => module.destroy());
        this.layers.destroy();
    }

    public update(delta: number) {
        this.modules.forEach(module => module.update(delta));
        this.viewsByEntity.forEach(view => view.update(delta));
        this.iconsByEntity.forEach(view => view.update(delta));
    }
}


// ---

import {GameDisplay} from "../GameDisplay.ts";
import {DisplayModule} from "../setup/DisplayModule.ts";
import {ControlledCamera} from "./ControlledCamera.ts";
import {Config} from "../../config/Config.ts";
import { EventBus } from "../../EventBus.ts";
import { GameEvent } from "../../consts/GameEvent.ts";
import { UIEvent } from "../../consts/UIEvent.ts";

export class CameraModule extends DisplayModule<GameDisplay> {
    public Camera: ControlledCamera;

    override init(display: GameDisplay) {
        this.Camera = new ControlledCamera(display.scene, Config.GameWidth, Config.GameHeight, Config.Camera);
        EventBus.on(UIEvent.FindViewRequested, this.handleFindViewRequested.bind(this));
    }

    private handleFindViewRequested(view: Phaser.GameObjects.Container) {
        if (view) {
            this.Camera.lookAt(view.x, view.y);
        }
    }

    override update(delta: number) {
        this.Camera?.update(delta);
    }

    override destroy() {
        this.Camera?.destroy();
        EventBus.off(GameEvent.ViewSelected);
    }
}

// ---

import Phaser from 'phaser';
import {CameraConfig} from "../../config/CameraConfig.ts";
import {PointerEvent} from "../../consts/PointerEvent.ts";
import { EventBus } from '../../EventBus.ts';

export class ControlledCamera {

    private readonly scene: Phaser.Scene;
    private readonly camera: Phaser.Cameras.Scene2D.Camera;
    private readonly config: CameraConfig; 

    private isDown = false;
    private isCountingClicks = false;
    private clickCount = 0;
    private timeout: number = 0;
    private dragInertia: Phaser.Math.Vector2 = new Phaser.Math.Vector2();
    private lastDragDelta: Phaser.Math.Vector2 = new Phaser.Math.Vector2();
    private readonly inertiaThresholdSq: number;
    
    public draggable: boolean = true;
    
    public constructor(
        scene: Phaser.Scene,
        worldWidth: number,
        worldHeight: number,
        config: CameraConfig, 
    ) {
        this.scene = scene;
        this.config = config;
        this.inertiaThresholdSq = this.config.InertiaThreshold * this.config.InertiaThreshold; 

        this.camera = this.scene.cameras.main;
        this.setupCamera(worldWidth, worldHeight);
    }

    public lookAt(x: number, y: number) {
        this.dragInertia.set(0, 0);

        const cam = this.camera;
        cam.pan(x,y,
          this.config.PanDurationMs,
          this.config.PanEasing,
          true
        );
      
        cam.zoomTo(
          this.config.DefaultZoom,
          this.config.ZoomDurationMs
        );
    }

    public follow(entity: Phaser.GameObjects.GameObject) {
        this.camera.startFollow(entity, true, 0.1, 0.1);
    }

    public destroy() {
        this.scene.input.off(PointerEvent.PointerDown, this.handlePointerDown, this);
        this.scene.input.off(PointerEvent.PointerUp, this.handlePointerUp, this);
        this.scene.input.off(PointerEvent.PointerMove, this.handlePointerMove, this);
        this.scene.input.off(PointerEvent.Wheel, this.handleWheel, this);
        clearTimeout(this.timeout);
    }

    private resetZoom() {
        this.dragInertia.set(0, 0);
        this.camera.pan(
            this.camera.width / 2,
            this.camera.height / 2,
            this.config.PanDurationMs,
            this.config.PanEasing,
            true
        );
        this.camera.zoomTo(
            this.config.MinZoom,
            this.config.ZoomDurationMs
        );
    }

    private handlePointerDown(pointer: Phaser.Input.Pointer) {
        if (pointer.rightButtonDown()) {
            return;
        }
        this.isDown = true;
        this.dragInertia.set(0, 0);
        this.lastDragDelta.set(0, 0);
        clearTimeout(this.timeout);

        if (!this.isCountingClicks) {
            this.isCountingClicks = true;
            this.timeout = window.setTimeout(() => {
                this.isCountingClicks = false;
                this.clickCount = 0;
            }, this.config.MaxTimeBetweenClicksMs);
        }
    }

    private handlePointerUp(pointer: Phaser.Input.Pointer) {
        if (this.scene.input.manager.activePointer.rightButtonDown()) {
            return;
        }
        this.dragInertia.copy(this.lastDragDelta);
        this.isDown = false;

        if (this.isCountingClicks) {
            this.clickCount++;
            if (this.clickCount === 2) {
                // TODO - fire event
                // this.resetZoom();
                const worldPoint = pointer.positionToCamera(this.camera) as Phaser.Math.Vector2;
                EventBus.emit(PointerEvent.DoubleClick, worldPoint);
                this.isCountingClicks = false;
                this.clickCount = 0;
                clearTimeout(this.timeout);
            }
        }
    }

    private handleWheel(pointer: Phaser.Input.Pointer) {
        const zoom = this.camera.zoom;
        let newZoom: number;

        if (pointer.deltaY < 0) {
            newZoom = Phaser.Math.Clamp(
                zoom * this.config.WheelZoomFactorIncrement,
                this.config.MinZoom,
                this.config.MaxZoom
            );
        } else {
            newZoom = Phaser.Math.Clamp(
                zoom * this.config.WheelZoomFactorDecrement, 
                this.config.MinZoom, 
                this.config.MaxZoom
            );
        }

        if (newZoom !== zoom) {
            this.dragInertia.set(0, 0);
            this.adjustCameraToPointer(pointer, newZoom);
        }
    }

    private adjustCameraToPointer(pointer: Phaser.Input.Pointer, newZoom: number) {
        const worldPoint = pointer.positionToCamera(this.camera) as Phaser.Math.Vector2;
        const newX = worldPoint.x - (worldPoint.x - this.camera.scrollX);
        const newY = worldPoint.y - (worldPoint.y - this.camera.scrollY);
        this.camera.zoomTo(
            newZoom,
            this.config.ZoomDurationMs
        );
        this.camera.setScroll(newX, newY);
    }

    private handlePointerMove(pointer: Phaser.Input.Pointer) {
        if (!this.isDown || !this.draggable) {
            return;
        }
        const dx = pointer.x - pointer.prevPosition.x;
        const dy = pointer.y - pointer.prevPosition.y;
        this.lastDragDelta.set(dx, dy);
        this.camera.scrollX -= (dx / this.camera.zoom);
        this.camera.scrollY -= (dy / this.camera.zoom);
    }

    update(_:number) {
        if (!this.isDown && this.dragInertia.lengthSq() > this.inertiaThresholdSq) {
            this.camera.scrollX -= (this.dragInertia.x / this.camera.zoom);
            this.camera.scrollY -= (this.dragInertia.y / this.camera.zoom);
            this.dragInertia.scale(this.config.DragDamping);
        } else if (this.dragInertia.x !== 0 || this.dragInertia.y !== 0) {
            this.dragInertia.set(0, 0);
        }
    }

    private setupCamera(worldWidth: number, worldHeight: number) {
        this.camera.setBackgroundColor(this.config.BackgroundColor);
        this.camera.setBounds(0, 0, worldWidth, worldHeight);

        this.scene.input.on(PointerEvent.PointerDown, this.handlePointerDown, this);
        this.scene.input.on(PointerEvent.PointerUp, this.handlePointerUp, this);
        this.scene.input.on(PointerEvent.PointerMove, this.handlePointerMove, this);
        this.scene.input.on(PointerEvent.Wheel, this.handleWheel, this);

        this.resetZoom();
    }
}

// ---


import Phaser from "phaser";
import { ECS, Entity } from "../../../ECS";
import { Transform } from "../../../components/Transform";
import { WoodDojo } from "../../../logic/buildings/wood_dojo/WoodDojo";
import { SpriteKey } from "../../setup/SpriteLibrary";
import { View } from "../../setup/View";
import { ViewDefinition, ViewType, PanelDefinition } from "../../setup/ViewDefinition";
import { ViewDisplayModule, registerViewDisplayModule } from "../../setup/ViewDisplayModule";
import { EffectType } from "../../setup/ViewEffectController";
import { createView } from "../../setup/ViewStore";
import { ToolType } from "../tools/GameTools";
import { GameDisplayContext } from "../../GameDisplay";

export class BuildingViewModule extends ViewDisplayModule {
    init(context: GameDisplayContext): void {
        registerViewDisplayModule(this, context, context.viewsByEntity);
    }

    update(delta: number): void {
        this.tracker?.update();
    }

    destroy(): void {
        this.tracker?.destroy();
    }
      
  getComponentClasses(): Function[] {
    return [Transform, WoodDojo];
  }

  getLayerContainer(): Phaser.GameObjects.Container {
    return this.context.layers.Caves;
  }

  createDefinition(ecs: ECS, entity: Entity): ViewDefinition {
    const transform = ecs.getComponent(entity, Transform);

    return createView({
      spriteName: "wood_dojo" as SpriteKey,
      position: {
        x: Math.round(transform.x),
        y: Math.round(transform.y),
      },
      size: { x: 2, y: 2 },
      frame: 0,
      type: ViewType.CAVE,
      panelDefinition: this.createPanelDefinition(),
    });
  }

  private createPanelDefinition(): PanelDefinition {
    const panel = new PanelDefinition();
    panel.title = "Wood Dojo";
    panel.description = "Center of Wood Mastery";
    panel.imagePath = "assets/panels/wood_dojo_panel.png";
    panel.actions = [
      {
        label: "Select Trees to Harvest",
        type: ToolType.TreeCutting,
      },
    ];
    return panel;
  }

  updateView(ecs: ECS, entity: Entity, view: View): boolean {
    const transform = ecs.getComponent(entity, Transform);
    view.viewContainer.x = Math.round(transform.x);
    view.viewContainer.y = Math.round(transform.y);
    return false;
  }

  createView(ecs: ECS, entity: number, views: { [key: number]: ViewDefinition; }, viewDefinition: ViewDefinition): View {
    const view = new View(viewDefinition.id, views, viewDefinition, this.context.layers.Surface, this.context.scene);
    view.applyEffect(EffectType.Shader, { shader: "TimeTint" });

    return view;
}
}


// ---

import { ECS, Entity } from "../../../ECS";
import { Cave } from "../../../logic/buildings/Cave";
import { Transform } from "../../../components/Transform";
import { GameDisplayContext } from "../../GameDisplay";
import { SpriteKey } from "../../setup/SpriteLibrary";
import { View } from "../../setup/View";
import { ViewDefinition, ViewType } from "../../setup/ViewDefinition";
import { ViewDisplayModule, registerViewDisplayModule } from "../../setup/ViewDisplayModule";
import { EffectType } from "../../setup/ViewEffectController";
import { createView } from "../../setup/ViewStore";


export class CaveViewModule extends ViewDisplayModule {
    init(context: GameDisplayContext): void {
        registerViewDisplayModule(this, context, context.viewsByEntity);
    }

    update(delta: number): void {
        this.tracker?.update();
    }

    destroy(): void {
        this.tracker?.destroy();
    }
      
  getComponentClasses(): Function[] {
    return [Transform, Cave];
  }

  getLayerContainer(): Phaser.GameObjects.Container {
    return this.context.layers.Caves;
  }

  createDefinition(ecs: ECS, entity: Entity): ViewDefinition {
    const transform = ecs.getComponent(entity, Transform);

    return createView({
      spriteName: "cave" as SpriteKey,
      position: {
        x: Math.round(transform.x),
        y: Math.round(transform.y),
      },
      frame: 0,
      type: ViewType.CAVE,
    });
  }

  updateView(ecs: ECS, entity: Entity, view: View): boolean {
    const transform = ecs.getComponent(entity, Transform);
    view.viewContainer.x = Math.round(transform.x);
    view.viewContainer.y = Math.round(transform.y);
    return false;
  }

  createView(ecs: ECS, entity: number, views: { [key: number]: ViewDefinition; }, viewDefinition: ViewDefinition): View {
    const view = new View(viewDefinition.id, views, viewDefinition, this.context.layers.Caves, this.context.scene);
    view.applyEffect(EffectType.Shader, { shader: "TimeTint" });
    return view;
}
}


// ---


import Phaser from "phaser";
import { ECS, Entity } from "../../../ECS";
import { EventBus } from "../../../EventBus";
import { GameEvent } from "../../../consts/GameEvent";
import { Character, CharacterType } from "../../../logic/characters/Character";
import { LocationState, Transform } from "../../../components/Transform";
import { View } from "../../setup/View";
import { ViewDefinition, PanelDefinition, ViewType, PanelType } from "../../setup/ViewDefinition";
import { ViewDisplayModule, registerViewDisplayModule } from "../../setup/ViewDisplayModule";
import { EffectType } from "../../setup/ViewEffectController";
import { createView } from "../../setup/ViewStore";
import { ViewTracker } from "../../setup/ViewTracker";
import { GameDisplayContext } from "../../GameDisplay";

export class CharacterViewModule extends ViewDisplayModule {
    init(context: GameDisplayContext): void {
        registerViewDisplayModule(this, context, context.viewsByEntity);
    }

    update(delta: number): void {
        this.tracker?.update();
    }

    destroy(): void {
        this.tracker?.destroy();
    }
      
    getComponentClasses(): Function[] {
       return [Transform, Character];
    }

    getLayerContainer(): Phaser.GameObjects.Container {
        return this.context.layers.Surface;
    }

    createDefinition(ecs: ECS, entity: Entity): ViewDefinition {
        const transform = ecs.getComponent(entity, Transform);

        const panelDefinition = new PanelDefinition();
        panelDefinition.title = "Professor Booker";
        panelDefinition.description = "The kind, absent-minded founder of Zooniversity.";
        panelDefinition.imagePath = "assets/characters/booker/booker_panel.png";
        panelDefinition.panelType = PanelType.CHARACTER;

        return createView({
            spriteName: "booker_char",
            position: {
                x: Math.round(transform.x),
                y: Math.round(transform.y),
            },
            frame: 0,
            type: ViewType.CHARCTER,
            panelDefinition
        });
    }

    updateView(ecs: ECS, entity: Entity, view: View): boolean {
        const transform = ecs.getComponent(entity, Transform);
        const rx = Math.round(transform.x);
        const ry = Math.round(transform.y);
        view.viewContainer.visible = transform.locationState != LocationState.INSIDE;
        const isChanged = view.viewContainer.x !== rx || view.viewContainer.y !== ry;

        view.viewContainer.x = rx;
        view.viewContainer.y = ry;
        view.viewContainer.scaleX = view.viewDefinition.size.x * transform.direction;

        const updateData = {
            id: entity,
            pos: ViewTracker.getReactCoordsFromPhaser(view.viewContainer, this.context.scene.cameras.main),
            character: {
                icon: "assets/characters/booker/booker_icon.png",
                type: CharacterType.PROFESSOR
            }
        };

        EventBus.emit(GameEvent.CharacterUpdate, updateData);

        return isChanged;
    }


    createView(ecs: ECS, entity: number, views: { [key: number]: ViewDefinition; }, viewDefinition: ViewDefinition): View {
        const view = new View(viewDefinition.id, views, viewDefinition, this.context.layers.Surface, this.context.scene);
        view.applyEffect(EffectType.Shader, { shader: "TimeTint" });
        return view;
    }
}


// ---

import { BuffType } from "../../../logic/buffs/buffsData";

export interface BuffDisplayInfo {
    isBuff: boolean;
    displayName: string;
    iconAssetKey: string;
    description: string;
}

export const BuffDisplayRegistry: Partial<Record<BuffType, BuffDisplayInfo>> = {
    [BuffType.RESTED]: {
        displayName: "Rested",
        iconAssetKey: "assets/icons/sleep_icon.png", // Ensure this asset exists
        description: "Feeling refreshed! +10% to walking and work speed.",
        isBuff: true,
    }
    // Add display information for other BuffTypes as they are created and need UI representation.
};

// ---

import { GameDisplayContext } from "../../GameDisplay.ts";
import { DisplayModule } from "../../setup/DisplayModule.ts";
import { EventBus } from "../../../EventBus.ts";
import { UIEvent } from "../../../consts/UIEvent.ts";
import { GameEvent } from "../../../consts/GameEvent.ts";
import { PanelDefinition } from "../../setup/ViewDefinition.ts";
import { PanelTypeReducer, PanelTypeReducers } from "./PanelReducersRegistry.ts";
import { PanelActionImplementation, SelectionPanelReducer, SelectionPanelReducers, createPanelActions } from "./PanelAction.ts";

export type PanelData = {
  actionsImpl?: PanelActionImplementation[];
  panelTypeData?: unknown;
} & PanelDefinition;

const findActionDefinition = {
  label: "find",
  type: "find",
};

export class DataPanelModule extends DisplayModule<GameDisplayContext> {
  private display: GameDisplayContext;
  private activeEntity: number = -1;
  private lastPayload: string = "";

  public init(display: GameDisplayContext): void {
    this.display = display;
    EventBus.on(GameEvent.SelectionChanged, this.handleSelectionChanged, this);
  }

  public destroy(): void {
    EventBus.off(GameEvent.SelectionChanged, this.handleSelectionChanged, this);
  }

  private handleSelectionChanged(entity: number): void {
    this.activeEntity = entity;
    this.updatePanel();
  }

  public update(_: number): void {
    this.updatePanel();
  }

  private updatePanel(): void {
    if (this.activeEntity === -1) {
        EventBus.emit(UIEvent.ShowPanelCalled, null);
        this.lastPayload = "";
        return;
    }

    const view = this.display.viewsByEntity.get(this.activeEntity);
    if (!view) return;

    const baseDef = view.viewDefinition.panelDefinition;
    if (!baseDef) return;

    const reducer: SelectionPanelReducer | undefined = SelectionPanelReducers[view.viewDefinition.type];
    const reduced = reducer ? reducer(this.activeEntity, this.display.ecs) : {};

    const typeReducer: PanelTypeReducer | undefined = baseDef.panelType ? PanelTypeReducers[baseDef.panelType] : undefined;
    const panelTypeData = typeReducer ? typeReducer(this.activeEntity, this.display.ecs) : undefined;

    const fullDef: PanelData = {
            ...baseDef,
            ...reduced,
            actionsImpl: createPanelActions({...baseDef, actions:[findActionDefinition, ...(baseDef.actions || [])]}, this.activeEntity, view),
            panelTypeData
        };

        const payload = JSON.stringify(fullDef);
        if (payload !== this.lastPayload) {
            this.lastPayload = payload;
            EventBus.emit(UIEvent.ShowPanelCalled, fullDef);
        }
    }
}


// ---

import { Entity, ECS } from "../../../ECS";
import { EventBus } from "../../../EventBus";
import { GameEvent } from "../../../consts/GameEvent";
import { UIEvent } from "../../../consts/UIEvent";
import { View } from "../../setup/View";
import { PanelDefinition, DisplayTrait } from "../../setup/ViewDefinition";
import { ToolType } from "../tools/GameTools";

export type PanelActionImplementation = {
    label: string;
    type: string;
    action: () => void;
    icon?: string;
};

type PanelActionMaker = (def: PanelDefinition, entity: number, view: View) => () => void;

const actionFunctions: Record<string, PanelActionMaker> = {
    tree_cutting: (_def, _entity, _view) => () => {
        EventBus.emit(GameEvent.ToolSelected, ToolType.TreeCutting);
    },
    find: (_def, _entity, view) => () => {
        EventBus.emit(UIEvent.FindViewRequested, view.viewContainer);
    }
};

const actionIcons: Record<string, string> = {
    tree_cutting: "assets/icons/axe_icon.png",
    find: "assets/icons/find_icon.png"
};

export function createPanelActions(
    def: PanelDefinition,
    entity: number,
    view: View
    ): PanelActionImplementation[] {
    if (!def.actions) return [];
    return def.actions.map(action => ({
        label: action.label,
        type: action.type,
        action: actionFunctions[action.type]?.(def, entity, view) ?? (() => {}),
        icon: actionIcons[action.type] ?? undefined
    }));
}

export interface SelectionPanelData {
    traits?: DisplayTrait[];
    extraLines?: string[];
}

export type SelectionPanelReducer = (entity: Entity, ecs: ECS) => Partial<SelectionPanelData>;

export const SelectionPanelReducers: Partial<Record<number, SelectionPanelReducer>> = {}; // populated elsewhere if needed
  

// ---

import { ECS, Entity } from "../../../ECS";
import { PanelType } from "../../setup/ViewDefinition";
import { cavePanelReducer } from "./buildings/cavePanelReducer";
import { characterPanelReducer } from "./character/characterPanelReducer";
import { treePanelReducer } from "./tree/treePanelReducer";
import { woodDojoPanelReducer } from "./buildings/woodDojoPanelReducer";

export type PanelTypeReducer = (entity: Entity, ecs: ECS) => unknown;

export const PanelTypeReducers: Partial<Record<PanelType, PanelTypeReducer>> = {
  [PanelType.CHARACTER]: characterPanelReducer,
  [PanelType.WOOD_DOJO]: woodDojoPanelReducer,
  [PanelType.CAVE]: cavePanelReducer,
  [PanelType.TREE]: treePanelReducer
};

// ---

import { PanelDefinition, PanelType } from "../../setup/ViewDefinition";
import { ToolType } from "../tools/GameTools";

export enum PanelId {
  CHAR_BOOKER = "char_booker",
  BUILDING_WOOD_DOJO = "building_wood_dojo",
  TREE_GENERIC = "tree_generic",
  CAVE_GENERIC = "cave_generic",
}

export const PanelRegistry: Partial<Record<PanelId, PanelDefinition>> = {};

export function loadPanelRegistry(scene: Phaser.Scene) {
    const raw = scene.cache.json.get("panelRegistry") as Record<PanelId, PanelDefinition>;
    for (const [key, value] of Object.entries(raw)) {
      PanelRegistry[key as PanelId] = {
        ...value,
        panelType: PanelType[value.panelType as keyof typeof PanelType],
        actions: value.actions?.map((a: any) => ({
          label: a.label,
          type: ToolType[a.type as keyof typeof ToolType],
        })),
      };
    }
  }

// ---

import { ECS, Entity } from "../../../../ECS";

export function cavePanelReducer(entity: Entity, ecs: ECS): unknown {
    return {}; // Placeholder for cave-specific data
}


// ---

import { ECS, Entity } from "../../../../ECS";
import { WoodDojo } from "../../../../logic/buildings/wood_dojo/WoodDojo";

export function woodDojoPanelReducer(entity: Entity, ecs: ECS): unknown {
    const dojo = ecs.getComponent(entity, WoodDojo);
    return { assignedCharacters: dojo?.assignedCharacters ?? [] };
}


// ---

import { ECS, Entity } from "../../../../ECS";
import { ActionIntentComponent } from "../../../../logic/action-intent/ActionIntentComponent";
import { StrollComponent } from "../../../../logic/action-intent/StrollComponent";
import { CharacterIntent, CharacterAction, isChoppingData, isSleepingData, isStrollingAtPointData, isWalkingData } from "../../../../logic/action-intent/actionIntentData";
import { DormitoryComponent } from "../../../../logic/buildings/dormitory/DormitoryComponent";
import { HomeComponent } from "../../../../logic/buildings/dormitory/HomeComponent";
import { WoodDojo } from "../../../../logic/buildings/wood_dojo/WoodDojo";
import { ScheduleComponent } from "../../../../logic/characters/ScheduleComponent";
import { TimeComponent } from "../../../../logic/time/TimeComponent";
import { Tree } from "../../../../logic/trees/Tree";
import { deriveBuffs } from "./deriveBuffs";


export function characterPanelReducer(entity: Entity, ecs: ECS): unknown {
    const actionIntent = ecs.getComponent(entity, ActionIntentComponent);
    const schedule = ecs.getComponent(entity, ScheduleComponent);
    const timeEntity = ecs.getEntitiesWithComponent(TimeComponent)[0];
    const time = ecs.getComponent(timeEntity, TimeComponent);
    const hour = time.hour;

    if (!actionIntent || !schedule) {
        return {
            currentStatusText: "Awaiting assignment",
            currentPerformedAction: CharacterAction.IDLE,
            currentScheduleIndex: hour,
            currentScheduleText: "No schedule",
            scheduleIconTypes: []
        };
    }

    const currentScheduledIntent = schedule.entries[hour] ?? CharacterIntent.NONE;

    return {
        currentStatusText: deriveCurrentStatusText(ecs, entity, actionIntent),
        currentPerformedAction: actionIntent.currentPerformedAction,
        currentScheduleIndex: hour,
        currentScheduleText: convertScheduleIntentToDisplayText(currentScheduledIntent, ecs, entity),
        scheduleIconTypes: schedule.entries.map(entry => convertScheduleIntentToIconType(entry as CharacterIntent)),
        activeBuffs: deriveBuffs(ecs, entity, time.minutesElapsed)
    };
}


export enum CharacterScheduleIconType {
    HARVEST = "Harvest", SLEEP = "Sleep", STUDY = "Study", REST = "Rest", BUILD = "Build", NONE = "None",
  }
  
function convertScheduleIntentToDisplayText(intent: CharacterIntent, ecs: ECS, entity: Entity): string {
    const home = ecs.getComponent(entity, HomeComponent);
    const homeName = home?.homeEntityId ? getEntityName(ecs, home.homeEntityId) : "their work area";
    switch (intent) {
        case CharacterIntent.HARVEST: return `Work @ ${homeName}`;
        case CharacterIntent.SLEEP:   return "Bed Time";
        case CharacterIntent.STUDY:   return "Studying";
        case CharacterIntent.REST:    return "Personal Time";
        case CharacterIntent.BUILD:   return `Building @ ${homeName}`;
        case CharacterIntent.NONE:    return "Free Time";
        default:                      return "Task";
    }
}

function convertScheduleIntentToIconType(intent: CharacterIntent): CharacterScheduleIconType {
    switch (intent) {
        case CharacterIntent.HARVEST: return CharacterScheduleIconType.HARVEST;
        case CharacterIntent.SLEEP:   return CharacterScheduleIconType.SLEEP;
        case CharacterIntent.STUDY:   return CharacterScheduleIconType.STUDY;
        case CharacterIntent.REST:    return CharacterScheduleIconType.REST;
        case CharacterIntent.BUILD:   return CharacterScheduleIconType.BUILD;
        default:                      return CharacterScheduleIconType.NONE;
    }
}

function getStatusTextForRest(ecs: ECS, entity: Entity, aic: ActionIntentComponent): string {
    const strollComp = ecs.getComponent(entity, StrollComponent);
    if (strollComp) {
        if (aic.currentPerformedAction === CharacterAction.WALKING && isWalkingData(aic.actionData) && aic.actionData.ultimateTargetEntityId) {
            return `Strolling towards ${getEntityName(ecs, aic.actionData.ultimateTargetEntityId)}`;
        } else if (aic.currentPerformedAction === CharacterAction.STROLLING && isStrollingAtPointData(aic.actionData)) {
            return `Enjoying nature near ${getEntityName(ecs, aic.actionData.atTreeEntityId)}`;
        }
        return "Having a relaxing stroll";
    }
    return "Taking personal time";
}

function getStatusTextForHarvest(ecs: ECS, entity: Entity, aic: ActionIntentComponent): string {
    if (aic.currentPerformedAction === CharacterAction.WALKING && isWalkingData(aic.actionData) && aic.actionData.ultimateTargetEntityId) {
        return `Walking to ${getEntityName(ecs, aic.actionData.ultimateTargetEntityId)} to harvest`;
    } else if (aic.currentPerformedAction === CharacterAction.CHOPPING && isChoppingData(aic.actionData)) {
        return `Chopping ${getEntityName(ecs, aic.actionData.targetTreeEntityId)}`;
    } else if (aic.currentPerformedAction === CharacterAction.NONE) {
        return "Waiting for available tree";
    }
    return "Preparing to harvest";
}

function getStatusTextForSleep(ecs: ECS, entity: Entity, aic: ActionIntentComponent): string {
    if (aic.currentPerformedAction === CharacterAction.WALKING && isWalkingData(aic.actionData) && aic.actionData.ultimateTargetEntityId) {
        return `Going to bed at ${getEntityName(ecs, aic.actionData.ultimateTargetEntityId)}`;
    } else if (aic.currentPerformedAction === CharacterAction.SLEEPING && isSleepingData(aic.actionData)) {
        return `Sleeping in ${getEntityName(ecs, aic.actionData.bedEntityId)}`;
    } else if (aic.currentPerformedAction === CharacterAction.NONE) {
        return "Waiting for a bed";
    }
    return "Preparing for bed";
}

function deriveCurrentStatusText(ecs: ECS, entity: Entity, actionIntent: ActionIntentComponent): string {
    switch (actionIntent.intentType) {
        case CharacterIntent.REST:    return getStatusTextForRest(ecs, entity, actionIntent);
        case CharacterIntent.HARVEST: return getStatusTextForHarvest(ecs, entity, actionIntent);
        case CharacterIntent.SLEEP:   return getStatusTextForSleep(ecs, entity, actionIntent);
        case CharacterIntent.NONE:    return "Contemplating.";
        default:{
            const actionString = (Object.keys(CharacterAction) as Array<keyof typeof CharacterAction>)
                .find(key => CharacterAction[key] === actionIntent.currentPerformedAction);
            return actionString ? `${actionString}` : "Engaged in a task";
          }
    }
}

function getEntityName(ecs: ECS, entityId: Entity | null | undefined): string {
    if (entityId === null || entityId === undefined || !ecs.hasEntity(entityId)) return "an unknown place";
    if (ecs.hasComponent(entityId, Tree)) return "a tree";
    if (ecs.hasComponent(entityId, WoodDojo)) return "the Wood Dojo";
    if (ecs.hasComponent(entityId, DormitoryComponent)) return "the Dormitory";
    return `location #${entityId}`;
}


// ---

import { ECS, Entity } from "../../../../ECS";
import { ActiveBuffsComponent } from "../../../../logic/buffs/ActiveBuffsComponent";
import { AffectedStat, BuffEffectApplicationType, BuffEffect, BUFF_DEFINITIONS } from "../../../../logic/buffs/buffsData";
import { BuffDisplayRegistry } from "../BuffDisplayRegistry";

export interface DisplayableBuffEffect {
    stat: AffectedStat;
    value: number;
    applicationType: BuffEffectApplicationType;
    effectText: string; // Textual description of the specific effect
}

export interface DisplayableBuffData {
    key: string; 
    displayName: string;
    iconAssetKey: string;
    description: string; // General description of the buff
    effects: DisplayableBuffEffect[];
    totalDurationMinutes: number;
    remainingDurationMinutes: number; 
    isBuff: boolean; 
}

function formatEffectValue(value: number, type: BuffEffectApplicationType): string {
    if (type === BuffEffectApplicationType.FLAT_ADDITIVE) {
        return `${value >= 0 ? '+' : ''}${value}`;
    }
    if (type === BuffEffectApplicationType.PERCENT_MULTIPLICATIVE) {
        const percentage = Math.round((value - 1) * 100);
        return `${percentage >= 0 ? '+' : ''}${percentage}%`;
    }
    return `${value}`; // Fallback
}

function affectedStatToText(stat: AffectedStat): string {
    switch (stat) {
        case AffectedStat.LOCOMOTION_SPEED: return "Speed";
        case AffectedStat.WORK_SPEED: return "Work Rate";
        case AffectedStat.HARVEST_SPEED: return "Harvest Rate";
        default: {
            return "";
        }
    }
}

function effectToText(effect: BuffEffect): string {
    const valueText = formatEffectValue(effect.value, effect.type);
    const statText = affectedStatToText(effect.stat);
    return `${statText}: ${valueText}`;
}

export function deriveBuffs(ecs: ECS, entity: Entity, currentTimeMinutes: number): DisplayableBuffData[] {
    const displayedBuffs: DisplayableBuffData[] = [];
    const activeBuffsComp = ecs.getComponent(entity, ActiveBuffsComponent);

    if (!activeBuffsComp || activeBuffsComp.buffs.length === 0) {
        return displayedBuffs;
    }

    for (const activeBuff of activeBuffsComp.buffs) {
        const definition = BUFF_DEFINITIONS[activeBuff.type];
        const displayInfo = BuffDisplayRegistry[activeBuff.type];

        if (definition && displayInfo) {
            const remainingDuration = Math.max(0, Math.floor(activeBuff.expirationTimeMinutes - currentTimeMinutes));
            
            const processedEffects: DisplayableBuffEffect[] = activeBuff.effects.map(eff => ({
                stat: eff.stat,
                value: eff.value,
                applicationType: eff.type,
                effectText: effectToText(eff)
            }));

            displayedBuffs.push({
                key: activeBuff.type.toString(),
                displayName: displayInfo.displayName,
                iconAssetKey: displayInfo.iconAssetKey,
                description: displayInfo.description,
                effects: processedEffects,
                totalDurationMinutes: definition.defaultDurationMinutes,
                remainingDurationMinutes: remainingDuration,
                isBuff: displayInfo.isBuff 
            });
        }
    }
    return displayedBuffs;
}

// ---

import { ECS, Entity } from "../../../../ECS";
import { HarvestableComponent } from "../../../../logic/trees/HarvestableComponent";

export function treePanelReducer(entity: Entity, ecs: ECS): unknown {
    const harvestable = ecs.getComponent(entity, HarvestableComponent);
    return {
        drops: harvestable?.drops ?? [],
        cutProgress: harvestable ? Math.max(0, Math.floor(harvestable.amount)) : 0,
        maxCutProgress: harvestable?.maxAmount ?? 0,
    };
}


// ---

import { Pos } from "../../../../utils/Math";
import Container = Phaser.GameObjects.Container;
import Graphics = Phaser.GameObjects.Graphics;

export type Position = "top" | "bottom" | "left" | "right";
export type Direction = "horizontal" | "vertical";

export interface ValueRef {
  current: number;
  max: number;
}

export interface SizeConfig {
  minWidth: number;
  maxWidth: number;
  minWidthValue: number;
  maxWidthValue: number;
}

export interface BorderConfig {
  color: number;
  thickness: number;
  radius?: number;
  opacity?: number;
}

export interface ProgressBarConfig {
  position: Position;
  offset: number;
  valueRef: ValueRef;
  size: SizeConfig;
  fillColor?: number;
  backgroundColor?: number;
  direction?: Direction;
  border?: BorderConfig;
}

export class ProgressBar {
  private container: Container;
  private graphics: Graphics;
  private config: Required<Omit<ProgressBarConfig, 'border'>> & { border?: BorderConfig };

  private isVisible: boolean = true;
  private anchorPos = { x: 0, y: 0 };
  private displayWidth: number = 32;
  private displayHeight: number = 32;

  private lastValue: number = -1;
  private lastMax: number = -1;
  private lastVisible: boolean = true;

  constructor(container: Container, config: ProgressBarConfig) {
    this.container = container;
    const direction: Direction =
      config.direction ?? (config.position === "left" || config.position === "right" ? "vertical" : "horizontal");

    this.config = {
      direction,
      fillColor: 0x00ff00,
      backgroundColor: 0x000000,
      ...config
    };

    this.graphics = container.scene.add.graphics();
    this.container.add(this.graphics);
    
    const sprite = container.list.find(obj => obj instanceof Phaser.GameObjects.Sprite) as Phaser.GameObjects.Sprite;
    if (sprite) {
      this.displayWidth = sprite.displayWidth;
      this.displayHeight = sprite.displayHeight;
    }
  }

  destroy(): void {
    this.graphics.destroy();
  }

  hide(): void {
    this.isVisible = false;
    this.graphics.setVisible(false);
  }

  show(): void {
    this.isVisible = true;
    this.graphics.setVisible(true);
  }

  update(delta: number, position:Pos): void {
    if (!this.isVisible || !this.config.valueRef) return;

    const { current, max } = this.config.valueRef;
    if (current === this.lastValue && max === this.lastMax && this.isVisible === this.lastVisible) return;

    this.lastValue = current;
    this.lastMax = max;
    this.lastVisible = this.isVisible;

    const { minWidth, maxWidth, minWidthValue, maxWidthValue } = this.config.size;
    const { fillColor, backgroundColor, direction, border } = this.config;

    const thickness = 6;
    const barLength = this.calculateWidth(max, minWidthValue, maxWidthValue, minWidth, maxWidth);
    const progress = Phaser.Math.Clamp(current / (max || 1), 0, 1);

    this.updateDisplaySize();
    this.getAnchorPosition(barLength, thickness);
    this.anchorPos.x += position.x;
    this.anchorPos.y += position.y;
    
    this.graphics.clear();

    // Border
    if (border) {
      this.graphics.fillStyle(border.color, border.opacity ?? 1);
      const radius = border.radius ?? 0;
      if (direction === "horizontal") {
        this.drawRoundedRect(
            this.anchorPos.x - border.thickness,
            this.anchorPos.y - border.thickness,
            barLength + 2 * border.thickness,
            thickness + 2 * border.thickness,
            radius
        );
      } else {
        this.drawRoundedRect(
            this.anchorPos.x - border.thickness,
            this.anchorPos.y - border.thickness,
            thickness + 2 * border.thickness,
            barLength + 2 * border.thickness,
            radius
        );
      }
    }

    // Background
    this.graphics.fillStyle(backgroundColor, 0.5);
    if (direction === "horizontal") {
      this.drawRoundedRect(this.anchorPos.x, this.anchorPos.y, barLength, thickness, 0);
    } else {
      this.drawRoundedRect(this.anchorPos.x, this.anchorPos.y, thickness, barLength, 0);
    }

    // Foreground
    this.graphics.fillStyle(fillColor, 1);
    if (direction === "horizontal") {
      this.drawRoundedRect(this.anchorPos.x, this.anchorPos.y, barLength * progress, thickness, 0);
    } else {
      const filled = barLength * progress;
      this.drawRoundedRect(this.anchorPos.x, this.anchorPos.y + (barLength - filled), thickness, filled, 0);
    }
  }

  private drawRoundedRect(x: number, y: number, w: number, h: number, r: number) {
    r > 0 ? this.graphics.fillRoundedRect(x, y, w, h, r) : this.graphics.fillRect(x, y, w, h);
  }

  private calculateWidth(value: number, minV: number, maxV: number, minW: number, maxW: number): number {
    if (value <= minV) return minW;
    if (value >= maxV) return maxW;
    const t = (Math.log(value) - Math.log(minV)) / (Math.log(maxV) - Math.log(minV));
    return minW + t * (maxW - minW);
  }

  private getAnchorPosition(length: number, thickness: number): void {
    const { position } = this.config;
    const { x: cx, y: cy } = this.container;
    const offset = this.config.offset;
    const halfW = this.displayWidth / 2;
    const halfH = this.displayHeight / 2;

    switch (position) {
      case "top":
        this.anchorPos.x = cx - length / 2;
        this.anchorPos.y = cy - halfH - offset - thickness;
        break;
      case "bottom":
        this.anchorPos.x = cx - length / 2;
        this.anchorPos.y = cy + halfH + offset;
        break;
      case "left":
        this.anchorPos.x = cx - halfW - offset - thickness;
        this.anchorPos.y = cy - length / 2;
        break;
      case "right":
        this.anchorPos.x = cx + halfW + offset;
        this.anchorPos.y = cy - length / 2;
        break;
    }
  }

  private updateDisplaySize(): void {
    const sprite = this.container.list.find(obj => obj instanceof Phaser.GameObjects.Sprite) as Phaser.GameObjects.Sprite;
    if (sprite) {
      this.displayWidth = sprite.displayWidth;
      this.displayHeight = sprite.displayHeight;
    }
  }
}

export const harvestBarConfig: ProgressBarConfig = {
  position: "left",
  offset: 50,
  valueRef: { current: 0, max: 1 },
  size: {
    minWidth: 20,
    maxWidth: 120,
    minWidthValue: 0.1,
    maxWidthValue: 1
  },
  fillColor: 0xffaa00,
  backgroundColor: 0x111111,
  border: {
    color: 0xffffff,
    thickness: 2,
    radius: 6,
    opacity: 0.8
  }
};


// ---

import { View } from "../../setup/View";
import { EffectInstance } from "../../setup/ViewEffectController";


export interface ShudderEffectConfig {
  interval: number;  // ms between shakes
  duration: number;  // ms shake duration
  strength: number;  // max shake distance in px
}

export class ShudderEffect implements EffectInstance {
  private sprite: Phaser.GameObjects.Sprite | undefined;
  private readonly interval: number;
  private readonly duration: number;
  private readonly strength: number;

  private timer = 0;
  private elapsed = 0;
  private isShaking = false;
  private originalX = 0;
  timeScale: number = 1;

  constructor(private view: View, config: ShudderEffectConfig) {
    this.sprite = view.getSprite?.();
    this.interval = config.interval;
    this.duration = config.duration;
    this.strength = config.strength;

    if (this.sprite) {
      this.originalX = this.sprite.x;
    }
  }

  start(): void {
    this.timer = 0;
    this.elapsed = 0;
    this.isShaking = false;
    if (this.sprite) {
      this.originalX = this.sprite.x;
    }
  }

  stop(): void {
    if (this.sprite) {
      this.sprite.x = this.originalX;
    }
  }

  setSpeed(speed: number): void {
    this.timeScale = speed;
  }
  
  update(delta: number): void {
    if (!this.sprite) return;

    this.timer += delta * this.timeScale;

    if (!this.isShaking && this.timer >= this.interval) {
      this.isShaking = true;
      this.elapsed = 0;
      this.timer = 0;
    }

    if (this.isShaking) {
      this.elapsed += delta;
      const t = Math.min(this.elapsed / this.duration, 1);
      const fade = 1 - t;

      this.sprite.x = this.originalX + (Math.random() - 0.5) * 2 * this.strength * fade;

      if (t >= 1) {
        this.sprite.x = this.originalX;
        this.isShaking = false;
      }
    }
  }
}


// ---

import { GameDisplayContext } from "../../GameDisplay.ts";
import { DisplayModule } from "../../setup/DisplayModule.ts";
import { TimeComponent } from "../../../logic/time/TimeComponent.ts";
import { TimeConfig } from "../../../config/TimeConfig.ts";
import { getColorForMinute } from "../time_tint/getColorForMinute.ts";
import { Config } from "../../../config/Config.ts";
import { WeatherComponent } from "../../../logic/weather/WeatherComponent.ts";

interface CloudLayerConfig {
    speed: number;
    preferredSprites: { key: string; weight: number }[];
    tintOffset: number;
    yOffset: number;
    ySpread: number;
    baseDensity: number;
    scaleMin: number;
    scaleMax: number;
    direction: 1 | -1;
}

interface CloudEntry {
    sprite: Phaser.GameObjects.Image;
    layerIndex: number;
}

export const CLOUD_TINT_GRADIENT: [number, number][] = [
    [0.0, 0x445566],
    [0.375, 0xf8f8ff],
    [0.5, 0xffffff],
    [0.875, 0xf8f8ff],
    [1.0, 0x445566],
];

function createCloudLayer(overrides: Partial<CloudLayerConfig>): CloudLayerConfig {
    return {
        speed: 0.5,
        preferredSprites: [{ key: "cloud0", weight: 1 }],
        tintOffset: 0.0,
        yOffset: 0,
        ySpread: 1200,
        baseDensity: 20,
        scaleMin: 1.0,
        scaleMax: 3.0,
        direction: 1,
        ...overrides,
    };
}

const CLOUD_LAYERS: CloudLayerConfig[] = [
    createCloudLayer({
        speed: 0.2,
        preferredSprites: [{ key: "cloud1", weight: 3 }, { key: "cloud0", weight: 1 }],
        tintOffset: 0,
        yOffset: 300,
    }),
    createCloudLayer({
        speed: 0.4,
        preferredSprites: [{ key: "cloud3", weight: 2 }, { key: "cloud0", weight: 2 }],
        tintOffset: 0.05,
        yOffset: 1200,
    }),
    createCloudLayer({
        speed: 0.8,
        preferredSprites: [{ key: "cloud0", weight: 4 }],
        tintOffset: 0.1,
        yOffset: 2200,
    }),
];

export class CloudsModule extends DisplayModule<GameDisplayContext> {
    private worldEntity!: number;
    private context!: GameDisplayContext;
    private containers: Phaser.GameObjects.Container[] = [];
    private cloudsByLayer: CloudEntry[][] = [];
    private outThreshold = 1000;
    private sceneWidth = 0;

    init(context: GameDisplayContext): void {
        this.context = context;
        const { scene, ecs, layers } = context;
        this.worldEntity = ecs.getEntitiesWithComponent(TimeComponent)[0];
        this.sceneWidth = scene.scale.width * 2 * Config.Camera.MaxZoom;

        CLOUD_LAYERS.forEach((layer, index) => {
            const container = scene.add.container();
            container.setDepth(-925 + index);
            layers.Sky.add(container);

            const clouds: CloudEntry[] = [];
            const spacing = this.sceneWidth / layer.baseDensity;
            const phaseOffset = (index / CLOUD_LAYERS.length) * spacing;

            for (let i = 0; i < layer.baseDensity; i++) {
                const sprite = this.spawnCloud(layer, scene);

                // Phase offset prevents same x positions between layers
                sprite.x = (i * spacing + phaseOffset) % this.sceneWidth;

                sprite.y = layer.yOffset + (Math.random() - 0.5) * layer.ySpread;
                container.add(sprite);
                clouds.push({ sprite, layerIndex:index });
            }


            this.containers.push(container);
            this.cloudsByLayer.push(clouds);
        });
    }

    update(delta: number): void {
        const { ecs } = this.context;
        const time = ecs.getComponent(this.worldEntity, TimeComponent);
        const weather = ecs.getComponent(this.worldEntity, WeatherComponent);

        const total = TimeConfig.HoursPerDay * TimeConfig.MinutesPerHour;
        const minute = time.hour * TimeConfig.MinutesPerHour + time.minute;
        const speedFactor = time.speedFactor ?? 1;
        const cloudCover = weather.cloudCover ?? 1;
        const windDir = weather.windDirection ?? 1;
        const effectiveSpeed = (weather.windStrength / TimeConfig.MinutesPerHour) * speedFactor * windDir;

        CLOUD_LAYERS.forEach((layer, layerIndex) => {
            this.updateLayer(layer, layerIndex, cloudCover, effectiveSpeed, windDir, minute, total, delta, speedFactor);
        });
    }

    private updateLayer(
        layer: CloudLayerConfig,
        layerIndex: number,
        cloudCover: number,
        effectiveSpeed: number,
        windDir: 1 | -1,
        minute: number,
        total: number,
        delta: number,
        speedFactor: number
    ) {
        const clouds = this.cloudsByLayer[layerIndex];
        const targetCount = Math.floor(layer.baseDensity * cloudCover);

        let activeCount = 0;

        for (let i = 0; i < clouds.length; i++) {
            const { sprite } = clouds[i];

            const becameVisible = this.updateCloud(
                sprite,
                activeCount < targetCount,
                layer,
                layerIndex,
                effectiveSpeed,
                windDir,
                minute,
                total,
                delta,
                speedFactor
            );

            if (becameVisible) {
                activeCount++;
            }
        }
    }

    private updateCloud(
        sprite: Phaser.GameObjects.Image,
        canBeActive: boolean,
        layer: CloudLayerConfig,
        layerIndex: number,
        effectiveSpeed: number,
        windDir: 1 | -1,
        minute: number,
        total: number,
        delta: number,
        speedFactor: number
    ): boolean {
        let becameVisible = false;

        // Move always
        sprite.x += (delta * 0.01 * effectiveSpeed);

        // Drift
        const drift = Math.sin(sprite.x * 0.00025 + layerIndex) * 0.05 * speedFactor;
        sprite.y -= drift;

        const outLeft = sprite.x < -this.outThreshold;
        const outRight = sprite.x > this.sceneWidth + this.outThreshold;
        const isOut = outLeft || outRight;

        if (isOut) {
            if (canBeActive) {
                // Re-enter
                const baseOffset = layerIndex * 20;
                const jitter = (Math.random() - 0.5) * 30;
                const offset = baseOffset + jitter;

                sprite.x = windDir === 1
                    ? -this.outThreshold + offset
                    : this.sceneWidth + this.outThreshold - offset;

                sprite.y = layer.yOffset + (Math.random() - 0.5) * layer.ySpread;

                if (!sprite.visible) {
                    sprite.setVisible(true);
                    becameVisible = true;
                }
            } else {
                sprite.setVisible(false);
            }
        } else if (!sprite.visible && canBeActive && this.shouldReenter(sprite, windDir)) {
            sprite.setVisible(true);
            becameVisible = true;
        }

        // Tint always
        const adjusted = (minute + layer.tintOffset * total) % total;
        sprite.setTint(getColorForMinute(adjusted, total, CLOUD_TINT_GRADIENT));

        return sprite.visible && becameVisible;
    }


    private shouldReenter(sprite: Phaser.GameObjects.Image, windDir: 1 | -1): boolean {
        const halfWidth = sprite.displayWidth / 2;

        if (windDir === 1) {
            // Entering from left  right
            const rightEdge = sprite.x + halfWidth;
            return rightEdge >= 0 && rightEdge <= this.outThreshold;
        } else {
            // Entering from right  left
            const leftEdge = sprite.x - halfWidth;
            return leftEdge <= this.sceneWidth && leftEdge >= this.sceneWidth - this.outThreshold;
        }
    }


    destroy(): void {
        this.cloudsByLayer.flat().forEach(c => c.sprite.destroy());
        this.containers.forEach(c => c.destroy());
        this.cloudsByLayer = [];
        this.containers = [];
    }

    private spawnCloud(layer: CloudLayerConfig, scene: Phaser.Scene): Phaser.GameObjects.Image {
        const spriteKey = this.chooseWeighted(layer.preferredSprites);
        const sprite = scene.add.image(0, 0, spriteKey);
        const scale = Phaser.Math.FloatBetween(layer.scaleMin, layer.scaleMax);
        sprite.setAlpha(0.8);
        sprite.setScale(scale);
        sprite.y = layer.yOffset + (Math.random() - 0.5) * layer.ySpread;
        return sprite;
    }

    private chooseWeighted(prefs: { key: string; weight: number }[]): string {
        const total = prefs.reduce((sum, p) => sum + p.weight, 0);
        let r = Math.random() * total;
        for (const p of prefs) {
            if (r < p.weight) return p.key;
            r -= p.weight;
        }
        return prefs[0].key;
    }
}


// ---

import {TimeComponent} from "../../../logic/time/TimeComponent.ts";
import {GameDisplayContext} from "../../GameDisplay.ts";
import {Entity} from "../../../ECS.ts";
import {DisplayModule} from "../../setup/DisplayModule.ts";
import {TimeConfig} from "../../../config/TimeConfig.ts";
import {Config} from "../../../config/Config.ts";
import {getColorForMinute, SKY_TINT_GRADIENT} from "../time_tint/getColorForMinute.ts";

export class SkyDisplayModule extends DisplayModule<GameDisplayContext> {
    private background!: Phaser.GameObjects.Rectangle;
    private worldEntity!: Entity;
    private context!: GameDisplayContext;
    init(context: GameDisplayContext): void {
        this.context = context;
        const { scene, ecs } = context;

        this.worldEntity = ecs.getEntitiesWithComponent(TimeComponent)[0];
        const w = (scene.scale.width*Config.Camera.MaxZoom) + 200;
        const h = (scene.scale.height*Config.Camera.MaxZoom)  + 200;
        this.background = scene.add
            .rectangle(0, 0, w, h, 0x000000)
            .setOrigin(0.5, 0.5)
            .setScrollFactor(0)
            .setDepth(-1000);

        context.layers.Sky.add(this.background);

        scene.scale.on("resize", () => {
            this.background.setSize(scene.scale.width, scene.scale.height);
        });
    }

    update(_: number): void {
        const time = this.context.ecs.getComponent(this.worldEntity, TimeComponent);
        
        if (!time){
            return;
        }
        
        const minutesInDay = TimeConfig.HoursPerDay * TimeConfig.MinutesPerHour;
        const currentMinute =
            time.hour * TimeConfig.MinutesPerHour + time.minute;

        const color = getColorForMinute(currentMinute, minutesInDay, SKY_TINT_GRADIENT);
        this.background.setFillStyle(color, 1);
    }

    destroy(): void {
        this.background?.destroy();
    }
}


// ---

import {GameDisplayContext} from "../../GameDisplay.ts";
import {DisplayModule} from "../../setup/DisplayModule.ts";
import {TimeComponent} from "../../../logic/time/TimeComponent.ts";
import {TimeConfig} from "../../../config/TimeConfig.ts";
import {Config} from "../../../config/Config.ts";

export class StarfieldModule extends DisplayModule<GameDisplayContext> {
    private starContainer!: Phaser.GameObjects.Container;
    private starBackground!: Phaser.GameObjects.Image;
    private stars: Phaser.GameObjects.Graphics[] = [];
    private starOffsets: number[] = [];
    private worldEntity!: number;
    private starCount = 120;
    private scene!: Phaser.Scene;
    private context!: GameDisplayContext;
    private center!: Phaser.Math.Vector2;

    init(context: GameDisplayContext): void {
        this.context = context;
        const { scene, layers, ecs } = context;
        this.scene = scene;

        this.worldEntity = ecs.getEntitiesWithComponent(TimeComponent)[0];

        const camera = scene.cameras.main;
        const width = camera.width * Config.Camera.MaxZoom;
        const height = camera.height * Config.Camera.MaxZoom;

        this.center = new Phaser.Math.Vector2(camera.scrollX + width / 2, camera.scrollY + height / 3);

        // Main container centered in the sky
        this.starContainer = scene.add.container(this.center.x, this.center.y);
        this.starContainer.setDepth(-950);
        layers.Sky.add(this.starContainer);

        // Milky Way background image (rotates with stars)
        this.starBackground = scene.add.image(0, 0, 'night_sky');
        this.starBackground.setOrigin(0.5);
        this.starBackground.setAlpha(0.6);
        this.starBackground.setScale(13); // Adjust scale if needed
        this.starContainer.add(this.starBackground);

        // Add twinkling stars in front
        for (let i = 0; i < this.starCount; i++) {
            const g = scene.add.graphics();
            g.fillStyle(0xffffff, 1);

            const radius = Math.random() * width * 0.6;
            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            const r = Math.random() * 2.5 + .5;

            g.fillCircle(0, 0, r);
            g.x = x;
            g.y = y;

            this.starContainer.add(g);
            this.stars.push(g);
            this.starOffsets.push(angle);
        }
    }

    update(): void {
        const time = this.context.ecs.getComponent(this.worldEntity, TimeComponent);
        const total = TimeConfig.HoursPerDay * TimeConfig.MinutesPerHour;
        const currentMinute = time.hour * TimeConfig.MinutesPerHour + time.minute;
        const baseAlpha = getNightAlpha(currentMinute, total);
        const zoom = this.scene.cameras.main.zoom;
        const timeSec = this.scene.time.now / 1000;

        // Rotate full circle over the day
        const t = currentMinute / total;
        this.starContainer.rotation = t * Math.PI * 2;

        for (let i = 0; i < this.stars.length; i++) {
            const star = this.stars[i];
            const offset = this.starOffsets[i];
            const twinkle = 0.85 + 0.15 * Math.sin(timeSec * 12 + offset) * Math.sin(timeSec * 7 + offset * 1.3);

            star.setAlpha(baseAlpha * twinkle);
            star.setScale(1 / zoom); // visual size constant
        }

        // Fade background in/out with stars
        this.starBackground.setAlpha(baseAlpha * 0.6);
    }

    destroy(): void {
        for (const star of this.stars) {
            star.destroy();
        }
        this.stars = [];
        this.starOffsets = [];

        this.starBackground?.destroy();
        this.starContainer?.destroy();
    }
}

function getNightAlpha(minute: number, total: number): number {
    const t = (minute % total) / total;

    if (t < 0.25 || t > 0.875) return 1; // full night
    if (t < 0.375) return 1 - (t - 0.25) * 8; // fade out at dawn
    if (t > 0.75) return (t - 0.75) * 8;      // fade in at dusk

    return 0;
}



// ---

import {GameDisplayContext} from "../../GameDisplay.ts";
import {DisplayModule} from "../../setup/DisplayModule.ts";
import {TimeComponent} from "../../../logic/time/TimeComponent.ts";
import {WeatherComponent} from "../../../logic/weather/WeatherComponent.ts";
import {updateTimeTintPipeline} from "./updateTimeTintPineline.ts";

export class TinterModule extends DisplayModule<GameDisplayContext> {
    private worldEntity!: number;
    private context!: GameDisplayContext;
    
    init(context: GameDisplayContext): void {
        this.context = context;
        const { ecs } = context;

        this.worldEntity = ecs.getEntitiesWithComponents([TimeComponent, WeatherComponent])[0];
    }

    update(_: number): void {
        const { ecs, scene } = this.context;
        const time = ecs.getComponent(this.worldEntity, TimeComponent);
        const weather = ecs.getComponent(this.worldEntity, WeatherComponent);
        updateTimeTintPipeline(scene, time, weather);
    }

    destroy(): void {
    }
}


// ---

import {View} from "../../setup/View.ts";
import {getColorForMinute, SPRITE_TINT_GRADIENT} from "./getColorForMinute.ts";


export class ViewTinter {
    private views = new Set<View>();

    add(view: View): void {
        this.views.add(view);
    }

    remove(view: View): void {
        this.views.delete(view);
    }

    clear(): void {
        this.views.clear();
    }

    update(minute: number, totalMinutesInDay: number): void {
        const color = getColorForMinute(minute, totalMinutesInDay, SPRITE_TINT_GRADIENT);

        for (const view of this.views) {
            view.getSprite()?.setTint(color);
        }
    }
}

// ---

import {lerpColor} from "../../../../utils/Color.ts";

export const SKY_TINT_GRADIENT: [number, number][] = [
    [0.0, 0x0a0a2a],   // midnight
    [0.25, 0x0a0a2a],  // still night
    [0.375, 0xffcc88], // dawn
    [0.5, 0x99ccff],   // full day
    [0.75, 0x99ccff],  // hold daylight
    [0.875, 0xff9966], // dusk
    [1.0, 0x0a0a2a],   // back to night
];

export const SPRITE_TINT_GRADIENT: [number, number][] = [
    [0.0, 0x4c5b88],   // deep night
    [0.25, 0x4c5b88],  // night holds
    [0.375, 0xfff2cc], // dawn
    [0.5, 0xffffff],   // full day
    [0.75, 0xffffff],  // hold day
    [0.875, 0xfff2cc], // dusk
    [1.0, 0x4c5b88],   // back to night
];


export function getColorForMinute(
    minute: number,
    total: number,
    gradient: [number, number][]
): number {
    const t = (minute % total) / total;

    for (let i = 0; i < gradient.length - 1; i++) {
        const [t1, c1] = gradient[i];
        const [t2, c2] = gradient[i + 1];

        if (t >= t1 && t <= t2) {
            const factor = (t - t1) / (t2 - t1);
            return lerpColor(c1, c2, factor);
        }
    }

    return gradient[0][1]; // fallback
}


// ---

import {TimeComponent} from "../../../logic/time/TimeComponent.ts";
import {WeatherComponent} from "../../../logic/weather/WeatherComponent.ts";
import {TimeTintPipeline} from "../../../../render/pipelines/TimeTintPipeline.ts";
import {TimeConfig} from "../../../config/TimeConfig.ts";
import {getColorForMinute, SPRITE_TINT_GRADIENT} from "./getColorForMinute.ts";

/**
 * Updates the TimeTintPipeline with time of day, cloud cover, and optional lighting.
 */
export function updateTimeTintPipeline(
    scene: Phaser.Scene,
    time: TimeComponent,
    weather: WeatherComponent
): void {
    const renderer = scene.renderer as Phaser.Renderer.WebGL.WebGLRenderer;
    const pipeline = renderer.pipelines.get('TimeTint') as TimeTintPipeline;

    const minute = time.hour * TimeConfig.MinutesPerHour + time.minute;
    const total = TimeConfig.HoursPerDay * TimeConfig.MinutesPerHour;

    const color = getColorForMinute(minute, total, SPRITE_TINT_GRADIENT);
    pipeline.setTintColor(Phaser.Display.Color.ValueToColor(color));
    pipeline.setCloudAlpha(1 - ((weather.cloudCover ?? 0))*.5);
    pipeline.setResolution(scene.scale.width, scene.scale.height);

    // Optional lighting RT (e.g. scene.lightingRT)
    const lightingRT = (scene as any).lightingRT as Phaser.GameObjects.RenderTexture | undefined;
    const glTex = (lightingRT as any)?._renderer?.glTexture;

    pipeline.setLightingTexture(glTex ?? null);
}


// ---

import { EventBus } from "../../../EventBus";
import { GameEvent } from "../../../consts/GameEvent";
import { UIEvent } from "../../../consts/UIEvent";
import { GameDisplayContext } from "../../GameDisplay";
import { DisplayModule } from "../../setup/DisplayModule";
import { SelectionTool } from "./selection/SelectionTool";
import { TreeCutSelectionTool } from "./trees/TreeCutSelectionTool";

export enum ToolType {
    None = "none",
    Selection = "selection",
    TreeCutting = "tree_cutting"
}

export interface ITool {
    start(): void;
    stop(): void;
    type: ToolType;
}

export type Tool = ITool & DisplayModule<GameDisplayContext>;

export class GameTools extends DisplayModule<GameDisplayContext> {
    private context!: GameDisplayContext;
    private modules: Tool[] = [new SelectionTool(), new TreeCutSelectionTool()];
    private activeTool: ToolType = ToolType.None;
    private awaitingReset: boolean = false;

    init(context: GameDisplayContext): void {
        this.context = context;
        this.modules.forEach(module => {
            module.init(context);
        });

        EventBus.on(UIEvent.ShowPanelCalled, this.handleShowPanelCalled, this);
        EventBus.on(GameEvent.ToolSelected, this.handleToolSelected, this);
        EventBus.emit(GameEvent.ToolSelected, ToolType.Selection);
    }
    handleShowPanelCalled(data: unknown): void {
        if (data == null) {
            this.awaitingReset = true;
        }
    }

    handleToolSelected(toolType: ToolType): void {
        if (this.activeTool == toolType) {
            if (this.activeTool != ToolType.Selection) {
                this.awaitingReset = true;
            }
            return;
        }

        this.activeTool = toolType;

        this.modules.forEach(module => {
            if (module.type === toolType) {
                module.start();
            } else {
                module.stop();
            }
        });
    }

    update(delta: number): void {
        if (this.awaitingReset) {
            EventBus.emit(GameEvent.ToolSelected, ToolType.Selection);
            this.awaitingReset = false;
        }
    }

    destroy(): void {
        // Clean up if necessary
        this.context = null!;
        this.modules.forEach(module => {
            module.destroy();
        });
        EventBus.off(GameEvent.ToolSelected, this.handleToolSelected, this);
        EventBus.off(UIEvent.ShowPanelCalled, this.handleShowPanelCalled, this);
    }
}

// ---

import { DisplayModule } from "../../../setup/DisplayModule.ts";
import { GameDisplayContext } from "../../../GameDisplay.ts";
import { GameEvent } from "../../../../consts/GameEvent.ts";
import { EventBus } from "../../../../EventBus.ts";
import OutlinePipelinePlugin from "phaser3-rex-plugins/plugins/outlinepipeline-plugin.js";

const OUTLINE_CONFIG = {
    thickness: 2,
    outlineColor: 0xd4a857,
    quality: 0.2,
};

export class SelectionHighlightModule extends DisplayModule<GameDisplayContext> {
    private context!: GameDisplayContext;
    private selected: number = -1;
    private outlinePlugin!: OutlinePipelinePlugin;

    init(context: GameDisplayContext): void {
        this.context = context;
        this.outlinePlugin = context.scene.plugins.get('rexOutlinePipeline') as OutlinePipelinePlugin;

        EventBus.on(GameEvent.SelectionChanged, this.handleSelectionChanged, this);
    }

    destroy(): void {
        EventBus.off(GameEvent.SelectionChanged, this.handleSelectionChanged, this);
        this.clearOutline();
    }

    update(): void {}

    private handleSelectionChanged(entity: number): void {
        if (entity === this.selected) return;

        this.clearOutline();
        this.selected = entity;

        if (entity === -1) return;

        const view = this.context.viewsByEntity.get(entity);
        if (!view) return;

        this.outlinePlugin.add(view.viewContainer, OUTLINE_CONFIG);

        EventBus.emit(GameEvent.ViewSelected, view.viewContainer);
    }

    private clearOutline(): void {
        if (this.selected === -1) return;

        const prev = this.context.viewsByEntity.get(this.selected);
        if (prev) {
            this.outlinePlugin.remove(prev.viewContainer);
        }

        this.selected = -1;
    }
}


// ---

import { DisplayModule } from "../../../setup/DisplayModule.ts";
import { GameDisplayContext } from "../../../GameDisplay.ts";
import { GameEvent } from "../../../../consts/GameEvent.ts";
import { EventBus } from "../../../../EventBus.ts";
import { ITool, ToolType } from "../GameTools.ts";
import { UIEvent } from "../../../../consts/UIEvent.ts";
import { ClickThresholdHandler } from "../../../utils/ClickThresholdHandler.ts";
import { AlphaSampler } from "../../../utils/AlphaSampler.ts";

export class SelectionTool extends DisplayModule<GameDisplayContext> implements ITool {
  type: ToolType = ToolType.Selection;
  private context!: GameDisplayContext;
  private cycleStack: number[] = [];
  private cycleIndex = 0;
  private clickHandler!: ClickThresholdHandler;
  private alphaSampler!: AlphaSampler;

  init(context: GameDisplayContext): void {
    this.context = context;
    this.alphaSampler = new AlphaSampler(context.scene);
    this.clickHandler = new ClickThresholdHandler(
      context.scene,
      this.handleClick.bind(this),
      5
    );
  }

  start(): void {
    this.clickHandler.start();
    EventBus.on(UIEvent.PortraitClicked, this.onPortraitClicked, this);
  }

  stop(): void {
    this.clickHandler.stop();
    EventBus.off(UIEvent.PortraitClicked, this.onPortraitClicked, this);
  }

  destroy(): void {
    this.clickHandler.stop();
    this.alphaSampler.destroy();
  }

  update(): void {}

  private onPortraitClicked(selected: number): void {
    EventBus.emit(GameEvent.SelectionChanged, selected);
  }

  private async handleClick(pointer: Phaser.Input.Pointer): Promise<void> {
    const camera = this.context.scene.cameras.main;
    const worldPoint = pointer.positionToCamera(camera) as Phaser.Math.Vector2;

    const allViews = [...this.context.viewsByEntity.entries()];
    const overlapping: number[] = [];

    for (const [entity, view] of allViews) {
      const sprite = view.getSprite();
      if (!view.selectable || !sprite?.input?.enabled) continue;

      const bounds = sprite.getBounds();
      if (!bounds.contains(worldPoint.x, worldPoint.y)) continue;

      const alpha = await this.alphaSampler.getAlphaAt(sprite, worldPoint.x, worldPoint.y);
      if (alpha > 0) {
        overlapping.push(entity);
      }
    }

    overlapping.sort((a, b) => {
      const va = this.context.viewsByEntity.get(a);
      const vb = this.context.viewsByEntity.get(b);
      return (vb?.getSprite()?.depth ?? 0) - (va?.getSprite()?.depth ?? 0);
    });

    if (overlapping.length === 0) {
      this.cycleStack = [];
      this.cycleIndex = 0;
      EventBus.emit(GameEvent.SelectionChanged, -1);
      return;
    }

    const sameStack = arraysEqual(overlapping, this.cycleStack);
    if (!sameStack) {
      this.cycleStack = overlapping;
      this.cycleIndex = 0;
    }

    const selected = this.cycleStack[this.cycleIndex];
    EventBus.emit(GameEvent.SelectionChanged, selected);
    this.cycleIndex = (this.cycleIndex + 1) % this.cycleStack.length;
  }
}

function arraysEqual(a: number[], b: number[]): boolean {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}


// ---

import { DisplayModule } from "../../../setup/DisplayModule.ts";
import { GameDisplayContext } from "../../../GameDisplay.ts";
import { GameEvent } from "../../../../consts/GameEvent.ts";
import { EventBus } from "../../../../EventBus.ts";
import { ITool, ToolType } from "../GameTools.ts";
import { ClickThresholdHandler } from "../../../utils/ClickThresholdHandler.ts";
import { Tree } from "../../../../logic/trees/Tree.ts";
import { AlphaSampler } from "../../../utils/AlphaSampler.ts";

export class TreeCutSelectionTool extends DisplayModule<GameDisplayContext> implements ITool {
  type: ToolType = ToolType.TreeCutting;
  private context!: GameDisplayContext;
  private clickHandler!: ClickThresholdHandler;
  private alphaSampler!: AlphaSampler;

  init(context: GameDisplayContext): void {
    this.context = context;
    this.clickHandler = new ClickThresholdHandler(
      context.scene,
      this.handleClick.bind(this),
      5
    );

    this.alphaSampler = new AlphaSampler(context.scene);
  }

  start(): void {
    this.clickHandler.start();
  }

  stop(): void {
    this.clickHandler.stop();
  }

  destroy(): void {
    this.stop();
    this.alphaSampler.destroy();
  }

  update(): void {}

  private async handleClick(pointer: Phaser.Input.Pointer): Promise<void> {
    const camera = this.context.scene.cameras.main;
    const worldPoint = pointer.positionToCamera(camera) as Phaser.Math.Vector2;
  
    const allViews = [...this.context.viewsByEntity.entries()];
    const overlapping: number[] = [];
  
    for (const [entity, view] of allViews) {
      const sprite = view.getSprite();
      if (!sprite) continue;
      if (!view.selectable || !sprite?.input?.enabled) continue;
  
      const bounds = sprite.getBounds();
      if (!bounds.contains(worldPoint.x, worldPoint.y)) continue;
  
      const alpha = await this.alphaSampler.getAlphaAt(sprite, worldPoint.x, worldPoint.y);
      if (alpha > 0) {
        overlapping.push(entity);
      }
    }
  
    overlapping.sort((a, b) => {
      const va = this.context.viewsByEntity.get(a);
      const vb = this.context.viewsByEntity.get(b);
      return (vb?.getSprite()?.depth ?? 0) - (va?.getSprite()?.depth ?? 0);
    });
  
    if (overlapping.length === 0) return;
  
    const selected = overlapping[0];
    EventBus.emit(GameEvent.TreeSelectedForCutting, selected);
  
    const tree = this.context.ecs.getComponent(selected, Tree);
    if (tree) {
      tree.selectedForCutting = !tree.selectedForCutting;
    }
  }  
}


// ---


import Phaser from "phaser";
import { ECS, Entity } from "../../../ECS";
import { Transform } from "../../../components/Transform";
import { Tree } from "../../../logic/trees/Tree";
import { GameDisplayContext } from "../../GameDisplay";
import { View } from "../../setup/View";
import { ViewDefinition, ViewType } from "../../setup/ViewDefinition";
import { ViewDisplayModule, registerViewDisplayModule } from "../../setup/ViewDisplayModule";
import { EffectType } from "../../setup/ViewEffectController";
import { createView } from "../../setup/ViewStore";

export class TreeCutIconViewModule extends ViewDisplayModule {
  init(context: GameDisplayContext): void {
    registerViewDisplayModule(this, context, context.iconsByEntity);
  }

  update(delta: number): void {
    this.tracker?.update();
  }

  destroy(): void {
    this.tracker?.destroy();
  }

  getComponentClasses(): Function[] {
    return [Transform, Tree];
  }

  getLayerContainer(): Phaser.GameObjects.Container {
    return this.context.layers.Icons;
  }

  getViewsByEntityMap(context: GameDisplayContext) {
    return context.iconsByEntity;
  }

  createDefinition(ecs: ECS, entity: Entity): ViewDefinition {
    const transform = ecs.getComponent(entity, Transform);

    return createView({
      spriteName: "axe_icon",
      position: {
        x: Math.round(transform.x),
        y: Math.round(transform.y),
      },
      frame: 0,
      type: ViewType.ICON,
      size: { x: 0.25, y: 0.25 },
    });
  }

  updateView(ecs: ECS, entity: Entity, view: View): boolean {
    const transform = ecs.getComponent(entity, Transform);
    const tree = ecs.getComponent(entity, Tree);

    view.viewContainer.x = Math.round(transform.x);
    view.viewContainer.y = Math.round(transform.y);

    const sprite = view.getSprite();
    if (sprite) sprite.visible = tree.selectedForCutting;

    return false;
  }

  createView(ecs: ECS, entity: number, views: { [key: number]: ViewDefinition; }, viewDefinition: ViewDefinition): View {
    const view = new View(viewDefinition.id, views, viewDefinition, this.context.layers.Icons, this.context.scene);
    view.applyEffect(EffectType.Red);
    return view;
  }
}


// ---

import Phaser from "phaser";

export interface TreeFallAnimationConfig {
  scene: Phaser.Scene;
  spriteKey: string;
  position: { x: number; y: number };
  size: { x: number; y: number };
  duration: number;
  direction?: number; // 1 or -1
  onComplete?: () => void;
  container?: Phaser.GameObjects.Container;
}

export class TreeFallAnimation {
  private sprite: Phaser.GameObjects.Sprite;
  private scene: Phaser.Scene;
  private tween: Phaser.Tweens.Tween;

  constructor(config: TreeFallAnimationConfig) {
    const { container, scene, spriteKey, position, size, duration, direction = Math.random() < 0.5 ? -1 : 1, onComplete } = config;

    this.scene = scene;
    this.sprite = scene.add.sprite(position.x, position.y, spriteKey);
    container?.add(this.sprite);
    this.sprite.setDisplaySize(size.x, size.y);
    this.sprite.setOrigin(0.5, 1);
    this.sprite.setPipeline("TimeTint");

    const offsetX = direction * 20;
    const rotation = direction * Phaser.Math.DegToRad(90);

    this.tween = scene.tweens.add({
      targets: this.sprite,
      x: position.x + offsetX,
      rotation: rotation,
      duration: duration,
      ease: "Sine.easeOut",
      onComplete: () => {
        onComplete?.();
      }
    });
  }

  setSpeed(speed: number): void {
    this.tween.timeScale = speed;
  }
  
  fadeOut(duration: number, onComplete?: () => void): void {
    this.scene.tweens.add({
      targets: this.sprite,
      alpha: 0,
      duration,
      ease: "Linear",
      onComplete: () => {
        this.sprite.destroy();
        onComplete?.();
      }
    });
  }
}


// ---

import {DisplayModule} from "../../setup/DisplayModule.ts";
import {GameDisplayContext} from "../../GameDisplay.ts";
import {Entity} from "../../../ECS.ts";
import {WeatherComponent} from "../../../logic/weather/WeatherComponent.ts";
import {TimeComponent} from "../../../logic/time/TimeComponent.ts";
import {SimplexNoise} from "../../../../utils/SimplexNoise.ts";
import {ViewType} from "../../setup/ViewDefinition.ts";

export class TreeSwayConfig {
    public static MaxRotation = Phaser.Math.DegToRad(6);
    public static SpatialFrequency = 0.001;
    public static TimeSpeed = 0.001;
}

export class TreeSwayModule extends DisplayModule<GameDisplayContext> {
    private context!: GameDisplayContext;
    private worldEntity!: Entity;
    private time = 0;
    private simplex = new SimplexNoise();

    init(context: GameDisplayContext): void {
        this.context = context;
        this.worldEntity = context.ecs.getEntitiesWithComponent(TimeComponent)[0];
    }

    update(delta: number): void {
        this.time += delta;
        const { ecs, viewsByEntity } = this.context;

        const timeComp = ecs.getComponent(this.worldEntity, TimeComponent);
        const weather = ecs.getComponent(this.worldEntity, WeatherComponent);

        const windStrength = Phaser.Math.Clamp(weather.windStrength ?? 0, 0, 1000) / 1000;
        const speedFactor = timeComp.speedFactor ?? 1;

        const t = this.time * TreeSwayConfig.TimeSpeed * speedFactor;
        const { SpatialFrequency: freq, MaxRotation: maxAngle } = TreeSwayConfig;

        for (const [entity, view] of viewsByEntity) {
            if (view.type !== ViewType.TREE) continue;

            const sprite = view.getSprite() as Phaser.GameObjects.Sprite;

            const sway = this.simplex.noise3D(
                sprite.x * freq,
                sprite.y * freq,
                t + entity * 1000 // phase offset by entity ID
            );

            sprite.rotation = sway * maxAngle * windStrength;
        }
    }


    destroy(): void {
        // Clean up if necessary
        this.context = null!;
        this.worldEntity = null!;
    }
}

// ---

import Phaser from "phaser";
import { ECS, Entity } from "../../../ECS";
import { Config } from "../../../config/Config";
import { Transform } from "../../../components/Transform";
import { Tree } from "../../../logic/trees/Tree";
import { HarvestableComponent } from "../../../logic/trees/HarvestableComponent";
import { View } from "../../setup/View";
import { ViewDefinition, ViewType } from "../../setup/ViewDefinition";
import { ViewDisplayModule, registerViewDisplayModule } from "../../setup/ViewDisplayModule";
import { EffectType } from "../../setup/ViewEffectController";
import { createView as createViewDefinition } from "../../setup/ViewStore";
import { GameDisplayContext } from "../../GameDisplay";
import { ProgressBarConfig, ValueRef } from "../effects/ProgressBar";
import { ShudderEffectConfig } from "../effects/ShudderEffect";
import { TreeFallAnimation } from "./TreeFallAnimation";
import { TimeComponent } from "../../../logic/time/TimeComponent";

const harvestBarConfig: ProgressBarConfig = {
  position: "left",
  offset: 50,
  valueRef: { current: 0, max: 1 },
  size: {
    minWidth: 20,
    maxWidth: 120,
    minWidthValue: 0.1,
    maxWidthValue: 1
  },
  fillColor: 0xffaa00,
  backgroundColor: 0x111111,
  border: {
    color: 0xffffff,
    thickness: 2,
    radius: 6,
    opacity: 0.8
  }
};

export class TreeViewModule extends ViewDisplayModule {
  private harvestRefs: Map<number, ValueRef> = new Map();
  private fallAnimations: Map<number, TreeFallAnimation> = new Map();
  private harvested: Map<number, boolean> = new Map();

  init(context: GameDisplayContext): void {
    registerViewDisplayModule(this, context, context.viewsByEntity);
  }

  update(delta: number): void {
    this.tracker?.update();
  }

  destroy(): void {
    this.tracker?.destroy();
    for (const anim of this.fallAnimations.values()) anim.fadeOut(500);
    this.fallAnimations.clear();
  }

  getComponentClasses(): Function[] {
    return [Transform, Tree, HarvestableComponent];
  }

  getLayerContainer(): Phaser.GameObjects.Container {
    return this.context.layers.Surface;
  }

  createDefinition(ecs: ECS, entity: Entity): ViewDefinition {
    const transform = ecs.getComponent(entity, Transform);
    const tree = ecs.getComponent(entity, Tree);

    return createViewDefinition({
      spriteName: tree.type,
      position: {
        x: Math.round(transform.x),
        y: Math.round(transform.y),
      },
      frame: 0,
      type: ViewType.TREE,
    });
  }

  updateView(ecs: ECS, entity: Entity, view: View): boolean {
    const transform = ecs.getComponent(entity, Transform);
    const tree = ecs.getComponent(entity, Tree);
    const harvestable = ecs.getComponent(entity, HarvestableComponent);

    const posX = Math.round(transform.x);
    const posY = Math.round(transform.y + Config.AnimImports.FrameHeight / 2);
    const isFallen = harvestable.harvested;

    view.viewContainer.x = posX;
    view.viewContainer.y = posY;
    view.viewContainer.scaleY = isFallen ? 0 : 1;

    this.updateHarvestProgress(entity, harvestable, view);
    this.updateShudderEffect(tree, harvestable, view);
    this.spawnFallAnimation(entity, tree, view, posX, posY, isFallen, () => {
      this.fallAnimations.delete(entity);
      this.harvested.set(entity, true);
    });

    const timeEntity = ecs.getEntitiesWithComponent(TimeComponent)[0];
    const time = ecs.getComponent(timeEntity, TimeComponent);
    this.fallAnimations.forEach((anim, _) => {
      const speed = time.speedFactor;
      anim.setSpeed(speed);
    });
    return false;
  }

  private updateHarvestProgress(entity: number, harvestable: HarvestableComponent, view: View): void {
    if (!harvestable.harvested && harvestable.amount !== harvestable.maxAmount) {
      const valueRef = this.harvestRefs.get(entity) || { current: harvestable.amount, max: harvestable.maxAmount };
      valueRef.current = harvestable.amount;
      if (!this.harvestRefs.has(entity)) {
        this.harvestRefs.set(entity, valueRef);
        view.applyEffect(EffectType.Progress, {
          ...harvestBarConfig,
          valueRef,
          container: this.context.layers.Icons
        });
      }
    } else {
      this.harvestRefs.delete(entity);
      view.clearEffect(EffectType.Progress);
      view.clearEffect(EffectType.Shudder);
    }
  }

  private updateShudderEffect(tree: Tree, harvestable: HarvestableComponent, view: View): void {
    if (tree.isBeingCut && harvestable.amount > 0) {
      const fps = view.getSprite()?.scene.game.loop.actualFps || 60;
      view.applyEffect(EffectType.Shudder, {
        duration: 1 * fps,
        interval: 3 * fps,
        strength: 20
      } as ShudderEffectConfig);
    }
  }

  private spawnFallAnimation(entity: number, tree: Tree, view: View, x: number, y: number, isFallen: boolean, onComplete:()=>void): void {
    if (!isFallen || this.fallAnimations.has(entity) || this.harvested.has(entity)) return;

    const spriteKey = tree.type;
    const anim = new TreeFallAnimation({
      container: this.context.layers.Surface,
      scene: this.context.scene,
      spriteKey,
      position: { x, y },
      size: {
        x: view.getSprite()?.displayWidth || 64,
        y: view.getSprite()?.displayHeight || 64
      },
      duration: 400,
      onComplete: () => {
        setTimeout(() => {
          anim.fadeOut(500, onComplete);
        }, 200);
      }
    });

    this.fallAnimations.set(entity, anim);
  }

  createView(ecs: ECS, entity: number, views: { [key: number]: ViewDefinition }, viewDefinition: ViewDefinition): View {
    const view = new View(viewDefinition.id, views, viewDefinition, this.context.layers.Surface, this.context.scene);
    view.applyEffect(EffectType.Shader, { shader: "TimeTint" });
    return view;
  }
}


// ---

import {ViewTracker} from "./ViewTracker.ts";
import {GameDisplayContext} from "../GameDisplay.ts";

export abstract class DisplayModule<T> {
    public abstract init(display: T, trackers?: Array<(context: GameDisplayContext)=>ViewTracker>): void;
    public abstract update(delta: number): void;
    public abstract destroy(): void;
}

// ---

import {Scene} from "phaser";

export class Layers {
    public Sky :Phaser.GameObjects.Container;
    public Ground :Phaser.GameObjects.Container;
    public Caves :Phaser.GameObjects.Container;
    public Surface :Phaser.GameObjects.Container;
    public Icons :Phaser.GameObjects.Container;
    
    constructor(scene:Scene) {
        this.Sky = scene.add.container();
        this.Ground = scene.add.container();
        this.Caves = scene.add.container();
        this.Surface = scene.add.container();
        this.Icons = scene.add.container();
    }
    
    public destroy() {
        this.Sky.destroy();
        this.Ground.destroy();
        this.Caves.destroy();
        this.Surface.destroy();
        this.Icons.destroy();
    }
}

// ---

import {Pos} from "../../../utils/Math.ts";
import {Config} from "../../config/Config.ts";

export const PlantSpriteKeys = ['tree0', 'tree1', 'tree2', 'tree3', 'tree4', 'tree5', 'bush0', 'bush1'] as const;
export type PlantSpriteKey = typeof PlantSpriteKeys[number];
export type HillSpriteKey = 'hill';
export const CaveSpriteKeys = ['cave', 'wood_dojo'] as const;
export type CaveSpriteKey = typeof CaveSpriteKeys[number];
export const CharacterKeys = ['booker_char'] as const;
export type CharacterKey = typeof CharacterKeys[number];
export type SpriteKey = PlantSpriteKey | HillSpriteKey | CaveSpriteKey | CharacterKey;

interface SpriteDefinition {
    key: SpriteKey;
    defaultSize: Pos;
    path?: string;
}

const defaultTreeSize = {x:2, y:2};
const defaultBushSize = {x:1, y:1};
const defaultCaveSize = {x:1, y:1};
const defaultHillSize = {x:1 + Config.GameWidth/Config.Display.PixelsPerUnit, y:Config.GameHeight/Config.Display.PixelsPerUnit};

export const SpriteLibrary: Record<SpriteKey, SpriteDefinition> = {
    tree0: {key: 'tree0', defaultSize: defaultTreeSize, path: 'assets/plants/tree0.png'},
    tree1: {key: 'tree1', defaultSize: defaultTreeSize, path: 'assets/plants/tree1.png'},
    tree2: {key: 'tree2', defaultSize: defaultTreeSize, path: 'assets/plants/tree2.png'},
    tree3: {key: 'tree3', defaultSize: defaultTreeSize, path: 'assets/plants/tree3.png'},
    tree4: {key: 'tree4', defaultSize: defaultTreeSize, path: 'assets/plants/tree4.png'},
    tree5: {key: 'tree5', defaultSize: defaultTreeSize, path: 'assets/plants/tree5.png'},
    bush0: {key: 'bush0', defaultSize: defaultBushSize, path: 'assets/plants/bush0.png'},
    bush1: {key: 'bush1', defaultSize: defaultBushSize, path: 'assets/plants/bush1.png'},
    hill: {key: 'hill', defaultSize: defaultHillSize, path: 'assets/hill/hill.png'},
    cave: {key: 'cave', defaultSize: defaultCaveSize, path: 'assets/hill/cave.png'},
    wood_dojo: {key: 'wood_dojo', defaultSize: defaultCaveSize, path: 'assets/hill/wood_dojo.png'},
    booker_char: {key: 'booker_char', defaultSize: {x: 0.5, y: 0.75}, path: 'assets/characters/booker_char.png'},
};

// ---

import Phaser from "phaser";
import { ViewDefinition, ViewType } from "./ViewDefinition";
import { Naming } from "../../consts/Naming";
import { Config } from "../../config/Config";
import { SpriteKey, SpriteLibrary } from "./SpriteLibrary";
import { EffectType, ViewEffectController } from "./ViewEffectController";

export class View {
  public readonly id: number;
  public readonly viewDefinition: ViewDefinition;
  public readonly viewContainer: Phaser.GameObjects.Container;
  public readonly subViews: View[] = [];

  public type = ViewType.NONE;
  public selectable = true;

  sprite: Phaser.GameObjects.Sprite;
  private readonly effects: ViewEffectController;

  constructor(
    id: number,
    views: { [key: number]: ViewDefinition },
    viewDefinition: ViewDefinition,
    parentContainer: Phaser.GameObjects.Container,
    scene: Phaser.Scene
  ) {
    this.id = id;
    this.viewDefinition = viewDefinition;
    this.type = viewDefinition.type;
    this.selectable = viewDefinition.selectable ?? true;

    viewDefinition.position.x = Math.round(viewDefinition.position.x);
    viewDefinition.position.y = Math.round(viewDefinition.position.y);

    this.viewContainer = scene.add.container(
      viewDefinition.position.x,
      viewDefinition.position.y
    );
    this.viewContainer.name = `${Naming.VIEW}${id}`;
    parentContainer.add(this.viewContainer);

    this.initSprite(scene);

    for (const subViewId of viewDefinition.subViews) {
      const subDef = views[subViewId];
      if (subDef) {
        const subView = new View(
          subViewId,
          views,
          subDef,
          this.viewContainer,
          scene
        );
        this.subViews.push(subView);
      }
    }

    this.effects = new ViewEffectController(this);
  }

  private initSprite(scene: Phaser.Scene): void {
    const { spriteName, frame, size, type } = this.viewDefinition;
    if (!spriteName) return;

    const sprite = scene.add.sprite(0, 0, spriteName);
    sprite.name = `${Naming.SPRITE}${this.id}`;
    this.viewContainer.add(sprite);

    sprite.setOrigin(0.5, type === ViewType.TREE ? 1 : 0.5);
    sprite.setFrame(frame);
    sprite.setInteractive({ useHandCursor: true });

    const defaultSize = SpriteLibrary[spriteName as SpriteKey]?.defaultSize ?? { x: 1, y: 1 };
    const pxPerUnit = Config.Display.PixelsPerUnit;
    sprite.setDisplaySize(
      defaultSize.x * pxPerUnit * size.x,
      defaultSize.y * pxPerUnit * size.y
    );

    this.sprite = sprite;
  }

  public getSprite(): Phaser.GameObjects.Sprite | undefined {
    return this.sprite;
  }

  public syncSprite(spriteName: string): void {
    if (this.viewDefinition.spriteName === spriteName) return;

    this.sprite?.destroy();

    this.viewDefinition.spriteName = spriteName;
    this.initSprite(this.viewContainer.scene);
  }

  public applyEffect(type: EffectType, opts?: any): void {
    this.effects.apply(type, opts);
  }

  public clearEffect(type: EffectType): void {
    this.effects.clear(type);
  }

  public clearAllEffects(): void {
    this.effects.clearAll();
  }

  public update(delta: number): void {
    this.effects.update(delta);
  }

  public sortSubviewsByY(): void {
    const containers = this.viewContainer.list.filter(
      obj => obj instanceof Phaser.GameObjects.Container
    ) as Phaser.GameObjects.Container[];

    containers
      .sort((a, b) => (a.y * a.scaleY - a.height / 2) - (b.y * b.scaleY - b.height / 2))
      .forEach(c => this.viewContainer.bringToTop(c));

    this.subViews.forEach(subView => subView.sortSubviewsByY());
  }

  public destroy(): void {
    this.clearAllEffects();
    this.sprite?.destroy();
    this.viewContainer.destroy();
  }
}

// ---

import {Pos} from "../../../utils/Math.ts";

export enum ViewType {
    NONE = 0,
    TREE = 1,
    CAVE = 2,
    CHARCTER = 3,
    ICON = 4,
}

export enum DisplayTraitType {
    NONE = 0,
    WOOD = 1,
    FOOD = 2
}

export enum PanelType {
    CHARACTER = "CHARACTER",
    WOOD_DOJO = "WOOD_DOJO",
    TREE = "TREE",
    CAVE = "CAVE"
}

export class DisplayTrait {
    public type: DisplayTraitType;
    public value: number;
}

export class PanelDefinition {
    public title:string;
    public description:string;
    public imagePath:string;
    public traits?: DisplayTrait[];
    actions?: PanelActionDefinition[];
    panelType: PanelType;
}

export interface PanelActionDefinition {
    label: string;
    type: string;
}

export class ViewDefinition {
    public readonly id: number;
    public spriteName: string;
    public readonly position: Pos;
    public readonly size: Pos;
    public frame: number;
    public subViews: number[];
    public type = ViewType.NONE;
    public selectable = true;
    public panelDefinition?: PanelDefinition;
}



// ---

import { ViewTracker } from "./ViewTracker";
import { ECS, Entity } from "../../ECS";
import { View } from "../setup/View";
import { ViewDefinition } from "../setup/ViewDefinition";
import { GameDisplayContext } from "../GameDisplay";
import { DisplayModule } from "./DisplayModule";

export abstract class ViewDisplayModule implements DisplayModule<GameDisplayContext> {
    tracker!: ViewTracker;
    context!: GameDisplayContext;
  
    abstract getComponentClasses(): Function[];
  
    abstract createDefinition(ecs: ECS, entity: Entity): ViewDefinition;
  
    abstract updateView(ecs: ECS, entity: Entity, view: View): boolean;
  
    abstract createView(ecs: ECS, entity: Entity, views: { [key: number]: ViewDefinition }, viewDefinition: ViewDefinition): View;
  
    abstract getLayerContainer(): Phaser.GameObjects.Container;
  
    abstract init(context: GameDisplayContext): void;
  
    abstract update(delta: number): void;
  
    abstract destroy(): void;
  
    static getReactCoordsFromPhaser(
      container: Phaser.GameObjects.Container,
      camera: Phaser.Cameras.Scene2D.Camera
    ): { x: number; y: number } {
      const x = (container.x - camera.worldView.x) * camera.zoom;
      const y = (container.y - camera.worldView.y) * camera.zoom;
      const canvas = camera.scene.sys.game.canvas;
      return {
        x: Phaser.Math.Clamp(x, 0, canvas.width),
        y: Phaser.Math.Clamp(y, 0, canvas.height),
      };
    }
  }
  

export function registerViewDisplayModule(
    module: ViewDisplayModule,
    context: GameDisplayContext,
    viewsByEntity: Map<Entity, View>
  ): void {
    module.context = context;
    module.tracker = new ViewTracker({
      viewsByEntity,
      ecs: context.ecs,
      scene: context.scene,
      componentClasses: module.getComponentClasses(),
      layerContainer: module.getLayerContainer(),
      createDefinition: module.createDefinition.bind(module),
      updateView: module.updateView.bind(module),
      createView: module.createView.bind(module)
    });
  
    module.tracker.init();
    module.tracker.update();
  }
  

// ---

import { ProgressBar, ProgressBarConfig } from "../game/effects/ProgressBar";
import { ShudderEffect, ShudderEffectConfig } from "../game/effects/ShudderEffect";
import { View } from "./View";

export interface EffectInstance {
  start(): void;
  stop(): void;
  update?(delta: number): void;
}

export enum EffectType {
  Red = "red",
  Highlight = "highlight",
  Shader = "shader",
  Shake = "shake",
  Progress = "progress",
  Shudder = "shudder",
}

export type ProgressBarOptions = ProgressBarConfig & { container: Phaser.GameObjects.Container };

export class ViewEffectController {
  private readonly view: View;
  private readonly active: Map<EffectType, EffectInstance> = new Map();

  constructor(view: View) {
    this.view = view;
  }

  apply(type: EffectType, opts?: Record<string, any>): void {
    if (this.active.has(type)) return;

    let instance: EffectInstance | undefined;

    switch (type) {
      case EffectType.Red:
        instance = this.makeRed(opts);
        break;
      case EffectType.Highlight:
        instance = this.makeRed(opts);
        break;
      case EffectType.Shader:
        instance = this.makeShader(opts);
        break;
      case EffectType.Shake:
        instance = this.makeShake(opts);
        break;
      case EffectType.Progress:
        instance = this.makeProgress(opts as ProgressBarOptions);
        break;
      case EffectType.Shudder:
        instance = new ShudderEffect(this.view, opts as ShudderEffectConfig);
        break;
    }

    if (instance) {
      this.active.set(type, instance);
      instance.start();
    }
  }

  clear(type: EffectType): void {
    const effect = this.active.get(type);
    if (effect) {
      effect.stop();
      this.active.delete(type);
    }
  }

  clearAll(): void {
    for (const effect of this.active.values()) {
      effect.stop();
    }
    this.active.clear();
  }

  update(delta: number): void {
    for (const effect of this.active.values()) {
      effect.update?.(delta);
    }
  }

  private makeShake(opts?: Record<string, any>): EffectInstance {
    const sprite = this.view.getSprite?.();
    if (!sprite) return { start: () => {}, stop: () => {} };

    const tween = sprite.scene.tweens.add({
      targets: sprite,
      scale: { from: 1, to: opts?.scale ?? 1.15 },
      yoyo: true,
      duration: opts?.duration ?? 200,
      repeat: opts?.repeat ?? 0,
    });

    return {
      start: () => {},
      stop: () => tween.stop(),
    };
  }

  private makeRed(opts?: Record<string, any>): EffectInstance {
    const sprite = this.view.getSprite?.();
    if (!sprite) return { start: () => {}, stop: () => {} };

    const tint = opts?.color ?? 0xff0000;

    return {
      start: () => sprite.setTint(tint),
      stop: () => sprite.clearTint(),
    };
  }

  private makeShader(opts?: Record<string, any>): EffectInstance {
    const sprite = this.view.getSprite?.();
    if (!sprite) return { start: () => {}, stop: () => {} };

    const shader = opts?.shader ?? "TimeTint";

    return {
      start: () => sprite.setPipeline(shader),
      stop: () => sprite.resetPipeline(),
    };
  }

  private makeProgress(config: ProgressBarOptions): EffectInstance {
    const bar = new ProgressBar(config.container, config);
  
    return {
      start: bar.show.bind(bar),
      stop: bar.hide.bind(bar),
      update: (delta: number) => bar.update(delta, this.view.viewDefinition.position)
    };
  }
}


// ---

import {DisplayTraitType, PanelDefinition, PanelType, ViewDefinition, ViewType} from "./ViewDefinition.ts";

export type ViewMap = Record<number, ViewDefinition>;

let nextId = 1;
let viewMap: ViewMap = {};

const panelDefinitions: Record<ViewType, PanelDefinition> = {
    [ViewType.TREE]: {
        title: "Tree",
        description: "A lush forest tree. May sway in the wind.",
        imagePath: "assets/panels/tree_panel.png",
        traits: [
            { type: DisplayTraitType.WOOD, value: 10 },
            { type: DisplayTraitType.FOOD, value: 5 },
        ],
        panelType: PanelType.TREE,
    },
    [ViewType.CAVE]: {
        title: "Cave",
        description: "A dark cave entrance. Mysterious and unexplored.",
        imagePath: "assets/panels/cave_panel.png",
        panelType: PanelType.CAVE
    },
    [ViewType.NONE]: {
        title: "",
        description: "",
        imagePath: "",
    } ,
    [ViewType.CHARCTER]: {
        title: "Character",
        description: "Some character",
        imagePath: "",
        panelType: PanelType.CHARACTER
    } 
} as Record<ViewType, PanelDefinition>;

export function createView(def: Partial<ViewDefinition>): ViewDefinition {
    const id = nextId++;
    const type = def.type ?? ViewType.NONE;

    const view: ViewDefinition = {
        id,
        spriteName: def.spriteName ?? ``,
        position: def.position ?? { x: 0, y: 0 },
        size: def.size ?? { x: 1, y: 1 },
        frame: def.frame ?? 0,
        subViews: [],
        type,
        selectable: def.selectable !== false,
        panelDefinition: def.panelDefinition ?? panelDefinitions[type],
        ...def,
    } as ViewDefinition;

    viewMap[id] = view;
    return view;
}

export function getView(id: number): ViewDefinition | undefined {
    return viewMap[id];
}

export function getViews(): ViewMap {
    return viewMap;
}

export function clearViews() {
    viewMap = {};
    nextId = 1;
}


// ---

import Phaser from "phaser";
import { ECS, Entity } from "../../ECS.ts";
import { View } from "./View.ts";
import { ViewDefinition } from "./ViewDefinition.ts";
import { getViews } from "./ViewStore.ts";
import { Pos } from "../../../utils/Math.ts";

export interface ViewTrackerOptions {
    ecs: ECS;
    scene: Phaser.Scene;
    componentClasses: Function[];
    layerContainer: Phaser.GameObjects.Container;
    createDefinition: (ecs: ECS, entity: Entity) => ViewDefinition;
    updateView: (ecs: ECS, entity: Entity, view: View) => boolean;
    createView: (ecs: ECS, entity: Entity,
        views: { [key: number]: ViewDefinition },
        viewDefinition: ViewDefinition) => View;
    viewsByEntity: Map<Entity, View>; //  Shared view map
}

export class ViewTracker {
    private viewsByEntity: Map<Entity, View>;
    private viewsLocal = new Map<Entity, View>();
    private firstRun = true;

    private ecs: ECS;
    private componentClasses: Function[];
    private layerContainer: Phaser.GameObjects.Container;
    private createDefinition: (ecs: ECS, entity: Entity) => ViewDefinition;
    private updateView: (ecs: ECS, entity: Entity, view: View) => boolean;
    createView: ((ecs: ECS, entity: Entity,views: { [key: number]: ViewDefinition; }, viewDefinition: ViewDefinition) => View);

    constructor({
                    ecs,
                    componentClasses,
                    layerContainer,
                    createDefinition,
                    updateView,
                    createView,
                    viewsByEntity
                }: ViewTrackerOptions) {
        this.ecs = ecs;
        this.componentClasses = componentClasses;
        this.layerContainer = layerContainer;
        this.createDefinition = createDefinition;
        this.updateView = updateView;
        this.createView = createView;
        this.viewsByEntity = viewsByEntity;
    }

    public init() {
        this.viewsLocal.clear();
        this.firstRun = true;
    }

    public update() {
        const entityList = this.ecs.getEntitiesWithComponents(this.componentClasses);
        const currentSet = new Set<Entity>(entityList);
        let changed = this.firstRun;

        // Remove destroyed entities
        for (const [entity, view] of this.viewsLocal) {
            if (!currentSet.has(entity)) {
                view.viewContainer.destroy();
                this.viewsLocal.delete(entity);
                this.viewsByEntity.delete(entity); //  global map cleanup
                changed = true;
            }
        }

        // Add newly created entities
        for (const entity of entityList) {
            if (!this.viewsLocal.has(entity)) {
                const def = this.createDefinition(this.ecs, entity);
                const view = this.createView(this.ecs, entity, getViews(), def);
                this.viewsLocal.set(entity, view);
                this.viewsByEntity.set(entity, view); //  global map update
                changed = true;
            }
        }

        // Update all tracked views
        for (const [entity, view] of this.viewsLocal) {
            if (this.updateView(this.ecs, entity, view)) {
                changed = true;
            }
        }

        if (changed) {
            const sorted = this.layerContainer.list
                .filter(obj => obj instanceof Phaser.GameObjects.Container)
                .map(obj => obj as Phaser.GameObjects.Container)
                .sort((a, b) => (a.y - b.y));

            sorted.forEach(c => this.layerContainer.bringToTop(c));
        }

        this.firstRun = false;
    }

    public destroy() {
        for (const view of this.viewsLocal.values()) {
            view.viewContainer.destroy();
        }
        for (const entity of this.viewsLocal.keys()) {
            this.viewsByEntity.delete(entity);
        }
        this.viewsLocal.clear();
    }

    public static getReactCoordsFromPhaser(
        container: Phaser.GameObjects.Container,
        camera: Phaser.Cameras.Scene2D.Camera
      ): Pos {
        const x = (container.x - camera.worldView.x) * camera.zoom;
        const y = (container.y - camera.worldView.y) * camera.zoom;
      
        const canvas = camera.scene.sys.game.canvas;
        const maxX = canvas.width;
        const maxY = canvas.height;
      
        return {
          x: Phaser.Math.Clamp(x, 0, maxX),
          y: Phaser.Math.Clamp(y, 0, maxY),
        };
    }
}


// ---

export class AlphaSampler {
  private rt: Phaser.GameObjects.RenderTexture;

  constructor(scene: Phaser.Scene) {
    this.rt = scene.add.renderTexture(0, 0, 1, 1).setVisible(false);
  }

  async getAlphaAt(sprite: Phaser.GameObjects.Sprite, worldX: number, worldY: number): Promise<number> {
    if (!sprite.texture || !sprite.frame) return 0;

    const originOffsetX = sprite.displayOriginX;
    const originOffsetY = sprite.displayOriginY;
    
    const local = sprite.getWorldTransformMatrix().applyInverse(worldX, worldY);
    const tx = Math.floor(local.x + originOffsetX);
    const ty = Math.floor(local.y + originOffsetY);
    
    if (tx < 0 || ty < 0 || tx >= sprite.width || ty >= sprite.height) return 0;

    this.rt.clear();
    this.rt.drawFrame(sprite.texture.key, sprite.frame.name, -tx, -ty);

    return new Promise<number>((resolve) => {
      this.rt.snapshotPixel(0, 0, (color) => {
        'alpha' in color && resolve(color?.alpha ?? 0);
      });
    });
  }

  destroy(): void {
    this.rt.destroy();
  }
}


// ---

export type ClickCallback = (pointer: Phaser.Input.Pointer) => void;

export class ClickThresholdHandler {
  private threshold: number;
  private downPos: Phaser.Math.Vector2 | null = null;
  private scene: Phaser.Scene;
  private onClick: ClickCallback;

  constructor(scene: Phaser.Scene, onClick: ClickCallback, threshold = 5) {
    this.scene = scene;
    this.onClick = onClick;
    this.threshold = threshold;
  }

  start(): void {
    this.scene.input.on('pointerdown', this.onPointerDown, this);
    this.scene.input.on('pointerup', this.onPointerUp, this);
  }

  stop(): void {
    this.scene.input.off('pointerdown', this.onPointerDown, this);
    this.scene.input.off('pointerup', this.onPointerUp, this);
  }

  private onPointerDown(pointer: Phaser.Input.Pointer): void {
    this.downPos = pointer.position.clone();
  }

  private onPointerUp(pointer: Phaser.Input.Pointer): void {
    if (!this.downPos) return;

    const upPos = pointer.position;
    const distance = Phaser.Math.Distance.BetweenPoints(this.downPos, upPos);
    this.downPos = null;

    if (distance <= this.threshold) {
      this.onClick(pointer);
    }
  }
}


// ---

import Container = Phaser.GameObjects.Container;

export function sortContainerByY(container: Container) {
    const sorted = container.list
        .filter(obj => obj instanceof Container)
        .sort((a, b) => {
            const aC = a as Container;
            const bC = b as Container;

            const aBottom = (aC.y + aC.height * aC.scaleY)
            const bBottom = bC.y + bC.height * bC.scaleY;

            return aBottom - bBottom;
        });

    sorted.forEach(c => container.bringToTop(c));
}


// ---

import Phaser from 'phaser';
import {Pos} from "../../../utils/Math.ts";

export function worldToLocal(container: Phaser.GameObjects.Container, worldPos: Pos): Pos {
    const matrix = container.getWorldTransformMatrix();
    const inverse = new Phaser.GameObjects.Components.TransformMatrix();
    matrix.copyToContext(inverse as any); // hacky but safe in Phaser 3
    inverse.invert();

    const out = new Phaser.Math.Vector2();
    inverse.transformPoint(worldPos.x, worldPos.y, out);
    return { x: out.x, y: out.y };
}


// ---

import { Component } from "../../ECS";
import { CharacterIntent, CharacterAction } from "./actionIntentData";

/**
 * ActionIntentComponent stores a character's high-level intent and their
 * current, concrete performed action. Data specific to the current action
 * is stored in the `actionData` payload.
 */
export class ActionIntentComponent extends Component {
    /** The character's current high-level goal or scheduled task. */
    public intentType: CharacterIntent = CharacterIntent.NONE;

    /** The specific, observable action the character is currently performing. */
    public currentPerformedAction: CharacterAction = CharacterAction.IDLE;
        
    /** * Holds data specific to the `currentPerformedAction`. 
     * Its structure is determined by the action (e.g., WalkingData, ChoppingData).
     * Managed by IntentActionSystem (and its helpers). Should be null if no data needed.
     */
    public actionData: any | null = null;

    constructor(initialIntent: CharacterIntent = CharacterIntent.NONE) {
        super();
        this.intentType = initialIntent;
    }
}

// ---

import { System, Entity } from "../../ECS";
import { ActionIntentComponent } from "./ActionIntentComponent";
import { CharacterIntent, CharacterAction } from "./actionIntentData";
import { handleHarvestIntentLogic } from "./intent-handlers/handleHarvestIntentLogic";
import { handleRestIntentLogic } from "./intent-handlers/handleRestIntentLogic";
import { handleSleepIntentLogic } from "./intent-handlers/handleSleepIntentLogic";

export class ActionIntentSystem extends System {
    public componentsRequired = new Set<Function>([ActionIntentComponent]);

    public update(entities: Set<Entity>, delta: number): void {
        for (const entity of entities) {
            const actionIntent = this.ecs.getComponent(entity, ActionIntentComponent);
            const currentIntent = actionIntent.intentType;

            switch (currentIntent) {
                case CharacterIntent.HARVEST:
                    handleHarvestIntentLogic(this.ecs, entity, actionIntent);
                    break;
                case CharacterIntent.SLEEP:
                    handleSleepIntentLogic(this.ecs, entity, actionIntent);
                    break;
                case CharacterIntent.REST:
                    handleRestIntentLogic(this.ecs, entity, actionIntent);
                    break;
                default:
                    actionIntent.currentPerformedAction = CharacterAction.IDLE;
                    actionIntent.actionData = null;
                    break;
            }
        }
    }
}

// ---

import { Entity, System } from "../../ECS";
import { ActiveBuffsComponent } from "../buffs/ActiveBuffsComponent";
import { BuffType } from "../buffs/buffsData";
import { DormitoryComponent } from "../buildings/dormitory/DormitoryComponent";
import { HomeComponent } from "../buildings/dormitory/HomeComponent";
import { WoodDojo } from "../buildings/wood_dojo/WoodDojo";
import { TimeComponent } from "../time/TimeComponent";
import { ActionIntentComponent } from "./ActionIntentComponent";
import { StrollComponent } from "./StrollComponent";
import { CharacterIntent } from "./actionIntentData";


export class RelaxBehaviorSystem extends System {
    public componentsRequired = new Set<Function>([
        ActionIntentComponent
    ]);

    public update(entities: Set<Entity>, delta: number): void {
        for (const entity of entities) {
            const actionIntent = this.ecs.getComponent(entity, ActionIntentComponent);
            const hasStrollComponent = this.ecs.hasComponent(entity, StrollComponent);

            if (actionIntent.intentType === CharacterIntent.REST) {
                if (!hasStrollComponent) {
                    // Intent is REST, but not yet strolling. Initiate stroll.
                    const referencePointEntityId: Entity | null = this.getStrollRefPointEntityId(entity);

                    if (referencePointEntityId !== null) {
                        this.ecs.addComponent(entity, new StrollComponent(referencePointEntityId));
                        const buffs = this.ecs.getComponent(entity, ActiveBuffsComponent);
                        const time = this.ecs.getComponent(this.ecs.getEntitiesWithComponent(TimeComponent)[0], TimeComponent);
                        
                        buffs?.addBuff(BuffType.STROLL_SPEED, time.minutesElapsed);
                    }
                }
                // If already has StrollComponent and intent is REST, StrollSystem/handleRestIntentLogic manages it.
            } else {
                // Intent is NOT REST. If character was strolling, clean up.
                if (hasStrollComponent) {
                    this.ecs.removeComponent(entity, StrollComponent);
                    const buffs = this.ecs.getComponent(entity, ActiveBuffsComponent);
                    buffs?.removeBuff(BuffType.STROLL_SPEED);
                }
            }
        }
    }

    private getStrollRefPointEntityId(entity: number) {
        const home = this.ecs.getComponent(entity, HomeComponent);
        if (home && home.homeEntityId !== null && this.ecs.hasEntity(home.homeEntityId)) {
            return home.homeEntityId;
        } else {
            const dorms = this.ecs.getEntitiesWithComponent(DormitoryComponent);
            if (dorms.length > 0) return dorms[0];
            else {
                const dojos = this.ecs.getEntitiesWithComponent(WoodDojo);
                if (dojos.length > 0) return dojos[0];
            }
        }
        return null;
    }
}

// ---

import { Pos } from "../../../utils/Math";
import { Component, Entity } from "../../ECS";

export class StrollComponent extends Component {
    public referencePointEntityId: Entity;
    public currentPathTargetPos?: Pos;
    public currentTargetTreeId?: Entity;
    public lastTargetTreeId?: Entity;
    public isPausedAtTarget: boolean = false;
    public pauseUntilTime: number = 0; 

    constructor(
        referencePointEntityId: Entity,
        initialTargetTreeId?: Entity,
        initialPathTargetPos?: Pos
    ) {
        super();
        this.referencePointEntityId = referencePointEntityId;
        this.currentTargetTreeId = initialTargetTreeId;
        this.currentPathTargetPos = initialPathTargetPos;
    }
}

// ---

import { Entity } from "../../ECS";
import { Pos } from "../../../utils/Math";

/** Defines the high-level goal or scheduled task for a character. */
export enum CharacterIntent {
    NONE = 0,
    HARVEST = 1,
    BUILD = 2,
    SLEEP = 3,
    REST = 4,
    STUDY = 5,
}

/** Defines the concrete, observable, low-level action a character is currently performing. */
export enum CharacterAction {
    IDLE = "Idle",
    WALKING = "Walking",
    CHOPPING = "Chopping",
    BUILDING = "Building",
    STUDYING = "Studying",
    SLEEPING = "Sleeping",
    STROLLING = "Strolling", // Covers walking during stroll and pausing at stroll points
    RELAXING = "Relaxing",
    NONE = "None",
}

/** Enum to discriminate between different actionData payload structures. */
export enum ActionDataType {
    WalkingData,
    ChoppingData,
    SleepingData,
    StrollingAtPointData,
}

// --- Payload Interfaces for ActionIntentComponent.actionData ---
export interface WalkingData {
    readonly type: ActionDataType.WalkingData;
    targetPosition: Pos;
    ultimateTargetEntityId?: Entity;
}

export interface ChoppingData {
    readonly type: ActionDataType.ChoppingData;
    targetTreeEntityId: Entity;
}

export interface SleepingData {
    readonly type: ActionDataType.SleepingData;
    bedEntityId: Entity;
    slotOffset: Pos;
}

export interface StrollingAtPointData {
    readonly type: ActionDataType.StrollingAtPointData;
    atTreeEntityId: Entity; // The tree/point they are currently at
}


// --- Type Guards for ActionData Payloads ---

export function isWalkingData(data: any): data is WalkingData {
    return data?.type === ActionDataType.WalkingData &&
           data.targetPosition !== undefined;
}

export function isChoppingData(data: any): data is ChoppingData {
    return data?.type === ActionDataType.ChoppingData &&
           typeof data.targetTreeEntityId === 'number';
}

export function isSleepingData(data: any): data is SleepingData {
    return data?.type === ActionDataType.SleepingData;
}

export function isStrollingAtPointData(data: any): data is StrollingAtPointData {
    return data?.type === ActionDataType.StrollingAtPointData;
}

// ---

import { ECS, Entity } from "../../../ECS";
import { ActionIntentComponent } from "../ActionIntentComponent";
import {
    CharacterAction,
    ActionDataType,
    WalkingData,
    ChoppingData,
    CharacterIntent
} from "../actionIntentData";
import { Transform } from "../../../components/Transform";
import { HarvesterComponent } from "../../trees/HarvesterComponent";
import { Tree } from "../../trees/Tree";
import { HarvestableComponent } from "../../trees/HarvestableComponent";
import { InteractionSlots, SlotType } from "../../../components/InteractionSlots";
import { Pos } from "../../../../utils/Math";

function setIdle(aic: ActionIntentComponent): void {
    aic.currentPerformedAction = CharacterAction.IDLE;
    aic.actionData = null;
}

function setWaitingOrBlocked(aic: ActionIntentComponent): void {
    aic.intentType = CharacterIntent.REST;
    aic.currentPerformedAction = CharacterAction.IDLE; 
    aic.actionData = null;
}

function setWalkingToSlot(aic: ActionIntentComponent, targetPosition: Pos, ultimateTargetId: Entity): void {
    aic.currentPerformedAction = CharacterAction.WALKING;
    aic.actionData = {
        type: ActionDataType.WalkingData,
        targetPosition,
        ultimateTargetEntityId: ultimateTargetId
    } as WalkingData;
}

function setChopping(aic: ActionIntentComponent, treeId: Entity): void {
    aic.currentPerformedAction = CharacterAction.CHOPPING;
    aic.actionData = {
        type: ActionDataType.ChoppingData,
        targetTreeEntityId: treeId
    } as ChoppingData;
}

function isTreeValidForHarvest(ecs: ECS, treeId: Entity): boolean {
    if (!ecs.hasEntity(treeId)) return false;
    const tree = ecs.getComponent(treeId, Tree);
    const harvestable = ecs.getComponent(treeId, HarvestableComponent);
    return !!(tree && tree.selectedForCutting && harvestable && harvestable.harvestable && !harvestable.harvested);
}

function releaseAnyWorkSlotHeldByCharacter(ecs: ECS, characterEntity: Entity): void {
    const allTreesWithSlots = ecs.getEntitiesWithComponents([Tree, InteractionSlots]);
    for (const treeId of allTreesWithSlots) {
        ecs.getComponent(treeId, InteractionSlots)?.release(characterEntity, SlotType.WORK);
    }
}

function findAndReserveNewHarvestTarget(ecs: ECS, characterEntity: Entity): { treeId: Entity, slotOffset: Pos, treeTransform: Transform } | null {
    releaseAnyWorkSlotHeldByCharacter(ecs, characterEntity);
    const allTrees = ecs.getEntitiesWithComponents([Tree, HarvestableComponent, InteractionSlots, Transform]);

    for (const treeId of allTrees) {
        if (isTreeValidForHarvest(ecs, treeId)) {
            const slots = ecs.getComponent(treeId, InteractionSlots);
            const offset = slots.reserve(characterEntity, SlotType.WORK);
            if (offset) {
                return { treeId, slotOffset: offset, treeTransform: ecs.getComponent(treeId, Transform) };
            }
        }
    }
    return null;
}

export function canHarvest(ecs: ECS, entity: Entity): boolean {
    const allTrees = ecs.getEntitiesWithComponents([Tree, HarvestableComponent, InteractionSlots]);
    for (const treeId of allTrees) {
        if (isTreeValidForHarvest(ecs, treeId)) {
            const slots = ecs.getComponent(treeId, InteractionSlots);
            // Check if ANY work slot is available, without reserving it.
            if (slots.getSlotsArray(SlotType.WORK).some(slot => slot.occupiedBy === null || slot.occupiedBy === entity)) {
                return true;
            }
        }
    }
    return false;
}


export function handleHarvestIntentLogic(
    ecs: ECS,
    entity: Entity,
    actionIntent: ActionIntentComponent
): void {
    const characterTransform = ecs.getComponent(entity, Transform);
    const harvester = ecs.getComponent(entity, HarvesterComponent);

    if (!characterTransform || !harvester) return setIdle(actionIntent);

    const targetInfo = findAndReserveNewHarvestTarget(ecs, entity);

    if (!targetInfo) {
        setWaitingOrBlocked(actionIntent,);
        return;
    }
    
    const { treeId, slotOffset, treeTransform } = targetInfo;
    const exactApproachPosition = { 
        x: Math.round(treeTransform.x + slotOffset.x), 
        y: Math.round(treeTransform.y + slotOffset.y) 
    };
    
    const roundedCharX = Math.round(characterTransform.x);
    const roundedCharY = Math.round(characterTransform.y);

    if (roundedCharX !== exactApproachPosition.x || roundedCharY !== exactApproachPosition.y) {
        setWalkingToSlot(actionIntent, exactApproachPosition, treeId);
    } else {
        // Arrived at the designated WORK slot for the target tree.
        setChopping(actionIntent, treeId);
    }
}

// ---

import { Pos, MathUtils } from "../../../../utils/Math";
import { Entity, ECS } from "../../../ECS";
import { Transform } from "../../../components/Transform";
import { LocomotionComponent } from "../../locomotion/LocomotionComponent";
import { TimeComponent } from "../../time/TimeComponent";
import { Tree } from "../../trees/Tree";
import { ActionIntentComponent } from "../ActionIntentComponent";
import { StrollComponent } from "../StrollComponent";
import { CharacterAction, ActionDataType, WalkingData, StrollingAtPointData, isWalkingData, CharacterIntent } from "../actionIntentData";

const STROLL_BEHIND_TREE_OFFSET = 30;
const MAX_CANDIDATE_TREES_FOR_RANDOM_STROLL = 5;
const MIN_PAUSE_DURATION_GAME_MINUTES = 2; // e.g., 2 game minutes
const MAX_PAUSE_DURATION_GAME_MINUTES = 5; // e.g., 5 game minutes

function setIdle(aic: ActionIntentComponent): void {
    aic.intentType = CharacterIntent.NONE;
    aic.currentPerformedAction = CharacterAction.IDLE;
    aic.actionData = null;
}

function setRelaxing(aic: ActionIntentComponent): void {
    aic.currentPerformedAction = CharacterAction.RELAXING;
    aic.actionData = null;
}

function setWalkingToStrollPoint(aic: ActionIntentComponent, targetPosition: Pos, treeId?: Entity): void {
    aic.currentPerformedAction = CharacterAction.WALKING;
    aic.actionData = {
        type: ActionDataType.WalkingData,
        targetPosition,
        ultimateTargetEntityId: treeId
    } as WalkingData;
}

function setStrollingAtPoint(aic: ActionIntentComponent, treeId: Entity): void {
    aic.currentPerformedAction = CharacterAction.STROLLING;
    aic.actionData = {
        type: ActionDataType.StrollingAtPointData,
        atTreeEntityId: treeId
    } as StrollingAtPointData;
}

function findValidStrollTrees(ecs: ECS, excludeTreeId?: Entity): { id: Entity, transform: Transform }[] {
    const treeEntities = ecs.getEntitiesWithComponents([Tree, Transform]);
    const validTrees: { id: Entity, transform: Transform }[] = [];
    for (const treeId of treeEntities) {
        if (treeId === excludeTreeId) continue;
        validTrees.push({ id: treeId, transform: ecs.getComponent(treeId, Transform) });
    }
    return validTrees;
}

function selectNextStrollTarget(
    ecs: ECS,
    currentPosOrReferenceTransform: Transform,
    referenceTransformForOrientation: Transform,
    lastTargetTreeId?: Entity
): { treeId: Entity, strollTargetPos: Pos } | null {
    const availableTrees = findValidStrollTrees(ecs, lastTargetTreeId);
    if (availableTrees.length === 0) return null;

    const candidates = availableTrees.map(t => ({
        id: t.id,
        transform: t.transform,
        distSq: MathUtils.distance(currentPosOrReferenceTransform, t.transform) ** 2
    })).sort((a, b) => a.distSq - b.distSq);

    if (candidates.length === 0) return null;
    const selectionPool = candidates.slice(0, MAX_CANDIDATE_TREES_FOR_RANDOM_STROLL);
    const chosenTreeInfo = selectionPool[Math.floor(Math.random() * selectionPool.length)];
    
    const strollTargetPos = calculateBehindTreePosition(chosenTreeInfo.transform, referenceTransformForOrientation);
    return { treeId: chosenTreeInfo.id, strollTargetPos };
}

function calculateBehindTreePosition(treePos: Pos, referencePos: Pos): Pos {
    const dirVector = MathUtils.normalize(MathUtils.subtract(treePos, referencePos));
    if (dirVector.x === 0 && dirVector.y === 0) {
        return { x: treePos.x + STROLL_BEHIND_TREE_OFFSET, y: treePos.y };
    }
    return MathUtils.add(treePos, MathUtils.multiply(dirVector, STROLL_BEHIND_TREE_OFFSET));
}

export function handleRestIntentLogic(
    ecs: ECS,
    entity: Entity,
    actionIntent: ActionIntentComponent
    // deltaTimeMs is removed
): void {
    const locomotion = ecs.getComponent(entity, LocomotionComponent);
    const strollComp = ecs.getComponent(entity, StrollComponent);
    const characterTransform = ecs.getComponent(entity, Transform);

    if (!locomotion || !characterTransform) return setIdle(actionIntent);
    if (!strollComp) return setRelaxing(actionIntent);

    const worldTimeEntity = ecs.getEntitiesWithComponent(TimeComponent)[0];
    if (!worldTimeEntity) return setRelaxing(actionIntent); // Cannot manage pause without time
    const time = ecs.getComponent(worldTimeEntity, TimeComponent);
    const currentGameTime = time.minutesElapsed;

    if (strollComp.isPausedAtTarget) {
        if (currentGameTime >= strollComp.pauseUntilTime) {
            strollComp.isPausedAtTarget = false;
            strollComp.lastTargetTreeId = strollComp.currentTargetTreeId;
            strollComp.currentTargetTreeId = undefined;
            strollComp.currentPathTargetPos = undefined;
        } else {
            if (strollComp.currentTargetTreeId) {
                setStrollingAtPoint(actionIntent, strollComp.currentTargetTreeId);
            } else { 
                setRelaxing(actionIntent);
            }
            return;
        }
    }

    if (!strollComp.currentPathTargetPos || !strollComp.currentTargetTreeId) {
        const referenceTransform = ecs.getComponent(strollComp.referencePointEntityId, Transform);
        if (!referenceTransform) {
            ecs.removeComponent(entity, StrollComponent);
            return setRelaxing(actionIntent);
        }
        
        const lastTreePosSource = strollComp.lastTargetTreeId ? ecs.getComponent(strollComp.lastTargetTreeId, Transform) : referenceTransform;
        const nextTargetInfo = selectNextStrollTarget(ecs, lastTreePosSource, referenceTransform, strollComp.lastTargetTreeId);

        if (nextTargetInfo) {
            strollComp.currentTargetTreeId = nextTargetInfo.treeId;
            strollComp.currentPathTargetPos = nextTargetInfo.strollTargetPos;
            actionIntent.actionData = null;
        } else {
            ecs.removeComponent(entity, StrollComponent);
            return setRelaxing(actionIntent);
        }
    }
    
    // We're still walking
    if (!locomotion.arrived) {
        const currentWalkData = actionIntent.actionData as WalkingData | null;
        if (actionIntent.currentPerformedAction !== CharacterAction.WALKING ||
            !isWalkingData(currentWalkData) ||
            currentWalkData.ultimateTargetEntityId !== strollComp.currentTargetTreeId) {
            
            setWalkingToStrollPoint(actionIntent, strollComp.currentPathTargetPos!, strollComp.currentTargetTreeId);
        }

        return;
    } 
    
    // We've arrived, waiting around
    if (actionIntent.currentPerformedAction != CharacterAction.STROLLING) {
        setStrollingAtPoint(actionIntent, strollComp.currentTargetTreeId!);
        strollComp.isPausedAtTarget = true;
        const pauseDuration = Math.random() * (MAX_PAUSE_DURATION_GAME_MINUTES - MIN_PAUSE_DURATION_GAME_MINUTES) + MIN_PAUSE_DURATION_GAME_MINUTES;
        strollComp.pauseUntilTime = currentGameTime + pauseDuration;
    }

    if (strollComp.pauseUntilTime >= currentGameTime){
        setWalkingToStrollPoint(actionIntent, {x:0,y:0});
    }
}

// ---

import { ECS, Entity } from "../../../ECS";
import { ActionIntentComponent } from "../ActionIntentComponent";
import {
    CharacterAction,
    ActionDataType,
    WalkingData,
    SleepingData,
    CharacterIntent
} from "../actionIntentData";
import { Transform } from "../../../components/Transform";
import { InteractionSlots, SlotType } from "../../../components/InteractionSlots";
import { DormitoryComponent } from "../../buildings/dormitory/DormitoryComponent";
import { Pos } from "../../../../utils/Math";
import { LocomotionComponent } from "../../locomotion/LocomotionComponent"; 

function setIdle(aic: ActionIntentComponent): void {
    aic.currentPerformedAction = CharacterAction.IDLE;
    aic.actionData = null;
}

function setBlocked(aic: ActionIntentComponent): void {
    aic.intentType = CharacterIntent.REST;
    aic.currentPerformedAction = CharacterAction.IDLE;
    aic.actionData = null;
}

function setWalkingToSlot(aic: ActionIntentComponent, targetPosition: Pos, ultimateTargetId: Entity): void {
    aic.currentPerformedAction = CharacterAction.WALKING;
    aic.actionData = {
        type: ActionDataType.WalkingData,
        targetPosition,
        ultimateTargetEntityId: ultimateTargetId
    } as WalkingData;
}

function setSleeping(aic: ActionIntentComponent, bedEntityId: Entity, slotOffset: Pos): void {
    aic.currentPerformedAction = CharacterAction.SLEEPING;
    aic.actionData = {
        type: ActionDataType.SleepingData,
        bedEntityId,
        slotOffset
    } as SleepingData;
}

function isDormitoryFunctionallyValid(ecs: ECS, dormitoryEntityId: Entity): boolean {
    if (!ecs.hasEntity(dormitoryEntityId)) return false;
    return ecs.hasComponent(dormitoryEntityId, DormitoryComponent) &&
           ecs.hasComponent(dormitoryEntityId, InteractionSlots);
}

function releaseAnySleepSlotHeldByCharacter(ecs: ECS, characterEntity: Entity): void {
    const allDormitories = ecs.getEntitiesWithComponents([DormitoryComponent, InteractionSlots]);
    for (const dormitoryId of allDormitories) {
        ecs.getComponent(dormitoryId, InteractionSlots)?.release(characterEntity, SlotType.SLEEP);
    }
}

function findAndReserveNewSleepTarget(ecs: ECS, characterEntity: Entity): { bedEntityId: Entity, slotOffset: Pos, bedBuildingTransform: Transform } | null {
    releaseAnySleepSlotHeldByCharacter(ecs, characterEntity);
    const allDormitories = ecs.getEntitiesWithComponents([DormitoryComponent, InteractionSlots, Transform]);
    
    for (const dormitoryId of allDormitories) {
        const slots = ecs.getComponent(dormitoryId, InteractionSlots);
        const offset = slots.reserve(characterEntity, SlotType.SLEEP);
        if (offset) {
            return { bedEntityId: dormitoryId, slotOffset: offset, bedBuildingTransform: ecs.getComponent(dormitoryId, Transform) };
        }
    }
    return null;
}

export function canSleep(ecs: ECS, entity: Entity): boolean {
    const allDormitories = ecs.getEntitiesWithComponents([DormitoryComponent, InteractionSlots]);
    for (const dormitoryId of allDormitories) {
        if (isDormitoryFunctionallyValid(ecs, dormitoryId)) {
            const slots = ecs.getComponent(dormitoryId, InteractionSlots);
            if (slots.getSlotsArray(SlotType.SLEEP).some(slot => slot.occupiedBy === null || slot.occupiedBy === entity)) {
                return true;
            }
        }
    }
    return false;
}

export function handleSleepIntentLogic(
    ecs: ECS,
    entity: Entity,
    actionIntent: ActionIntentComponent
): void {
    const characterTransform = ecs.getComponent(entity, Transform);
    if (!characterTransform) return setIdle(actionIntent);

    const targetInfo = findAndReserveNewSleepTarget(ecs, entity);

    if (!targetInfo) {
        setBlocked(actionIntent);
        return;
    }
    
    const locomotion = ecs.getComponent(entity, LocomotionComponent);

    const { bedEntityId, slotOffset, bedBuildingTransform } = targetInfo;

    if (locomotion.arrived){
        if (actionIntent.currentPerformedAction == CharacterAction.SLEEPING) return;

        setSleeping(actionIntent, bedEntityId, slotOffset);
        return;
    }

    if (actionIntent.currentPerformedAction != CharacterAction.WALKING) {
        const exactSleepPosition = { 
            x: Math.round(bedBuildingTransform.x + slotOffset.x), 
            y: Math.round(bedBuildingTransform.y + slotOffset.y) 
        };
    
        setWalkingToSlot(actionIntent, exactSleepPosition, bedEntityId);
    }
}

// ---

import { Component } from "../../ECS";
import { ActiveBuff, BuffType, BUFF_DEFINITIONS, BuffStackingBehavior } from "./buffsData";

export class ActiveBuffsComponent extends Component {
    public buffs: ActiveBuff[] = [];

    public addBuff(buffTypeToAdd: BuffType, currentTimeMinutes: number): void {
        const definition = BUFF_DEFINITIONS[buffTypeToAdd];
        if (!definition) {
            console.warn(`Attempted to add undefined buff type: ${buffTypeToAdd}`);
            return;
        }

        const newExpirationTimeMinutes = currentTimeMinutes + definition.defaultDurationMinutes;
        const existingBuffIndex = this.buffs.findIndex(b => b.type == buffTypeToAdd);

        if (existingBuffIndex != -1) {
            const existingBuff = this.buffs[existingBuffIndex];
            switch (definition.stackingBehavior) {
                case BuffStackingBehavior.REFRESH_DURATION:
                    existingBuff.expirationTimeMinutes = Math.max(existingBuff.expirationTimeMinutes, newExpirationTimeMinutes);
                    // Optionally, if effects could change or be stronger, update them:
                    // existingBuff.effects = [...definition.effects]; 
                    break;
                case BuffStackingBehavior.NO_STACK:
                    // Buff already exists, do nothing
                    break;
                case BuffStackingBehavior.INDEPENDENT_STACKING:
                    // Add a new instance regardless
                    this.buffs.push({
                        type: definition.type,
                        expirationTimeMinutes: newExpirationTimeMinutes,
                        effects: [...definition.effects], // Create a new copy of effects
                        stackingBehavior: definition.stackingBehavior,
                        source: definition.displayName 
                    });
                    break;
                case BuffStackingBehavior.HIGHEST_EFFECT_WINS:
                    // This would require comparing effect values, more complex.
                    // For now, let's treat it like REFRESH_DURATION or log a warning.
                    existingBuff.expirationTimeMinutes = Math.max(existingBuff.expirationTimeMinutes, newExpirationTimeMinutes);
                    // Potentially update effects if new ones are "stronger"
                    break;
                default:
                    // Default to refresh if behavior is unknown
                    existingBuff.expirationTimeMinutes = Math.max(existingBuff.expirationTimeMinutes, newExpirationTimeMinutes);
                    break;
            }
        } else {
            // Buff does not exist, add new one
            this.buffs.push({
                type: definition.type,
                expirationTimeMinutes: newExpirationTimeMinutes,
                effects: [...definition.effects],
                stackingBehavior: definition.stackingBehavior,
                source: definition.displayName
            });
        }
    }

    public removeBuff(buffTypeToRemove: BuffType): void {
        this.buffs = this.buffs.filter(b => b.type != buffTypeToRemove);
    }

    public hasBuff(buffType: BuffType): boolean {
        return this.buffs.some(b => b.type == buffType);
    }

    public getBuff(buffType: BuffType): ActiveBuff | undefined {
        return this.buffs.find(b => b.type == buffType);
    }
}

// ---

import { System, Entity } from "../../ECS";
import { TimeComponent } from "../time/TimeComponent";
import { ActiveBuffsComponent } from "./ActiveBuffsComponent";

export class BuffManagementSystem extends System {
    public componentsRequired = new Set<Function>([ActiveBuffsComponent]);
    private worldTimeEntity: Entity | null = null;

    private getCurrentTimeMinutes(): number | null {
        if (this.worldTimeEntity === null || !this.ecs.hasEntity(this.worldTimeEntity)) {
            const timeEntities = this.ecs.getEntitiesWithComponent(TimeComponent);
            if (timeEntities.length > 0) {
                this.worldTimeEntity = timeEntities[0];
            } else {
                return null; 
            }
        }
        return this.ecs.getComponent(this.worldTimeEntity, TimeComponent).minutesElapsed;
    }

    public update(entities: Set<Entity>, delta: number): void {
        const currentTimeMinutes = this.getCurrentTimeMinutes();
        if (currentTimeMinutes === null) {
            return; 
        }

        for (const entity of entities) {
            const activeBuffs = this.ecs.getComponent(entity, ActiveBuffsComponent);
            
            activeBuffs.buffs = activeBuffs.buffs.filter(
                buff => buff.expirationTimeMinutes > currentTimeMinutes
            );
        }
    }
}

// ---

import { System, Entity, ECS } from "../../ECS";
import { ActionIntentComponent } from "../action-intent/ActionIntentComponent";
import { CharacterAction } from "../action-intent/actionIntentData";
import { ActiveBuffsComponent } from "./ActiveBuffsComponent";
import { MIN_SLEEP_DURATION_FOR_RESTED_BUFF_MINUTES, BuffType } from "./buffsData";
import { TimeComponent } from "../time/TimeComponent"; // Adjust path
import { CharacterSleepStateComponent } from "../buildings/dormitory/CharacterSleepStateComponent";

export class SleepEffectsSystem extends System {
    public componentsRequired = new Set<Function>([ActionIntentComponent]);
    private worldTimeEntity: Entity | null = null;

    private getCurrentTimeMinutes(ecs: ECS): number | null {
        if (this.worldTimeEntity === null || !ecs.hasEntity(this.worldTimeEntity)) {
            const timeEntities = ecs.getEntitiesWithComponent(TimeComponent);
            this.worldTimeEntity = timeEntities.length > 0 ? timeEntities[0] : null;
        }
        if (!this.worldTimeEntity) return null;
        return ecs.getComponent(this.worldTimeEntity, TimeComponent).minutesElapsed;
    }

    public update(entities: Set<Entity>, delta: number): void {
        const currentTimeMinutes = this.getCurrentTimeMinutes(this.ecs);
        if (currentTimeMinutes === null) return;

        for (const entity of entities) {
            const actionIntent = this.ecs.getComponent(entity, ActionIntentComponent);
            const sleepState = this.ecs.getComponent(entity, CharacterSleepStateComponent);

            if (actionIntent.currentPerformedAction === CharacterAction.SLEEPING) {
                if (!sleepState) {
                    this.ecs.addComponent(entity, new CharacterSleepStateComponent(currentTimeMinutes));
                    return;
                }
            } else { // Not currently SLEEPING
                if (sleepState) {
                    // Was sleeping, but no longer is. Apply buff if duration was sufficient.
                    const sleepDurationMinutes = currentTimeMinutes - sleepState.sleepStartTimeMinutes;
                    if (sleepDurationMinutes >= MIN_SLEEP_DURATION_FOR_RESTED_BUFF_MINUTES) {
                        let activeBuffs = this.ecs.getComponent(entity, ActiveBuffsComponent);
                        if (!activeBuffs) {
                            activeBuffs = new ActiveBuffsComponent();
                            this.ecs.addComponent(entity, activeBuffs);
                        }
                        activeBuffs.addBuff(BuffType.RESTED, currentTimeMinutes);
                    }
                    this.ecs.removeComponent(entity, CharacterSleepStateComponent);
                }
            }
        }
    }
}

// ---

import { ECS, Entity } from "../../ECS"; // Adjust path
import { AffectedStat, BuffEffect, BuffEffectApplicationType } from "./buffsData";
import { LocomotionComponent } from "../locomotion/LocomotionComponent"; // Adjust path
import { HarvesterComponent as HarvesterComponent } from "../trees/HarvesterComponent"; // Adjust path, aliased to avoid name clash
import { ActiveBuffsComponent } from "./ActiveBuffsComponent";
import { WorkerComponent } from "../characters/WorkerComponent";

export class StatCalculator {

    private static getBaseValue(ecs: ECS, entity: Entity, statType: AffectedStat): number {
        switch (statType) {
            case AffectedStat.LOCOMOTION_SPEED:{
                const loco = ecs.getComponent(entity, LocomotionComponent);
                return loco?.speed ?? 0; // Default to 0 if component or baseSpeed is missing
            }
            case AffectedStat.WORK_SPEED:{
                const worker = ecs.getComponent(entity, WorkerComponent);
                return worker?.workSpeed ?? 0; 
            }
            case AffectedStat.HARVEST_SPEED:{
                const effectiveWorkSpeed = StatCalculator.getEffectiveStat(ecs, entity, AffectedStat.WORK_SPEED);
                const harvesterForHS = ecs.getComponent(entity, HarvesterComponent);
                const baseHarvestSpeedAdditive = harvesterForHS?.harvestPerMinute ?? 0;
                return effectiveWorkSpeed + baseHarvestSpeedAdditive;
            }       
            default:
                console.warn(`StatCalculator: Base value for stat type ${statType} not defined.`);
                return 0;
        }
    }

    public static getEffectiveStat(
        ecs: ECS, 
        entity: Entity, 
        statType: AffectedStat
    ): number {
        let currentValue = StatCalculator.getBaseValue(ecs, entity, statType);
        
        const activeBuffsComp = ecs.getComponent(entity, ActiveBuffsComponent);
        if (!activeBuffsComp || activeBuffsComp.buffs.length === 0) {
            return currentValue;
        }

        const relevantEffects: BuffEffect[] = [];
        for (const buff of activeBuffsComp.buffs) {
            for (const effect of buff.effects) {
                if (effect.stat === statType) {
                    relevantEffects.push(effect);
                }
            }
        }

        if (relevantEffects.length === 0) {
            return currentValue;
        }

        // Sort effects: FLAT_ADDITIVE first, then PERCENT_MULTIPLICATIVE.
        // Further sort by 'order' if provided.
        relevantEffects.sort((a, b) => {
            const typeOrderA = a.type === BuffEffectApplicationType.FLAT_ADDITIVE ? 1 : 2;
            const typeOrderB = b.type === BuffEffectApplicationType.FLAT_ADDITIVE ? 1 : 2;
            if (typeOrderA !== typeOrderB) {
                return typeOrderA - typeOrderB;
            }
            return (a.order ?? 0) - (b.order ?? 0);
        });

        // Apply flat additive bonuses
        for (const effect of relevantEffects) {
            if (effect.type === BuffEffectApplicationType.FLAT_ADDITIVE) {
                currentValue += effect.value;
            }
        }

        // Apply percent multiplicative bonuses
        for (const effect of relevantEffects) {
            if (effect.type === BuffEffectApplicationType.PERCENT_MULTIPLICATIVE) {
                currentValue *= effect.value; // Assumes value is like 1.1 for +10%
            }
        }
        
        // Min value for stats like speed/rate is typically 0, or a small positive epsilon.
        // This can be handled by the consuming system or configured per stat if needed.
        return currentValue;
    }
}

// ---

export enum BuffType {
    RESTED = "RESTED",
    STROLL_SPEED = "STROLL_SPEED"
}

export enum AffectedStat {
    LOCOMOTION_SPEED = "locomotionSpeed",
    WORK_SPEED = "workSpeed",
    HARVEST_SPEED = "harvestSpeed",
}

export enum BuffEffectApplicationType {
    FLAT_ADDITIVE = "FLAT_ADDITIVE",
    PERCENT_MULTIPLICATIVE = "PERCENT_MULTIPLICATIVE",
}

export enum BuffStackingBehavior {
    REFRESH_DURATION = "REFRESH_DURATION", // New instance refreshes duration, effects might update if stronger
    INDEPENDENT_STACKING = "INDEPENDENT_STACKING", // Multiple instances co-exist, StatCalculator sums effects
    NO_STACK = "NO_STACK", // Only one instance allowed; subsequent applications ignored or fail
    HIGHEST_EFFECT_WINS = "HIGHEST_EFFECT_WINS" // Only the instance with the highest effect value for a given stat applies
}

export interface BuffEffect {
    stat: AffectedStat;
    type: BuffEffectApplicationType;
    value: number;
    order?: number; 
}

export interface ActiveBuff {
    type: BuffType;
    expirationTimeMinutes: number;
    effects: BuffEffect[];
    stackingBehavior: BuffStackingBehavior; // Could be copied from BuffDefinition or set per instance
    source?: string;
}

export interface BuffDefinition {
    readonly type: BuffType;
    readonly defaultDurationMinutes: number;
    readonly effects: ReadonlyArray<BuffEffect>;
    readonly stackingBehavior: BuffStackingBehavior;
    readonly displayName?: string; // Optional display name for UI
}

export const MIN_SLEEP_DURATION_FOR_RESTED_BUFF_MINUTES = 90;

export const BUFF_DEFINITIONS: Readonly<Record<BuffType, BuffDefinition>> = {
    [BuffType.RESTED]: {
        type: BuffType.RESTED,
        defaultDurationMinutes: 60,
        effects: [
            { stat: AffectedStat.LOCOMOTION_SPEED, type: BuffEffectApplicationType.PERCENT_MULTIPLICATIVE, value: 1.10, order: 100 },
            { stat: AffectedStat.WORK_SPEED,       type: BuffEffectApplicationType.PERCENT_MULTIPLICATIVE, value: 1.10, order: 100 },
        ],
        stackingBehavior: BuffStackingBehavior.REFRESH_DURATION,
    },
    [BuffType.STROLL_SPEED]: {
        type: BuffType.STROLL_SPEED,
        defaultDurationMinutes: 60 * 24 * 7, // Effectively indefinite, managed by adding/removing
        effects: [
            { stat: AffectedStat.LOCOMOTION_SPEED, type: BuffEffectApplicationType.PERCENT_MULTIPLICATIVE, value: 0.1, order: 50 }
        ],
        stackingBehavior: BuffStackingBehavior.NO_STACK, // Only one instance of this effect
    }
};

// ---

import {Component} from "../../ECS.ts";

export class Cave extends Component {
    constructor(
        public explored: boolean = false
    ) {
        super();
    }
}

// ---

import { Component } from "../../../ECS"; // Adjust path as needed

/**
 * Tracks the state of an entity currently performing the SLEEPING action,
 * primarily to determine sleep duration for effects like the "Rested" buff.
 */
export class CharacterSleepStateComponent extends Component {
    /** Game time in total minutes (e.g., from TimeComponent.minutesElapsed) when the SLEEPING action began. */
    public sleepStartTimeMinutes: number;

    constructor(sleepStartTimeMinutes: number) {
        super();
        this.sleepStartTimeMinutes = sleepStartTimeMinutes;
    }
}

// ---

import { Component } from "../../../ECS";

export class DormitoryComponent extends Component {
    public assignedCharacters: number[] = [];

    constructor(public maxCapacity: number = 5) {
        super();
    }
}

// ---

import { System, Entity } from "../../../ECS";
import { DormitoryComponent } from "./DormitoryComponent";

export class DormitorySystem extends System {
    public componentsRequired = new Set<Function>([DormitoryComponent]);

    public update(dormitoryEntities: Set<Entity>, delta: number): void {
        for (const dormitoryEntity of dormitoryEntities) {
            const dorm = this.ecs.getComponent(dormitoryEntity, DormitoryComponent);

            for (let i = dorm.assignedCharacters.length - 1; i >= 0; i--) {
                const characterId = dorm.assignedCharacters[i];
                if (!this.ecs.hasEntity(characterId)) {
                    dorm.assignedCharacters.splice(i, 1);
                }
            }
        }
    }
}

// ---

import { Component, Entity } from "../../../ECS";

/**
 * Stores the entity ID of a character's assigned "home" base.
 * This could be a dormitory, a work building like a WoodDojo, or another central point
 * used as a reference for behaviors like strolling or context-based task targeting.
 */
export class HomeComponent extends Component {
    /**
     * @param homeEntityId The entity ID of the character's assigned home structure.
     */
    constructor(public homeEntityId: Entity) {
        super();
    }
}

// ---

import {Component} from "../../../ECS.ts";

export class WoodDojo extends Component {
    public assignedCharacters: number[] = [];
    
    constructor(
    ) {
        super();
    }
}

// ---

import { System, Entity } from "../../../ECS";
import { WoodDojo } from "./WoodDojo";

export class WoodDojoSystem extends System {
    public componentsRequired = new Set<Function>([WoodDojo]);

    public update(dojoEntities: Set<Entity>, delta: number): void {
        for (const dojoEntity of dojoEntities) {
            const dojo = this.ecs.getComponent(dojoEntity, WoodDojo);

            // Clean up non-existent characters from the assignedCharacters list
            // Iterate backwards when removing elements from an array during iteration
            for (let i = dojo.assignedCharacters.length - 1; i >= 0; i--) {
                const characterId = dojo.assignedCharacters[i];
                if (!this.ecs.hasEntity(characterId)) {
                    dojo.assignedCharacters.splice(i, 1);
                }
            }
        }
    }
}

// ---

import { Component } from "../../ECS";

export enum CharacterType {
    PROFESSOR = "PROFESSOR"
}

export class CharacterDefinition {
    public name: string;
    public description: string;
    public type:CharacterType;
}

export class Character extends Component {
    constructor(
        public definition: CharacterDefinition,
    ) {
        super();
    }
}

// ---

import { Component } from "../../ECS";
import { CharacterIntent } from "../action-intent/actionIntentData";

export type ScheduleEntry = CharacterIntent; // One entry per hour

export class ScheduleComponent extends Component {
  public lastScheduleStartHour: number = 0; // Time in minutes when the schedule started

  constructor(public entries: ScheduleEntry[]) {
    super();
  }
}

export function createStandardSchedule(): ScheduleComponent {
  return new ScheduleComponent([
    CharacterIntent.SLEEP,
    CharacterIntent.HARVEST,
    CharacterIntent.HARVEST,
    CharacterIntent.REST,
    CharacterIntent.HARVEST,
    CharacterIntent.HARVEST,
    CharacterIntent.HARVEST,
    CharacterIntent.SLEEP
  ]);
}

// ---

import { Component } from "../../ECS";

export class WorkerComponent extends Component {
    public workSpeed: number = 1; 

    constructor() {
        super();
    }
}

// ---

import { Component } from "../../ECS";

export type TimeSpeed = 'paused' | 'normal' | 'fast' | 'veryfast';

export class InputComponent extends Component {
    constructor(
        public speed: TimeSpeed = 'normal',
        public selection: number = -1 // -1 means no selection
    ) {
        super();
    }
}


// ---

import { Entity, System } from "../../ECS";
import { InputComponent, TimeSpeed } from "./InputComponent.ts";
import { GameEvent } from "../../consts/GameEvent.ts";
import { EventBus } from "../../EventBus.ts";

export class InputSystem extends System {
    public componentsRequired = new Set<Function>([InputComponent]);

    constructor() {
        super();
    }

    handleSetSpeed(speed: TimeSpeed) {
        for (const entity of this.ecs.getEntitiesWithComponent(InputComponent)) {
            const input = this.ecs.getComponent(entity, InputComponent);
            input.speed = speed;
        }
    }

    handleSelectionChange(entityId: number) {
        for (const entity of this.ecs.getEntitiesWithComponent(InputComponent)) {
            const input = this.ecs.getComponent(entity, InputComponent);
            input.selection = entityId;
        }
    }

    update(_: Set<Entity>, __: number): void {}

    initialize(): () => void {
        const boundHandleSetSpeed = this.handleSetSpeed.bind(this);
        const boundHandleSelectionChange = this.handleSelectionChange.bind(this);
        
        EventBus.on(GameEvent.SetTimeSpeed, boundHandleSetSpeed);
        EventBus.on(GameEvent.SelectionChanged, boundHandleSelectionChange);

        for (const entity of this.ecs.getEntitiesWithComponent(InputComponent)) {
            const input = this.ecs.getComponent(entity, InputComponent);
            EventBus.emit(GameEvent.SetTimeSpeed, input.speed);
        }

        return () => {
            EventBus.off(GameEvent.SetTimeSpeed, boundHandleSetSpeed);
            EventBus.off(GameEvent.SelectionChanged, boundHandleSelectionChange);
        };
    }
}


// ---

import { Entity, System } from "../../ECS";
import { ActionIntentComponent } from "../action-intent/ActionIntentComponent";
import { CharacterIntent, CharacterAction } from "../action-intent/actionIntentData";
import { ScheduleComponent } from "../characters/ScheduleComponent";
import { getCurrentHour } from "../time/TimeComponent";
import { NeedsComponent } from "../needs/NeedsComponent";
import { calculateHarvestIntentWeight } from "./calculateHarvestIntentWeight";
import { calculateSleepIntentWeight } from "./calculateSleepIntentWeight";
import { calculateRestIntentWeight } from "./calculateRestIntentWeight";

export class IntentSelectionSystem extends System {
    public componentsRequired = new Set<Function>([
        ActionIntentComponent,
        ScheduleComponent,
        NeedsComponent
    ]);

    public update(entities: Set<Entity>, delta: number): void {
        const currentHour = getCurrentHour(this.ecs);
        if (currentHour === null) return;

        for (const entity of entities) {
            const actionIntent = this.ecs.getComponent(entity, ActionIntentComponent);
            const schedule = this.ecs.getComponent(entity, ScheduleComponent);
            const needs = this.ecs.getComponent(entity, NeedsComponent);

            const intentWeights: { intent: CharacterIntent, weight: number }[] = [];

            // Calculate weights for all relevant intents
            intentWeights.push({ intent: CharacterIntent.SLEEP, weight: calculateSleepIntentWeight(this.ecs, entity, schedule, needs, currentHour) });
            intentWeights.push({ intent: CharacterIntent.HARVEST, weight: calculateHarvestIntentWeight(this.ecs, entity, schedule, needs, currentHour) });
            intentWeights.push({ intent: CharacterIntent.REST, weight: calculateRestIntentWeight(this.ecs, entity, schedule, needs, currentHour) });

            // Sort by weight descending
            intentWeights.sort((a, b) => b.weight - a.weight);

            let chosenIntent = CharacterIntent.REST;

            if (intentWeights.length > 0 && intentWeights[0].weight > 0) {
                chosenIntent = intentWeights[0].intent;
            }

            if (actionIntent.intentType !== chosenIntent) {
                actionIntent.intentType = chosenIntent;
                actionIntent.currentPerformedAction = CharacterAction.IDLE; // Reset action
                actionIntent.actionData = null; // Clear data for the new intent
            }
        }
    }
}

// ---

import { ECS, Entity } from "../../ECS";
import { CharacterIntent } from "../action-intent/actionIntentData";
import { canHarvest as canHarvest } from "../action-intent/intent-handlers/handleHarvestIntentLogic";
import { ScheduleComponent } from "../characters/ScheduleComponent";
import { NeedsComponent } from "../needs/NeedsComponent";

export function calculateHarvestIntentWeight(ecs: ECS, entity: Entity, schedule: ScheduleComponent, needs: NeedsComponent, currentHour: number): number {
    if (schedule.entries[currentHour] !== CharacterIntent.HARVEST) return 0;
    return canHarvest(ecs, entity) ? 100 : 0;
}


// ---

import { ECS, Entity } from "../../ECS";
import { CharacterIntent } from "../action-intent/actionIntentData";
import { ScheduleComponent } from "../characters/ScheduleComponent";
import { NeedsComponent } from "../needs/NeedsComponent";

export function calculateRestIntentWeight(ecs: ECS, entity: Entity, schedule: ScheduleComponent, needs: NeedsComponent, currentHour: number): number {
    if (schedule.entries[currentHour] === CharacterIntent.REST) return 60;
    return 10;
}


// ---

import { ECS, Entity } from "../../ECS";
import { CharacterIntent } from "../action-intent/actionIntentData";
import { canSleep as canSleep } from "../action-intent/intent-handlers/handleSleepIntentLogic";
import { ScheduleComponent } from "../characters/ScheduleComponent";
import { NeedsComponent } from "../needs/NeedsComponent";

export function calculateSleepIntentWeight(ecs: ECS, entity: Entity, schedule: ScheduleComponent, needs: NeedsComponent, currentHour: number): number {
    let weight = 0;
    const sleepNeed = needs.sleep.current / needs.sleep.max; // Normalized 1.0 (full) to 0.0 (empty)

    if (sleepNeed < 0.3) weight += 200 * (1 - sleepNeed); // Very high weight if very tired
    else if (sleepNeed < 0.6) weight += 50 * (1 - sleepNeed);

    if (schedule.entries[currentHour] === CharacterIntent.SLEEP) {
        weight += 80; // Boost if scheduled
    }

    return canSleep(ecs, entity) ? weight : 0;
}


// ---

import { Component } from "../../ECS";

export class InsideLocationComponent extends Component {}

// ---

import { Component } from "../../ECS.ts";
import { Pos } from "../../../utils/Math.ts";

export class LocomotionComponent extends Component {
    public destination: Pos;
    public speed: number = 1;
    public arrived: boolean = false;

  constructor(
  ) {
    super();
  }
}


// ---

import { System, Entity } from "../../ECS";
import { LocationState, Transform } from "../../components/Transform";
import { ActionIntentComponent } from "../action-intent/ActionIntentComponent";
import { CharacterAction, WalkingData} from "../action-intent/actionIntentData";
import { TimeComponent } from "../time/TimeComponent";
import { LocomotionComponent } from "./LocomotionComponent";
import { Pos } from "../../../utils/Math";
import { InsideLocationComponent } from "./InsideLocationComponent";
import { StatCalculator } from "../buffs/StatCalculator";
import { AffectedStat } from "../buffs/buffsData";

export class LocomotionSystem extends System {
    public componentsRequired = new Set<Function>([
        LocomotionComponent,
        Transform,
        ActionIntentComponent,
    ]);

    public update(entities: Set<Entity>, delta: number): void {
        const timeEntity = this.ecs.getEntitiesWithComponent(TimeComponent)[0];
        if (!timeEntity) return;
        const time = this.ecs.getComponent(timeEntity, TimeComponent);
        if (time.speedFactor === 0) return;

        const scaledDelta = delta * time.speedFactor;

        for (const entity of entities) {
            const locomotion = this.ecs.getComponent(entity, LocomotionComponent);
            const transform = this.ecs.getComponent(entity, Transform);
            const actionIntent = this.ecs.getComponent(entity, ActionIntentComponent);

            if (!this.isEntityActivelyWalking(actionIntent)) {
                continue;
            }

            const walkData = actionIntent.actionData as WalkingData;
            const targetPosition = { 
                x: Math.round(walkData.targetPosition.x), 
                y: Math.round(walkData.targetPosition.y) 
            };

            const isArrived = this.processArrival(locomotion, transform, targetPosition);
            
            if (isArrived) {
                this.updateLocationState(transform, walkData.ultimateTargetEntityId, isArrived);
                continue; 
            }

            transform.locationState = LocationState.OUTSIDE;
            
            const speed = StatCalculator.getEffectiveStat(this.ecs, entity, AffectedStat.LOCOMOTION_SPEED);
            this.performMovementStep(transform, targetPosition, speed * scaledDelta);
            this.updateSpriteDirection(transform, targetPosition.x - transform.x);
        }
    }

    private isEntityActivelyWalking(actionIntent: ActionIntentComponent): boolean {
        return actionIntent.currentPerformedAction == CharacterAction.WALKING && !!(actionIntent?.actionData?.targetPosition);
    }

    private processArrival(locomotion: LocomotionComponent, transform: Transform, targetPos: Pos): boolean {
        const roundedCurrentX = Math.round(transform.x);
        const roundedCurrentY = Math.round(transform.y);

        if (roundedCurrentX === targetPos.x && roundedCurrentY === targetPos.y) {
            if (!locomotion.arrived) { // Actions for first arrival at exact spot
                transform.x = targetPos.x; 
                transform.y = targetPos.y;
                locomotion.arrived = true;
            }
            return true; // Is at target
        } else if (locomotion.arrived) {
            locomotion.arrived = false; // Reset arrived state if not at target
        }

        return false; // Not at target
    }
    
    private updateLocationState(transform: Transform, ultimateTargetEntityId: Entity | undefined, isArrivedAtTarget: boolean): void {
        if (ultimateTargetEntityId && this.ecs.hasEntity(ultimateTargetEntityId) && this.ecs.hasComponent(ultimateTargetEntityId, InsideLocationComponent)) {
            transform.locationState = isArrivedAtTarget ? LocationState.INSIDE : LocationState.OUTSIDE;
        }
    }

    private performMovementStep(transform: Transform, targetPos: Pos, stepDistance: number): void {
        const dx = targetPos.x - transform.x;
        const dy = targetPos.y - transform.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist <= stepDistance || dist === 0) {
            transform.x = targetPos.x; // Snap to exact rounded target
            transform.y = targetPos.y;
            // locomotion.arrived will be set true in the next frame by processArrival
        } else {
            transform.x += (dx / dist) * stepDistance;
            transform.y += (dy / dist) * stepDistance;
        }
    }

    private updateSpriteDirection(transform: Transform, dxToTarget: number): void {
        if (dxToTarget !== 0) {
            transform.direction = dxToTarget > 0 ? -1 : 1; // Assuming -1 is right, 1 is left
        }
    }
}

// ---

import { Component } from "../../ECS";

export class CaveTreeLUTComponent extends Component {
    constructor(public lut: Record<number, number[]>) {
        super();
    }
}

// ---

import { Pos } from "../../../utils/Math";
import { View } from "../../display/setup/View";
import { ViewType } from "../../display/setup/ViewDefinition";

// Output: caveEntityId  sorted array of nearby tree entityIds
export function buildCaveTreeLUTFromViews(views: Map<number, View>): Record<number, number[]> {
    const caves: { id: number; pos: Pos }[] = [];
    const trees: { id: number; pos: Pos }[] = [];

    for (const [entity, view] of views) {
        if (view.type === ViewType.CAVE) {
            caves.push({ id: entity, pos: view.viewDefinition.position });
        } else if (view.type === ViewType.TREE) {
            trees.push({ id: entity, pos: view.viewDefinition.position });
        }
    }

    const result: Record<number, number[]> = {};

    for (const cave of caves) {
        const sortedTrees = trees
            .map(tree => ({
                id: tree.id,
                distSq: distanceSq(cave.pos, tree.pos)
            }))
            .sort((a, b) => a.distSq - b.distSq)
            .map(t => t.id);

        result[cave.id] = sortedTrees;
    }

    return result;
}

function distanceSq(a: Pos, b: Pos): number {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return dx * dx + dy * dy;
}


// ---

import { Component } from "../../ECS";

export class NeedsComponent extends Component {
    public sleep = { current: 100, max: 100, downRatePerMinute: 0.5, upRatePerMinute: 1 };
}

// ---

import { System, Entity, ECS } from "../../ECS";
import { TimeConfig } from "../../config/TimeConfig";
import { ActionIntentComponent } from "../action-intent/ActionIntentComponent";
import { CharacterAction } from "../action-intent/actionIntentData";
import { getTime } from "../time/TimeComponent";
import { NeedsComponent } from "./NeedsComponent";

export class SleepNeedSystem extends System {
    public componentsRequired = new Set<Function>([NeedsComponent, ActionIntentComponent]);

    private getDeltaInGameMinutes(ecs: ECS, deltaMs: number): number {
        const time = getTime(ecs);
        if (time.speedFactor === 0) return 0;

        const realSecondsPassed = deltaMs / 1000;
        // Using TimeConfig to correctly scale real seconds to game minutes
        const gameMinutesPassed = (realSecondsPassed / TimeConfig.RealSecondsPerHour) * TimeConfig.MinutesPerHour * time.speedFactor;
        return gameMinutesPassed;
    }

    public update(entities: Set<Entity>, delta: number): void {
        const gameMinutesPassedThisFrame = this.getDeltaInGameMinutes(this.ecs, delta);
        if (gameMinutesPassedThisFrame === 0) return;

        for (const entity of entities) {
            const needs = this.ecs.getComponent(entity, NeedsComponent);
            const actionIntent = this.ecs.getComponent(entity, ActionIntentComponent);

            if (actionIntent.currentPerformedAction === CharacterAction.SLEEPING) {
                needs.sleep.current += needs.sleep.upRatePerMinute * gameMinutesPassedThisFrame;
            } else {
                needs.sleep.current -= needs.sleep.downRatePerMinute * gameMinutesPassedThisFrame;
            }

            needs.sleep.current = Math.max(0, Math.min(needs.sleep.current, needs.sleep.max));
        }
    }
}

// ---

import { Component } from "../../ECS";
import { ResourceType } from "./ResourceType";

export class ResourceComponent extends Component {
    public amounts: Record<ResourceType, number> = {
        [ResourceType.MONEY]: 10,
        [ResourceType.WOOD]: 0,
        [ResourceType.FOOD]: 0,
        [ResourceType.TOOLS]: 0
    };
}


// ---

import { ResourceType } from "./ResourceType";

export interface ResourceDefinition {
    icon: string;         // Path to icon
    description: string;  // Human-friendly tooltip or label
}

export const ResourceConfig: Record<ResourceType, ResourceDefinition> = {
    [ResourceType.MONEY]: {
        icon: "assets/icons/money_icon.png",
        description: "Money"
    },
    [ResourceType.WOOD]: {
        icon: "assets/icons/wood_icon.png",
        description: "Wood"
    },
    [ResourceType.FOOD]: {
        icon: "assets/icons/food_icon.png",
        description: "Food"
    },
    [ResourceType.TOOLS]: {
        icon: "assets/icons/tools_icon.png",
        description: "Tools"
    }
};


// ---

import { System, Entity } from "../../ECS";
import { ResourceComponent } from "./ResourceComponent";
import { ResourceTracker } from "./ResourceTracker";
import { ResourceType } from "./ResourceType";

export class ResourceSystem extends System {
    public componentsRequired = new Set<Function>([ResourceComponent]);

    private lastState: Record<ResourceType, number> = {
        [ResourceType.MONEY]: -1,
        [ResourceType.WOOD]: -1,
        [ResourceType.FOOD]: -1,
        [ResourceType.TOOLS]: -1
    };

    update(_: Set<Entity>, __: number): void {
        const entity = this.ecs.getEntitiesWithComponent(ResourceComponent)[0];
        if (entity === undefined) return;

        const res = this.ecs.getComponent(entity, ResourceComponent);
        const changed: Partial<Record<ResourceType, number>> = {};

        for (const type of Object.values(ResourceType)) {
            const current = Math.max(0, Math.floor(res.amounts[type]));
            if (current !== this.lastState[type]) {
                this.lastState[type] = current;
                changed[type] = current;
            }
        }

        if (Object.keys(changed).length > 0) {
            ResourceTracker.bulkSet(changed);
        }
    }
}


// ---

import { EventBus } from "../../EventBus";
import { GameEvent } from "../../consts/GameEvent";
import { ResourceType } from "./ResourceType";

type ResourceListener = (resources: Partial<Record<ResourceType, number>>) => void;

export class ResourceTracker {
    private static resources: Record<ResourceType, number> = {
        [ResourceType.MONEY]: 0,
        [ResourceType.WOOD]: 0,
        [ResourceType.FOOD]: 0,
        [ResourceType.TOOLS]: 0
    };

    private static listeners: Set<ResourceListener> = new Set();

    static get(type: ResourceType): number {
        return this.resources[type];
    }

    static set(type: ResourceType, value: number) {
        const clamped = Math.max(0, Math.floor(value));
        if (clamped !== this.resources[type]) {
            this.resources[type] = clamped;
            this.notify([type]);
        }
    }

    static add(type: ResourceType, delta: number) {
        this.set(type, this.resources[type] + delta);
    }

    static bulkSet(values: Partial<Record<ResourceType, number>>) {
        const changed: ResourceType[] = [];
        for (const type in values) {
            const t = type as ResourceType;
            const val = Math.max(0, Math.floor(values[t]!));
            if (val !== this.resources[t]) {
                this.resources[t] = val;
                changed.push(t);
            }
        }
        if (changed.length > 0) this.notify(changed);
    }

    static subscribe(fn: ResourceListener) {
        this.listeners.add(fn);
    }

    static unsubscribe(fn: ResourceListener) {
        this.listeners.delete(fn);
    }

    private static notify(changed: ResourceType[]) {
        const changedValues: Partial<Record<ResourceType, number>> = {};
        for (const type of changed) {
            changedValues[type] = this.resources[type];
        }
        this.listeners.forEach(fn => fn(changedValues));
        EventBus.emit(GameEvent.ResourcesUpdated, changedValues);
    }
}


// ---

export enum ResourceType {
    MONEY = "money",
    WOOD = "wood",
    FOOD = "food",
    TOOLS = "tools"
}


// ---


// All components should be serializable to JSON.
import {Entity} from "../../ECS.ts";

export interface GameState {
    entities: EntityState[];
}

export interface EntityState {
    id: Entity;
    components: Record<string, any>; // key = component class name, value = serialized data
}


// ---


// Registry to map component names to classes for deserialization
import {Component, ECS} from "../../ECS.ts";
import {Transform} from "../../components/Transform.ts";
import {Tree} from "../trees/Tree.ts";
import {Cave} from "../buildings/Cave.ts";
import {EntityState, GameState} from "./GameState.ts";
import {EventBus} from "../../EventBus.ts";
import {GameEvent} from "../../consts/GameEvent.ts";
import {InputComponent} from "../input/InputComponent.ts";
import {TimeComponent} from "../time/TimeComponent.ts";

const componentRegistry: Record<string, new (...args: any[]) => Component> = {
    Transform,
    Tree,
    Cave,
    InputComponent,
    TimeComponent
};

export function serializeECS(ecs: ECS): GameState {
    const entities: EntityState[] = [];

    for (const [entityId, container] of ecs["entities"].entries()) {
        const components: Record<string, any> = {};
        for (const [key, component] of container["map"].entries()) {
            components[key.name] = { ...component }; // assumes components are plain data
        }
        entities.push({ id: entityId, components });
    }

    return { entities };
}

export function loadFromState(ecs: ECS, state: GameState): void {
    // Sort by entity ID to ensure ECS assigns them in matching order
    state.entities.sort((a, b) => a.id - b.id);
    for (const entityState of state.entities) {
        const entity = ecs.addEntity(); // creates a new ID, ignores the original one
        for (const [name, data] of Object.entries(entityState.components)) {
            const CompClass = componentRegistry[name];
            if (!CompClass) {
                console.warn(`Unknown component type: ${name}`);
                continue;
            }
            const instance = Object.assign(new CompClass(), data);
            ecs.addComponent(entity, instance);
        }
    }
    EventBus.emit(GameEvent.GameLoaded);
}


// ---

import {MapDefinition} from "./MapTypes.ts";
import {ECS} from "../../ECS.ts";
import {Transform} from "../../components/Transform.ts";
import {Tree} from "../trees/Tree.ts";
import {CaveSpriteKey, PlantSpriteKey} from "../../display/setup/SpriteLibrary.ts";
import {Cave} from "../buildings/Cave.ts";
import {EventBus} from "../../EventBus.ts";
import {GameEvent} from "../../consts/GameEvent.ts";
import { ViewDefinition } from "../../display/setup/ViewDefinition.ts";
import { WoodDojo } from "../buildings/wood_dojo/WoodDojo.ts";
import { HarvestableComponent } from "../trees/HarvestableComponent.ts";
import { ResourceType } from "../resources/ResourceType.ts";
import { InteractionSlots, SlotLayout, SlotType } from "../../components/InteractionSlots.ts";
import { initWorld, createProfessorBooker } from "./init.ts";
import { DormitoryComponent } from "../buildings/dormitory/DormitoryComponent.ts";
import { InsideLocationComponent } from "../locomotion/InsideLocationComponent.ts";

function loadMapIntoECS(ecs: ECS, map: MapDefinition): void {
    for (const [id, obj] of Object.entries(map.objects)) {
        const entity = ecs.addEntity();

        // Use view position if available, otherwise skip
        if (obj.components?.view) {
            const view = obj.components.view;
            ecs.addComponent(entity, new Transform(view.position.x, view.position.y));
        }

        const def = obj.components?.view;
        
        if (!def) {
            console.warn(`Object ${id} is missing a view component.`);
            continue;
        }
        
        switch (obj.type) {
            case "tree":
                if (def.spriteName) {
                    ecs.addComponent(entity, new Tree(def.spriteName as PlantSpriteKey));
                    ecs.addComponent(entity, new HarvestableComponent(1000, [{type:ResourceType.WOOD, amount:10}]));
                    ecs.addComponent(entity, new InteractionSlots({
                        [SlotType.WORK]: { layout: SlotLayout.RADIAL, radius: 120, count: 2 }
                      }));
                    } 
                else {
                    console.warn(`Tree object ${id} is missing a sprite key.`);
                }
                break;
            case "cave":
                if (def.spriteName) {
                    createCave(def, ecs, entity);
                } else {
                    console.warn(`Cave object ${id} is missing a sprite key.`);
                }
                break;

            default:
                console.warn(`Unknown object type: ${obj.type}`);
                break;
        }

        const panelDef = def.panelDefinition;
        
        if (!panelDef) {
            continue;
        }
    }
}

function createCave(def: ViewDefinition, ecs: ECS, entity: number) {
    switch (def.spriteName as CaveSpriteKey) {
        case 'cave':
            ecs.addComponent(entity, new InsideLocationComponent());
            ecs.addComponent(entity, new Cave(false));
            break;
        case 'wood_dojo':
            ecs.addComponent(entity, new InsideLocationComponent());
            ecs.addComponent(entity, new WoodDojo());
            ecs.addComponent(entity, new DormitoryComponent());
            ecs.addComponent(entity, new InteractionSlots({
                [SlotType.SLEEP]: { layout: SlotLayout.RADIAL, radius: 100, count: 5 }
              }));
            break;
        default:
            console.warn(`Unknown cave sprite key: ${def.spriteName}`);
            break;
    }
}

// =============================
// Game Entry: Load New Game
// =============================
export function loadNewGame(ecs: ECS, scene: Phaser.Scene): void {
    const rawData = scene.cache.json.get('forestMap');
    if (!rawData) {
        console.error('Failed to load forestMap from cache.');
        return;
    }

    const mapDefinition = rawData as MapDefinition;
    loadMapIntoECS(ecs, mapDefinition);
    initWorld(ecs);
    createProfessorBooker(ecs);
    EventBus.emit(GameEvent.GameLoaded);
} 


// ---

import {ViewDefinition} from "../../display/setup/ViewDefinition.ts";

export type MapObjectType = 'tree' | 'rock' | 'cave'; // extend freely

export interface MapObject {
    id: number;
    type: MapObjectType;
    name?: string;
    components?: {
        view?: ViewDefinition;
    };
    zHint?: number; // zHint is used to determine the rendering order of objects
}

export interface MapDefinition {
    name: string;
    hill: ViewDefinition;
    objects: Record<number, MapObject>;
}

// ---

import { EventBus } from "../../EventBus.ts";
import { GameEvent } from "../../consts/GameEvent.ts";
import { GameDisplay } from "../../display/GameDisplay.ts";
import { CameraModule } from "../../display/camera/CameraModule.ts";
import { SelectionHighlightModule } from "../../display/game/tools/selection/SelectionHighlightModule.ts";
import { DataPanelModule } from "../../display/game/data_panel/DataPanelModule.ts";
import { CloudsModule } from "../../display/game/sky/CloudsModule.ts";
import { SkyDisplayModule } from "../../display/game/sky/SkyDisplayModule.ts";
import { StarfieldModule } from "../../display/game/sky/StarfieldModule.ts";
import { TinterModule } from "../../display/game/time_tint/TinterModule.ts";
import { TreeSwayModule } from "../../display/game/trees/TreeSwayModule.ts";
import { Game } from "../../scenes/Game.ts";
import { InputSystem } from "../input/InputSystem.ts";
import { CaveExploreStory } from "../story/CaveExploreStory.ts";
import { StoryEventSystem } from "../story/StoryEventSystem.ts";
import { StoryOption } from "../story/StoryEventTypes.ts";
import { TimeSystem } from "../time/TimeSystem.ts";
import { WeatherSystem } from "../weather/WeatherSystem.ts";
import {CaveTreeLUTComponent} from "../lut/CaveTreeLUTComponent.ts";
import {buildCaveTreeLUTFromViews} from "../lut/buildCaveTreeLUTFromViews.ts";
import { GameTools } from "../../display/game/tools/GameTools.ts";
import { WoodDojoSystem } from "../buildings/wood_dojo/WoodDojoSystem.ts";
import { LocomotionSystem } from "../locomotion/LocomotionSystem.ts";
import { TreeHarvestingSystem } from "../trees/TreeHarvestingSystem.ts";
import { CaveViewModule } from "../../display/game/buildings/CaveViewModule.ts";
import { BuildingViewModule } from "../../display/game/buildings/BuildingViewModule.ts";
import { TreeViewModule } from "../../display/game/trees/TreeViewModule.ts";
import { TreeCutIconViewModule } from "../../display/game/trees/TreeCutIconViewModule.ts";
import { CharacterViewModule } from "../../display/game/characters/CharacterViewModule.ts";
import { ResourceSystem } from "../resources/ResourceSystem.ts";
import { ECS, Entity } from "../../ECS.ts";
import { Character, CharacterType } from "../characters/Character.ts";
import { Transform } from "../../components/Transform.ts";
import { WoodDojo } from "../buildings/wood_dojo/WoodDojo.ts";
import { InputComponent } from "../input/InputComponent.ts";
import { LocomotionComponent } from "../locomotion/LocomotionComponent.ts";
import { ResourceComponent } from "../resources/ResourceComponent.ts";
import { createStandardSchedule } from "../characters/ScheduleComponent.ts";
import { TimeComponent } from "../time/TimeComponent.ts";
import { WeatherComponent } from "../weather/WeatherComponent.ts";
import { HarvesterComponent } from "../trees/HarvesterComponent.ts";
import { loadPanelRegistry } from "../../display/game/data_panel/PanelRegistry.ts";
import { DormitorySystem } from "../buildings/dormitory/DormitorySystem.ts";
import { DormitoryComponent } from "../buildings/dormitory/DormitoryComponent.ts";
import { ActionIntentComponent } from "../action-intent/ActionIntentComponent.ts";
import { ActionIntentSystem } from "../action-intent/ActionIntentSystem.ts";
import { HomeComponent } from "../buildings/dormitory/HomeComponent.ts";
import { RelaxBehaviorSystem } from "../action-intent/RelaxBehaviorSystem.ts";
import { ActiveBuffsComponent } from "../buffs/ActiveBuffsComponent.ts";
import { BuffManagementSystem } from "../buffs/BuffManagementSystem.ts";
import { WorkerComponent } from "../characters/WorkerComponent.ts";
import { SleepEffectsSystem } from "../buffs/SleepEffectsSystem.ts";
import { SleepNeedSystem } from "../needs/SleepNeedSystem.ts";
import { NeedsComponent } from "../needs/NeedsComponent.ts";
import { IntentSelectionSystem } from "../intent-selection/IntentSelectionSystem.ts";

export const init = (game:Game) => {
    initData(game);
    initDisplay(game);
    initSystems(game);
    EventBus.emit(GameEvent.ViewsInitialized);
}

export const initStory = (game:Game) => {
    const story = new StoryEventSystem({
        "intro": CaveExploreStory
    });

    game.ecs.addSystem(story);

    const handleStoryEvent = (opt: StoryOption) => {
        if (opt.effect) opt.effect(game.ecs);
        if (opt.close) {
            EventBus.emit(GameEvent.StoryEventEnded);
        } else {
            story.advance(opt.entity!, opt.nextPageId);
        }
    };

    EventBus.on(GameEvent.StoryEventOptionChosen, handleStoryEvent);

    game.destroyQueue.push(() => {
        EventBus.off(GameEvent.StoryEventOptionChosen, handleStoryEvent);
    });
}

export const initInput = (game:Game) => {
    const input = new InputSystem();
    game.ecs.addSystem(input);
    const destroyInput = input.initialize();
    game.destroyQueue.push(destroyInput);
}

export const initSystems = (game:Game)=>{
    game.ecs.addSystem(new TimeSystem());
    game.ecs.addSystem(new WeatherSystem());
    game.ecs.addSystem(new LocomotionSystem());
    game.ecs.addSystem(new SleepNeedSystem());
    game.ecs.addSystem(new IntentSelectionSystem());
    game.ecs.addSystem(new ActionIntentSystem());
    game.ecs.addSystem(new SleepEffectsSystem());
    game.ecs.addSystem(new TreeHarvestingSystem())
    game.ecs.addSystem(new RelaxBehaviorSystem());
    game.ecs.addSystem(new BuffManagementSystem());
    game.ecs.addSystem(new ResourceSystem());
    game.ecs.addSystem(new WoodDojoSystem());
    game.ecs.addSystem(new DormitorySystem());

    initInput(game);
    initStory(game);
    initLut(game);
}

const initLut = (game:Game) => {
    const handleViewsInitialized = ()=>{
        const lut = new CaveTreeLUTComponent(buildCaveTreeLUTFromViews(game.gameDisplay.viewsByEntity));
        game.ecs.addComponent(game.ecs.addEntity(), lut);
    }
    
    EventBus.on(GameEvent.ViewsInitialized, handleViewsInitialized);

    game.destroyQueue.push(() => {
        EventBus.off(GameEvent.ViewsInitialized, handleViewsInitialized);
    });
}

export const initData = (game:Game) => {
    loadPanelRegistry(game);
}

export const initDisplay = (game:Game)=>{
    game.gameDisplay = new GameDisplay();
    
    const modules = [
        new CameraModule(),
        new SkyDisplayModule(),
        new StarfieldModule(),
        new CloudsModule(),
        new TinterModule(),
        new TreeSwayModule(),
        new SelectionHighlightModule(),
        new GameTools(),
        new DataPanelModule(),
        new CaveViewModule(),
        new BuildingViewModule(),
        new TreeViewModule(),
        new TreeCutIconViewModule(),
        new CharacterViewModule(),
    ];
    
    game.gameDisplay.init(game, game.ecs, modules);
}

export function initWorld(ecs: ECS): number {
    const world = ecs.addEntity();
    ecs.addComponent(world, new TimeComponent());
    ecs.addComponent(world, new InputComponent());
    ecs.addComponent(world, new WeatherComponent());
    ecs.addComponent(world, new ResourceComponent());
    
    return world;
}

export function createProfessorBooker(ecs: ECS): number {
    // Get the wood dojo transform, get position from it for booker
    const woodDojoEntity = ecs.getEntitiesWithComponent(WoodDojo)[0];
    const woodDojoTransform = ecs.getComponent(woodDojoEntity, Transform);
    const woodDojo = ecs.getComponent(woodDojoEntity, WoodDojo);

    const dormEntity = ecs.getEntitiesWithComponent(DormitoryComponent)[0];
    const dorm = ecs.getComponent(dormEntity, DormitoryComponent);

    // and add booker entity to the ECS
    const booker = addBooker(ecs, woodDojoTransform, woodDojo, dorm, dormEntity);
    
    return booker;
}

function addBooker(ecs: ECS, woodDojoTransform: Transform, woodDojo: WoodDojo, dorm:DormitoryComponent, homeEntity:Entity) {
    const booker = ecs.addEntity();
    
    ecs.addComponent(booker, new Transform(woodDojoTransform.x - 200, woodDojoTransform.y));
    ecs.addComponent(booker, new Character({
        name: "Professor Booker",
        description: "The professor of the academy. He is a master of the wood element.",
        type: CharacterType.PROFESSOR,
    }));
    ecs.addComponent(booker, new HomeComponent(homeEntity));
    ecs.addComponent(booker, new ActionIntentComponent());
    ecs.addComponent(booker, new LocomotionComponent());
    ecs.addComponent(booker, new HarvesterComponent());
    ecs.addComponent(booker, new ActiveBuffsComponent());
    ecs.addComponent(booker, new WorkerComponent());
    ecs.addComponent(booker, new NeedsComponent());
    ecs.addComponent(booker, createStandardSchedule());

    woodDojo.assignedCharacters.push(booker);
    dorm.assignedCharacters.push(booker);

    return booker;
}


// ---

import { StoryEventDefinition } from "./StoryEventTypes";
import { ECS } from "../../ECS";

export const CaveExploreStory: StoryEventDefinition = {
    id: "cave_explore",
    startPageId: "intro",

    pages: {
        intro: {
            id: "intro",
            imagePath: "assets/story/cave_intro.png",
            text: `You stand before a mossy cave entrance. A faint rustle echoes from within, followed by a soft squeak. 
Could someoneor somethingbe inside? The breeze carries the scent of damp earth and mushrooms.`,
            options: [
                { label: "Leave quietly", close: true },
                { label: "Sneak in", nextPageId: "sneak" },
                { label: "Call softly into the cave", nextPageId: "call" }
            ]
        },

        sneak: {
            id: "sneak",
            imagePath: "assets/story/cave_sneak.png",
            text: `You tiptoe into the dimness, careful not to disturb the moss underfoot. Suddenly, you hear a tiny sneeze.`,
            options: [
                {
                    label: "Peek around the rock",
                    nextPageId: "reveal_sproutling"
                },
                {
                    label: "Back away politely",
                    close: true
                }
            ]
        },

        call: {
            id: "call",
            imagePath: "assets/story/cave_call.png",
            text: `"Hello?" you whisper. A soft *"honk!"* replies. Something waddles closer.`,
            options: [
                {
                    label: "Stand your ground",
                    nextPageId: "reveal_sproutling"
                },
                {
                    label: "Hide and watch",
                    nextPageId: "reveal_sproutling"
                }
            ]
        },

        reveal_sproutling: {
            id: "reveal_sproutling",
            imagePath: "assets/story/sproutling_reveal.png",
            text: `A tiny Sproutling emerges! Its leafy head shakes from side to side, trying to appear intimidatingbut it stumbles on a root and tumbles forward in a squeaky puff.`,
            options: [
                {
                    label: "Help it up",
                    nextPageId: "friend"
                },
                {
                    label: "Offer it a snack",
                    nextPageId: "friend"
                }
            ]
        },

        friend: {
            id: "friend",
            imagePath: "assets/story/sproutling_friend.png",
            text: `The Sproutling beams! It flutters its leafy arms and gives you a shiny acorn as thanks. Youre now friends.`,
            options: [
                {
                    label: "Wave goodbye",
                    close: true,
                    effect: (ecs: ECS) => {
                        console.log("Friendship with sproutling recorded.");
                        // Example: Add friendship component, flag, or item
                    }
                }
            ]
        }
    }
};


// ---

import { Component } from "../../ECS";

export class StoryEventStateComponent extends Component {
    constructor(
        public eventId: string,
        public currentPageId: string
    ) {
        super();
    }
}


// ---

import { System, Entity } from "../../ECS";
import { EventBus } from "../../EventBus";
import { GameEvent } from "../../consts/GameEvent";
import { StoryEventStateComponent } from "./StoryEventComponent";
import { StoryEventDefinition } from "./StoryEventTypes";

export class StoryEventSystem extends System {
    public update(entities: Set<number>, delta: number): void {
        
    }
    
    componentsRequired = new Set<Function>([StoryEventStateComponent]);

    private activeEvent: StoryEventDefinition | null = null;
    private allEvents: Record<string, StoryEventDefinition>;

    constructor(allEvents: Record<string, StoryEventDefinition>) {
        super();
        this.allEvents = allEvents;
    }

    public start(eventId: string) {
        const event = this.allEvents[eventId];
        if (!event) return;
        this.activeEvent = event;

        const entity = this.ecs.addEntity();
        this.ecs.addComponent(entity, new StoryEventStateComponent(eventId, event.startPageId));

        EventBus.emit(GameEvent.StoryEventStarted, event.pages[event.startPageId]);
    }

    public advance(entity: Entity, nextPageId?: string) {
        const state = this.ecs.getComponent(entity, StoryEventStateComponent);
        if (!state || !this.activeEvent) return;

        if (!nextPageId) {
            this.ecs.removeEntity(entity);
            EventBus.emit(GameEvent.StoryEventEnded);
            return;
        }

        state.currentPageId = nextPageId;
        EventBus.emit(GameEvent.StoryEventPageChanged, this.activeEvent.pages[nextPageId]);
    }
}


// ---

import { ECS } from "../../ECS";

export interface StoryOption {
    label: string;
    nextPageId?: string;
    condition?: (ecs: ECS) => boolean;
    effect?: (ecs: ECS) => void;
    close?: boolean;
    entity?:number;
}

export interface StoryEventPage {
    id: string;
    imagePath: string;
    text: string;
    options: StoryOption[];
    entity?: number;
}

export interface StoryEventDefinition {
    id: string;
    pages: Record<string, StoryEventPage>;
    startPageId: string;
    entity?:number;
}


// ---

import { Component, ECS } from "../../ECS";
import { TimeConfig } from "../../config/TimeConfig";

export class TimeComponent extends Component {
    constructor(
        public minutesElapsed: number = 4*TimeConfig.MinutesPerHour,
        public minute: number = 0,
        public hour: number = 4,
        public day: number = 0,
        public semester: number = 0,
        public speedFactor: number = 1
    ) {
        super();
    }
}

let worldEntity:number;
let hasWorlEntity:boolean;

export function getCurrentHour(ecs: ECS): number {
    if (!hasWorlEntity){
        worldEntity = ecs.getEntitiesWithComponent(TimeComponent)[0];
        hasWorlEntity = true;
    }
    const time = ecs.getComponent(worldEntity, TimeComponent);
    return time?.hour || 0;
}

export function getTime(ecs: ECS): TimeComponent {
    if (!hasWorlEntity){
        worldEntity = ecs.getEntitiesWithComponent(TimeComponent)[0];
        hasWorlEntity = true;
    }
    const time = ecs.getComponent(worldEntity, TimeComponent);
    return time!;
}


// ---

import {Entity, System} from "../../ECS";
import {InputComponent} from "../input/InputComponent.ts";
import {TimeComponent} from "./TimeComponent.ts";
import {TimeConfig} from "../../config/TimeConfig.ts";
import {EventBus} from "../../EventBus.ts";
import {GameEvent} from "../../consts/GameEvent.ts";

export class TimeSystem extends System {
    public componentsRequired = new Set<Function>([TimeComponent, InputComponent]);

    update(entities: Set<Entity>, delta: number): void {
        for (const entity of entities) {
            const time = this.ecs.getComponent(entity, TimeComponent);
            const input = this.ecs.getComponent(entity, InputComponent);

            const speedMultiplier = TimeConfig.SpeedMultipliers[input.speed];
            time.speedFactor = speedMultiplier;

            if (speedMultiplier === 0) continue;

            // Calculate how much real time has passed
            const realSecondsPassed = delta / 1000;
            const inGameHours = (realSecondsPassed / TimeConfig.RealSecondsPerHour) * speedMultiplier;
            const inGameMinutes = inGameHours * TimeConfig.MinutesPerHour;

            this.advanceTime(time, inGameMinutes);
        }
    }

    private advanceTime(time: TimeComponent, minutesToAdd: number) {
        time.minutesElapsed += minutesToAdd;
        time.minute += minutesToAdd;

        while (time.minute >= TimeConfig.MinutesPerHour) {
            time.minute -= TimeConfig.MinutesPerHour;
            time.hour += 1;
        }

        while (time.hour >= TimeConfig.HoursPerDay) {
            time.hour -= TimeConfig.HoursPerDay;
            time.day += 1;
        }

        while (time.day >= TimeConfig.DaysPerSemester) {
            time.day -= TimeConfig.DaysPerSemester;
            time.semester += 1;
        }
        
        EventBus.emit(GameEvent.SetTime, time.minutesElapsed);
    }
}


// ---

import { Component } from "../../ECS";
import { ResourceType } from "../resources/ResourceType";

export type ResourceDrop = {
    type:ResourceType,
    amount:number
}

export class HarvestableComponent extends Component {
    public maxAmount: number = 0;
    public harvestable: boolean = true;
    public harvested: boolean = false;
    
    constructor(public amount: number, public drops: ResourceDrop[]) {
        super();
        this.amount = amount;
        this.maxAmount = amount;
    }
}

// ---

import { Component } from "../../ECS";

export class HarvesterComponent extends Component {
    public harvestPerMinute: number = 5;

    constructor() {
        super();
    }
}

// ---

import {Component} from "../../ECS.ts";
import {PlantSpriteKey} from "../../display/setup/SpriteLibrary.ts";

export class Tree extends Component {
    public selectedForCutting = false;
    public isBeingCut = false;
    
    constructor(
        public type: PlantSpriteKey
    ) {
        super();
    }
}

// ---

import { System, Entity, ECS } from "../../ECS";
import { ActionIntentComponent } from "../action-intent/ActionIntentComponent";
import { CharacterAction, isChoppingData } from "../action-intent/actionIntentData";
import { HarvestableComponent } from "./HarvestableComponent";
import { HarvesterComponent } from "./HarvesterComponent"; // For harvest speed/ability
import { TimeComponent } from "../time/TimeComponent";
import { ResourceComponent } from "../resources/ResourceComponent";
import { ResourceType } from "../resources/ResourceType";
import { InteractionSlots } from "../../components/InteractionSlots";
import { Tree } from "../trees/Tree";

export class TreeHarvestingSystem extends System {
    public componentsRequired = new Set<Function>([
        ActionIntentComponent,
        HarvesterComponent
    ]);

    public update(entities: Set<Entity>, delta: number): void {
        const timeEntity = this.ecs.getEntitiesWithComponent(TimeComponent)[0];
        if (!timeEntity) return; // No time, no progress

        const time = this.ecs.getComponent(timeEntity, TimeComponent);
        if (time.speedFactor === 0) return; // Game paused
        
        const scaledDeltaSeconds = (delta / 1000) * time.speedFactor;

        for (const characterEntity of entities) {
            const actionIntent = this.ecs.getComponent(characterEntity, ActionIntentComponent);

            if (actionIntent.currentPerformedAction !== CharacterAction.CHOPPING || 
                !isChoppingData(actionIntent.actionData)) {
                continue;
            }

            const choppingData = actionIntent.actionData; // Known to be ChoppingData
            const targetTreeId = choppingData.targetTreeEntityId;

            if (!this.ecs.hasEntity(targetTreeId)) {
                this.abortHarvest(actionIntent, characterEntity, null);
                continue;
            }

            const tree = this.ecs.getComponent(targetTreeId, Tree);
            const harvestable = this.ecs.getComponent(targetTreeId, HarvestableComponent);
            const harvester = this.ecs.getComponent(characterEntity, HarvesterComponent);

            if (!tree || !harvestable || !harvester) {
                this.abortHarvest(actionIntent, characterEntity, targetTreeId, tree);
                continue;
            }

            // Re-validate conditions, though IntentActionSystem's helper should have ensured this.
            // This is a safety check.
            if (!tree.selectedForCutting || !harvestable.harvestable || harvestable.harvested) {
                this.abortHarvest(actionIntent, characterEntity, targetTreeId, tree);
                continue;
            }

            tree.isBeingCut = true;

            const harvestAmountThisFrame = harvester.harvestPerMinute * scaledDeltaSeconds;
            harvestable.amount -= harvestAmountThisFrame;

            if (harvestable.amount <= 0) {
                this.finalizeHarvest(this.ecs, harvestable, tree);
                this.finishHarvest(actionIntent, characterEntity, targetTreeId);
            }
        }
    }

    private finalizeHarvest(ecs: ECS, harvestable: HarvestableComponent, tree: Tree): void {
        harvestable.amount = 0;
        harvestable.harvested = true;
        harvestable.harvestable = false;
        tree.isBeingCut = false;
        tree.selectedForCutting = false;

        const resourcesEntity = ecs.getEntitiesWithComponent(ResourceComponent)[0];
        if (resourcesEntity) {
            const resources = ecs.getComponent(resourcesEntity, ResourceComponent);
            harvestable.drops.forEach((drop) => {
                resources.amounts[drop.type as ResourceType] = (resources.amounts[drop.type as ResourceType] || 0) + drop.amount;
            });
        }
    }

    private clearActionState(aic: ActionIntentComponent, characterEntity: Entity, treeId: Entity | null, treeComponent?: Tree) {
        if (treeComponent) treeComponent.isBeingCut = false;
        if (treeId !== null) {
            const slots = this.ecs.getComponent(treeId, InteractionSlots);
            slots?.releaseAll(characterEntity);
        }
        aic.currentPerformedAction = CharacterAction.IDLE;
        aic.actionData = null;
    }

    private abortHarvest(aic: ActionIntentComponent, characterEntity: Entity, treeId: Entity | null, tree?: Tree): void {
        this.clearActionState(aic, characterEntity, treeId, tree);
    }

    private finishHarvest(aic: ActionIntentComponent, characterEntity: Entity, treeId: Entity): void {
        this.clearActionState(aic, characterEntity, treeId, this.ecs.getComponent(treeId,Tree));
    }
}

// ---

import { Component } from "../../ECS.ts";

export class WeatherComponent extends Component {
    constructor(
        public windDirection: 1 | -1 = 1,
        public windStrength: number = 0.5,
        public cloudCover: number = 0.5,
    ) {
        super();
    }
}


// ---

import { System } from "../../ECS.ts";
import { Entity } from "../../ECS.ts";
import { WeatherComponent } from "./WeatherComponent.ts";
import {SimplexNoise} from "../../../utils/SimplexNoise.ts";
import {WeatherConfig} from "../../config/WeatherConfig.ts";
import {EventBus} from "../../EventBus.ts";
import {GameEvent} from "../../consts/GameEvent.ts";
import {TimeComponent} from "../time/TimeComponent.ts";

export class WeatherSystem extends System {
    componentsRequired = new Set<Function>([WeatherComponent, TimeComponent]);
    private noise = new SimplexNoise(1); // Seed for consistent variation
    private time = 0;

    update(entities: Set<Entity>, delta: number): void {
        if (entities.size === 0) return;
        if (entities.size > 1) {
            console.warn("WeatherSystem is not designed to handle multiple entities.");
        }
        for (const entity of entities) {
            this.updateWeather(entity, delta);
        }
    }
    
    updateWeather(entity: Entity, delta: number) {
        const weather = this.ecs.getComponent(entity, WeatherComponent);
        const time = this.ecs.getComponent(entity, TimeComponent);

        this.time += delta * time.speedFactor;

        // Wind Strength
        const t = this.time * WeatherConfig.Wind.StrengthFrequency;
        const windRaw = this.noise.noise(t, 0);             // [-1, 1]
        const windNorm = (windRaw + 1) / 2;                 // [0, 1]
        const biased = this.biasedSample(windNorm, WeatherConfig.Wind.Bias);

        weather.windStrength = Phaser.Math.Linear(
            WeatherConfig.Wind.MinSpeed,
            WeatherConfig.Wind.MaxSpeed,
            biased
        ); // Result in px/game-minute


        // Wind Direction
        const t1 = this.time * WeatherConfig.Wind.DirectionFrequency;
        const dirNoise = this.noise.noise(t1, 1000);
        weather.windDirection = dirNoise > WeatherConfig.Wind.DirectionThreshold ? 1 : -1;

        // Cloud Cover (Inverted Bell)
        const t2 = this.time * WeatherConfig.CloudCover.Frequency;
        const coverNoise = this.noise.noise(t2, WeatherConfig.CloudCover.NoiseOffset);
        const coverNorm = (coverNoise + 1) / 2;
        weather.cloudCover = Phaser.Math.Clamp(
            this.biasedSample(coverNorm, 1 - WeatherConfig.CloudCover.Bias),
            0,
            1
        );

        EventBus.emit(GameEvent.SetWeather, weather);
    }

    private biasedSample(x: number, bias: number): number {
        // bias  [0, 1], where 0 = favor low, 1 = favor high
        const k = Math.max(0.0001, bias); // avoid log(0)
        return x / ((1 - k) / k * (1 - x) + 1);
    }
}

// ---

import { Boot } from './scenes/Boot';
import { Game } from './scenes/Game';
import { AUTO, Game as PhaserGame } from 'phaser';
import { Preloader } from './scenes/Preloader';
import OutlinePipelinePlugin from 'phaser3-rex-plugins/plugins/outlinepipeline-plugin.js';
import {Config} from "./config/Config.ts";

//  Find out more information about the Game Config at:
//  https://newdocs.phaser.io/docs/3.70.0/Phaser.Types.Core.GameConfig
const config: Phaser.Types.Core.GameConfig = {
    type: AUTO,
    width: Config.Display.Width,
    height: Config.Display.Height,
    parent: 'game-container',
    backgroundColor: '#028af8',
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
    },
    scene: [
        Boot,
        Preloader,
        Game
    ],
    plugins: {
        global: [
            { key: 'rexOutlinePipeline', plugin: OutlinePipelinePlugin, start: true}
        ]
    },
    render: {
        pixelArt: true
    },
    physics: {
        default: 'arcade',
        arcade: {
            debug: true
        }
    },
    disableContextMenu: true
};

const StartGame = (parent: string) => {
    return new PhaserGame({ ...config, parent });
}

export default StartGame;

// ---

import {GameState} from "../logic/serialization/GameState.ts";

const SAVE_KEY = "zooniversity_save";

export interface SaveManager {
    save(state: GameState): void;
    load(): GameState | null;
    clear(): void;
}

export const saveManager: SaveManager = {
    save(state) {
        localStorage.setItem(SAVE_KEY, JSON.stringify(state));
    },
    load() {
        const raw = localStorage.getItem(SAVE_KEY);
        return raw ? JSON.parse(raw) : null;
    },
    clear() {
        localStorage.removeItem(SAVE_KEY);
    },
};


// ---

import { Scene } from 'phaser';

export class Boot extends Scene
{
    constructor ()
    {
        super('Boot');
    }

    preload ()
    {
        //  The Boot Scene is typically used to load in any assets you require for your Preloader, such as a game logo or background.
        //  The smaller the file size of the assets, the better, as the Boot Scene itself has no preloader.

        this.load.image('background', 'assets/bg.png');
    }

    create ()
    {
        this.scene.start('Preloader');
    }
}


// ---

import {EventBus} from '../EventBus';
import { Scene } from 'phaser';
import {ECS} from "../ECS.ts";
import {GameDisplay} from "../display/GameDisplay.ts";
import {setSceneType} from "../../ui/ui_switcher/useActiveSceneType.ts";
import {GameEvent} from "../consts/GameEvent.ts";
import {GameState} from "../logic/serialization/GameState.ts";
import {loadFromState} from "../logic/serialization/GameStateSerializer.ts";
import {loadNewGame} from "../logic/serialization/MapSerializer.ts";
import {TimeTintPipeline} from "../../render/pipelines/TimeTintPipeline.ts";
import { init} from '../logic/serialization/init.ts';

export class Game extends Scene
{
    gameDisplay: GameDisplay;
    ecs:ECS;
    
    destroyQueue: Array<()=>void> = [];
    
    constructor ()
    {
        super('Game');
    }
    
    update(time: number, delta: number) {
        super.update(time, delta);
        
        this.ecs?.update(delta);
        this.gameDisplay?.update(delta);
    }

    create ()
    {
        EventBus.emit('current-scene-ready', this);
        setSceneType('game');

        const pipeline = new TimeTintPipeline(this.game);
        (this.renderer as Phaser.Renderer.WebGL.WebGLRenderer)
            .pipelines
            .add('TimeTint', pipeline);
 
        this.ecs = new ECS();
        
        EventBus.on(GameEvent.NewGame, () => {
            loadNewGame(this.ecs, this);
            init(this)
        });

        EventBus.on(GameEvent.LoadGame, (state: GameState) => {
            loadFromState(this.ecs, state);
            init(this)
        });

        this.events.on('destroy', this.destroy);
    }

    private destroy() {
        this.events.off('destroy', this.destroy);

        this.destroyQueue.forEach(fn => fn());
        this.destroyQueue = [];
        
        this.gameDisplay.destroy();

        EventBus.off(GameEvent.SetTimeSpeed);
        EventBus.off(GameEvent.SetTime);
        EventBus.off(GameEvent.NewGame);
        EventBus.off(GameEvent.LoadGame);
    }
}


// ---

import { Scene } from 'phaser';
import { Config } from '../config/Config';

export class Preloader extends Scene
{
    constructor ()
    {
        super('Preloader');
    }

    init ()
    {

        //  A simple progress bar. This is the outline of the bar.
        this.add.rectangle(512, 384, 468, 32).setStrokeStyle(1, 0xffffff);

        //  This is the progress bar itself. It will increase in size from the left based on the % of progress.
        const bar = this.add.rectangle(512-230, 384, 4, 28, 0xffffff);

        //  Use the 'progress' event emitted by the LoaderPlugin to update the loading bar
        this.load.on('progress', (progress: number) => {

            //  Update the progress bar (our bar is 464px wide, so 100% = 464px)
            bar.width = 4 + (460 * progress);

        });
    }

    preload ()
    {
        this.load.json("panelRegistry", "assets/data/panels.json");

        this.load.setPath('assets/plants');

        const animFrameConfig =                 {
            frameWidth: Config.AnimImports.FrameWidth*2,
            frameHeight: Config.AnimImports.FrameHeight*2,
            endFrame: Config.AnimImports.NumberOfFrames-1
        };
        
        for (let i = 0; i < Config.AnimImports.NumberOfTrees; i++) {
            this.load.spritesheet(
                `tree${i}`, 
                `tree${i}.png`,
                animFrameConfig
            );
        }
        
        for (let i = 0; i < Config.AnimImports.NumberOfBushes; i++) {
            this.load.spritesheet(
                `bush${i}`,
                `bush${i}.png`,
                animFrameConfig
            );
        }

        this.load.setPath('assets/hill');

        const staticFrameConfig = {
            frameWidth: Config.AnimImports.StaticWidth,
            frameHeight: Config.AnimImports.StaticHeight,
            endFrame: 0
        };

        const caveFrameConfig = {
            frameWidth: Config.AnimImports.StaticHeight,
            frameHeight: Config.AnimImports.StaticHeight,
            endFrame: 0
        };
        
        this.load.spritesheet('hill', 'hill.png', staticFrameConfig);
        this.load.spritesheet('home-lvl-1', 'home-lvl-1.png', staticFrameConfig);
        this.load.spritesheet('home-lvl-1-inside', 'home-lvl-1-inside.png', staticFrameConfig);
        this.load.spritesheet('kitchen-lvl-1', 'kitchen-lvl-1.png', staticFrameConfig);
        this.load.spritesheet('kitchen-lvl-1-inside', 'kitchen-lvl-1-inside.png', staticFrameConfig);
        this.load.spritesheet('cave', 'cave.png', caveFrameConfig);
        this.load.spritesheet('wood_dojo', 'wood_dojo.png', caveFrameConfig);


        this.load.setPath('assets/maps');
        this.load.json('forestMap', 'forestMap.json');

        this.load.setPath('assets/clouds');

        for (let i = 0; i < 4; i++) {
            this.load.spritesheet(
                `cloud${i}`,
                `cloud${i}.png`,
                caveFrameConfig
            );
        }

        this.load.setPath('assets');

        this.load.spritesheet('night_sky', 'night_sky.png', caveFrameConfig);


        const charFrameConfig = {
            frameWidth: Config.AnimImports.StaticHeight,
            frameHeight: Config.AnimImports.StaticWidth,
            endFrame: 0
        };

        this.load.setPath('assets/characters/booker');
        this.load.spritesheet('booker_char', 'booker_char.png', charFrameConfig);
        this.load.spritesheet('booker_icon', 'booker_icon.png', caveFrameConfig);

        this.load.setPath('assets/icons');
        this.load.spritesheet('axe_icon', 'axe_icon.png', caveFrameConfig);
    }

    create ()
    {
        this.scene.start(Config.EntryScene);
    }
}


// ---

import React from 'react';
import ReactDOM from 'react-dom/client';
import {App} from './App.tsx';

ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
)


// ---

// TimeTintPipeline.ts
import Phaser from 'phaser';
import fragShader from '../../shaders/tint.frag?raw';

export class TimeTintPipeline extends Phaser.Renderer.WebGL.Pipelines.SinglePipeline {
    constructor(game: Phaser.Game) {
        super({
            game,
            fragShader,
        });
    }

    setTintColor(color: Phaser.Display.Color) {
        this.set4f(
            'uTimeTint',
            color.redGL,
            color.greenGL,
            color.blueGL,
            1.0
        );
    }

    setCloudAlpha(alpha: number) {
        this.set1f('uCloudAlpha', Phaser.Math.Clamp(alpha, 0, 1));
    }

    setResolution(width: number, height: number) {
        this.set2f('uResolution', width, height);
    }

    setLightingTexture(rt: Phaser.GameObjects.RenderTexture | null) {
        const glTex = (rt as any)?._renderer?.glTexture;

        if (glTex) {
            this.setBoolean('uUseLighting', true);
            this.setTexture2D(glTex);
        } else {
            this.setBoolean('uUseLighting', false);
        }
    }
}


// ---

import React, { useEffect, useState } from "react";
import {GameEvent} from "../../game/consts/GameEvent.ts";
import {EventBus} from "../../game/EventBus.ts";
import {MainMenu} from "./main_menu/MainMenu.tsx";
import {TimeControls} from "./time_controls/TimeControls.tsx";
import {WeatherPanel} from "./weather/WeatherPanel.tsx";
import {SelectionPanel} from "./selection/SelectionPanel.tsx";
import { ResourceDisplay } from "./resources/ResourceDisplay.tsx";
import { CharacterPortraitsLayer } from "./character_portaits/CharacterPortraitsLayer.tsx";

export const GameContainer: React.FC = () => {
    const [gameLoaded, setGameLoaded] = useState(false);

    useEffect(() => {
        const handler = () => setGameLoaded(true);
        EventBus.on(GameEvent.GameLoaded, handler);
        return () => {
            EventBus.off(GameEvent.GameLoaded, handler);
        };
    }, []);

    return !gameLoaded ? <MainMenu /> : 
    <>
        <TimeControls/>
        <WeatherPanel/>
        <SelectionPanel/>
        <ResourceDisplay/>
        <CharacterPortraitsLayer/>
    </>
};


// ---

/* src/ui/common/BuffView.css */

.buff-view-container {
    width: 32px;
    height: 32px;
    position: relative;
    border: 1px solid #444;
    border-radius: 3px;
    overflow: hidden;
    background-color: #222;
    cursor: help;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 1px 2px rgba(0,0,0,0.5);
  }
  
  .buff-view-background-bar {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #3a3a3a;
    z-index: 1;
  }
  
  .buff-view-progress-fill {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: #666; 
    z-index: 2;
    transition: height 0.2s linear;
  }
  
  .buff-view-container.is-buff .buff-view-progress-fill {
    background-color: #38761d; /* Green */
  }
  
  .buff-view-container.is-debuff .buff-view-progress-fill {
    background-color: #cc0000; /* Red */
  }
  
  .buff-view-icon {
    position: relative;
    width: calc(100% - 8px);
    height: calc(100% - 8px);
    object-fit: contain;
    z-index: 3;
  }

// ---

import React from 'react';
import './BuffView.css';
import { DisplayableBuffData } from '../../../game/display/game/data_panel/character/deriveBuffs';

interface BuffViewProps {
  data: DisplayableBuffData;
}

export const BuffView: React.FC<BuffViewProps> = ({ data }) => {
  const progressPercent = (data.totalDurationMinutes > 0 && data.remainingDurationMinutes >= 0)
    ? (data.remainingDurationMinutes / data.totalDurationMinutes) * 100
    : (data.remainingDurationMinutes > 0 ? 100 : 0); 

  const buffClass = data.isBuff ? 'is-buff' : 'is-debuff';
  
  return (
    <div 
      className={`buff-view-container ${buffClass}`} 
    >
      <div className="buff-view-background-bar">
        <div 
          className="buff-view-progress-fill" 
          style={{ height: `${progressPercent}%` }} 
        />
      </div>
      <img 
        src={data.iconAssetKey} 
        alt={data.displayName} 
        className="buff-view-icon" 
      />
    </div>
  );
};

// ---

import React from 'react';
import './CharacterPortraits.css';
import { EventBus } from '../../../game/EventBus';
import { UIEvent } from '../../../game/consts/UIEvent';

type CharacterPortraitProps = {
  data: {
    entity: number;
    pos: { x: number; y: number };
    character: {
      icon: string;
      type: string;
    };
  };
};

export const CharacterPortrait: React.FC<CharacterPortraitProps> = ({ data }) => {
  return (
    <div
      className="character-portrait"
      style={{
        left: `${data.pos.x}px`,
        top: `${data.pos.y}px`,
        pointerEvents: 'all',
      }}
      onClick={() => {
        EventBus.emit(UIEvent.PortraitClicked, data.entity);
    }}
    >
      <img src={data.character.icon} alt={`${data.character.type} Icon`} />
    </div>
  );
};


// ---

.character-portrait {
    position: absolute;
    width: 48px;
    height: 48px;
    background-color: white;
    border: 2px solid black;
    border-radius: 50%;
    overflow: hidden;
    pointer-events: none;
    transform: translate(-50%, -50%);
  }
  
  .character-portrait img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  

// ---

import React, { useEffect, useRef, useState } from 'react';
import './CharacterPortraits.css';
import { CharacterPortrait } from './CharacterPortrait';
import { EventBus } from '../../../game/EventBus';
import { GameEvent } from '../../../game/consts/GameEvent';

type CharacterUpdateData = {
  id: number;
  pos: { x: number; y: number };
  character: {
    icon: string;
    type: string;
  };
};

export const CharacterPortraitsLayer: React.FC = () => {
  const [portraits, setPortraits] = useState<Record<number, CharacterUpdateData>>({});
  const seenThisFrameRef = useRef<Set<number>>(new Set());
  const tickRef = useRef(0);

  // Reset seenThisFrame every animation frame
  useEffect(() => {
    let raf: number;
    const loop = () => {
      seenThisFrameRef.current.clear();
      tickRef.current++;
      raf = requestAnimationFrame(loop);
    };
    raf = requestAnimationFrame(loop);
    return () => cancelAnimationFrame(raf);
  }, []);

  useEffect(() => {
    const handleUpdate = (data: CharacterUpdateData) => {
      seenThisFrameRef.current.add(data.id);

      setPortraits(prev => ({
        ...prev,
        [data.id]: data
      }));
    };

    EventBus.on(GameEvent.CharacterUpdate, handleUpdate);
    return () => {
      EventBus.off(GameEvent.CharacterUpdate, handleUpdate);
    };
  }, []);

  return (
    <>
      {Object.entries(portraits).map(([id, data]) => (
        <CharacterPortrait key={id} data={{ ...data, entity: +id }} />
      ))}
    </>
  );
};

// ---

@import url('https://fonts.googleapis.com/css2?family=Chewy&display=swap');

.main-menu {
    position: static;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
}

.menu-background {
    background: #000000 !important;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: contain; /* Preserve aspect ratio */
    object-position: center;
    z-index: 0;
    pointer-events: none; /* So it doesn't block buttons */
}

.menu-buttons {
    position: absolute;
    bottom: 40px;
    width: 100%;
    display: flex;
    justify-content: center;
    gap: 32px;
    z-index: 10;
}


.menu-button {
    font-family: 'Chewy', cursive;
    font-size: 1.6rem;
    padding: 24px 56px;
    background-color: #fce8c6; /* soft parchment tone */
    border: 3px solid #6b4c3b; /* rich brown */
    border-radius: 12px;
    color: #2f1f16; /* darker brown text */
    cursor: pointer;
    transition:
        transform 0.2s ease-out,
        box-shadow 0.2s ease-out,
        background-color 0.2s ease-in;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.menu-button:hover:not(.disabled) {
    transform: translateY(-4px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
}

.menu-button:active:not(.disabled) {
    transform: scale(0.96);
}

.menu-button.disabled {
    opacity: 0.5;
    cursor: not-allowed;
    pointer-events: none;
}


// ---

import {MenuButton} from "./MenuButton.tsx";
import {EventBus} from "../../../game/EventBus.ts";
import {GameEvent} from "../../../game/consts/GameEvent.ts";
import {useSaveManager} from "./useSaveManager.tsx";
import "./MainMenu.css";

export const MainMenu: React.FC = () => {
    const { current } = useSaveManager();

    return (
        <div className="main-menu">
            <img src="assets/splash.png" alt="Main Menu" className="menu-background" />
            <div className="menu-buttons">
                <MenuButton title="NEW GAME" onClick={() => EventBus.emit(GameEvent.NewGame)} />
                <MenuButton title="CONTINUE" onClick={() => EventBus.emit(GameEvent.LoadGame, current)} enabled={!!current} />
                <MenuButton title="LOAD" onClick={() => {}} enabled={true} />
            </div>
        </div>
    );
};


// ---

import React from "react";

interface MenuButtonProps {
    title: string;
    onClick: () => void;
    enabled?: boolean;
}

export const MenuButton: React.FC<MenuButtonProps> = ({ title, onClick, enabled = true }) => {
    return (
        <button
            className={`menu-button${enabled ? "" : " disabled"}`}
            onClick={enabled ? onClick : undefined}
            disabled={!enabled}>
            {title}
            </button>
        );
};


// ---

import { useState, useEffect } from 'react';
import {GameState} from "../../../game/logic/serialization/GameState.ts";
import {saveManager} from "../../../game/save_manager/SaveManager.ts";

export function useSaveManager() {
    const [current, setCurrent] = useState<GameState | undefined>();

    useEffect(() => {
        const loaded = saveManager.load();
        if (loaded) setCurrent(loaded);
    }, []);

    return { current };
}


// ---

.resource-display {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 100;
    display: flex;
    flex-direction: column;
    gap: 8px;
    background-color: rgba(24, 24, 24, 0.6);
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 0 8px rgba(0,0,0,0.3);
    pointer-events: none;
}

.resource-row {
    display: flex;
    align-items: center;
    gap: 8px;
}

.resource-icon {
    width: 24px;
    height: 24px;
    image-rendering: pixelated;
}

.resource-value {
    font-size: 1.1rem;
    font-weight: bold;
    color: #fff;
    min-width: 40px;
    text-align: right;
}


// ---

import React, { useEffect, useState } from "react";
import "./ResourceDisplay.css";
import { ResourceConfig } from "../../../game/logic/resources/ResourceConfig";
import { ResourceTracker } from "../../../game/logic/resources/ResourceTracker";
import { ResourceType } from "../../../game/logic/resources/ResourceType";
import { formatResourceNumber } from "./formatResourceNumber";

export const ResourceDisplay: React.FC = () => {
    const [values, setValues] = useState<Record<ResourceType, number>>(() =>
        Object.fromEntries(Object.values(ResourceType).map(key => [key, 0])) as Record<ResourceType, number>
    );

    useEffect(() => {
        const handle = (update: Partial<Record<ResourceType, number>>) => {
            setValues(prev => ({ ...prev, ...update }));
        };
        ResourceTracker.subscribe(handle);
        return () => ResourceTracker.unsubscribe(handle);
    }, []);

    return (
        <div className="resource-display">
            {Object.values(ResourceType).map((type) => {
                const { icon, description } = ResourceConfig[type];
                const value = values[type];
                return (
                    <div className="resource-row" key={type} title={description}>
                        <img src={icon} alt={type} className="resource-icon" />
                        <span className="resource-value">{formatResourceNumber(value)}</span>
                    </div>
                );
            })}
        </div>
    );
};


// ---

export function formatResourceNumber(value: number): string {
    if (value < 1000) return `${value}`;
    if (value < 1_000_000) return `${(value / 1000).toFixed(1)}K`;
    if (value < 1_000_000_000) return `${(value / 1_000_000).toFixed(1)}M`;
    return `${(value / 1_000_000_000).toFixed(1)}B`;
}


// ---

import React from "react";
import { useSelectedTool } from "./useSelectedTool.ts";
import { PanelActionImplementation } from "../../../game/display/game/data_panel/PanelAction.ts";

interface ActionButtonProps {
    action: PanelActionImplementation;
}

export const ActionButton: React.FC<ActionButtonProps> = ({ action }) => {
    const selectedTool = useSelectedTool();
    const isActive = action.type === selectedTool;

    return (
        <button
            className={`action-button ${isActive ? "active" : ""}`}
            style={{
                backgroundImage: action.icon ? `url(${action.icon})` : undefined,
            }}
            onClick={action.action}
        />
    );
};


// ---

:root {
    --panel-transition-ms: 300ms;
}

.selection-panel {
    position: absolute;
    top: 0;
    left: 0;
    width: 33.333%;
    height: 80%;
    z-index: 100;
    transform: translateX(-100%);
    transition:
        transform var(--panel-transition-ms) ease-in-out,
        height var(--panel-transition-ms) ease-in-out;
    pointer-events: none;
}

.selection-panel.open {
    transform: translateX(0);
    pointer-events: auto;
}

.selection-panel.collapsed {
    height: 12%;
}

.selection-panel-content {
    width: 100%;
    height: 100%;
    background-color: rgba(24, 24, 24, 0.95);
    display: flex;
    flex-direction: column;
    position: relative;
    overflow: hidden;
    opacity: 0;
    transition: opacity var(--panel-transition-ms) ease-in-out;
}

.selection-panel-content.fade-in {
    opacity: 1;
}

.selection-panel-content.fade-out {
    opacity: 0;
}

.selection-panel-bg {
    height: 100%;
    background-size: cover;
    background-repeat: no-repeat;
    background-position: center;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    display: flex;
    flex-direction: column;
}

.selection-panel-header {
    padding: 16px;
    color: #fff;
    cursor: pointer;
    flex-shrink: 0;
}

.selection-panel-header h2 {
    margin: 0 0 8px;
    font-size: 1.5rem;
}

.selection-panel-header p {
    margin: 0;
    font-size: 1rem;
    color: #ccc;
}

.selection-panel-body {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    padding: 0 16px 16px;
}

.text-bg {
    background-color: rgba(0, 0, 0, 0.5);
    padding: 0.2em 0.4em;
    border-radius: 4px;
}

.info-line {
    display: flex;
    margin-block-start: unset;
    margin-block-end: unset;
    margin-bottom: 4px;
}

.selection-panel-controls {
    padding: 8px;
    display: flex;
    justify-content: flex-end;
    gap: 8px;
}

.selection-panel-close {
    position: absolute;
    top: 8px;
    right: 8px;
    background: transparent;
    color: white;
    border: none;
    font-size: 1.25rem;
    cursor: pointer;
}

.traits-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    display: flex;
    justify-content: center;
    gap: 16px;
    padding: 0px 4px 4px;
    pointer-events: none;
    z-index: 1;
}

.trait {
    display: flex;
    align-items: center;
    gap: 6px;
    background-color: rgba(0, 0, 0, 0.4);
    padding: 4px 6px;
    border-radius: 6px;
    pointer-events: auto;
}

.trait-icon {
    width: 24px;
    height: 24px;
}

.trait-value {
    font-size: 1rem;
    color: #fff;
    font-weight: 600;
}

.selection-panel-actions {
    display: flex;
    gap: 8px;
    padding: 0px 8px;
    position: absolute;
    bottom: -74px;
    left: 0;
    width: 100%;
    z-index: 101;
}

.action-button {
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    border: 2px solid white;
    border-radius: 8px;
    padding: 8px 12px;
    font-weight: bold;
    font-size: 1rem;
    color: white;
    background-color: rgba(0, 0, 0, 0.6);
    cursor: pointer;
    min-width: 100px;
    width: 64px;
    height: 64px;
    min-width: 0px;
    aspect-ratio: 1 / 1;
    display: flex;
    align-items: center;
    justify-content: center;
    text-shadow: 0 0 4px black;
}

.action-button.active {
    box-shadow: inset 0 0 6px 2px rgba(255, 255, 255, 0.8);
    transform: scale(0.95);
}

.schedule-bar {
    margin-top: auto;
    padding: 8px;
    background-color: rgba(0, 0, 0, 0.4);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 6px;
}


// ---

import React, { useEffect, useRef, useState, useCallback } from "react";
import { EventBus } from "../../../game/EventBus.ts";
import { UIEvent } from "../../../game/consts/UIEvent.ts";
import { GameEvent } from "../../../game/consts/GameEvent.ts";
import { ActionButton } from "./ActionButton.tsx";
import { PanelType } from "../../../game/display/setup/ViewDefinition.ts";
import "./SelectionPanel.css";
import { PanelData } from "../../../game/display/game/data_panel/DataPanelModule.ts";
import { CharacterPanelDataView } from "./character/CharacterPanelDataView.tsx";
import { TreePanelDataView } from "./tree/TreePanelDataView.tsx";

const PanelTypeComponentMap: Partial<Record<PanelType, React.FC<{ data: any; collapsed: boolean }>>> = {
    [PanelType.CHARACTER]: CharacterPanelDataView,
    [PanelType.TREE]: TreePanelDataView
};

export const SelectionPanel: React.FC = () => {
  const [visiblePanel, setVisiblePanel] = useState<PanelData | null>(null);
  const [isVisible, setIsVisible] = useState(false);
  const [fadeState, setFadeState] = useState<"fade-in" | "fade-out">("fade-in");
  const [isCollapsed, setIsCollapsed] = useState(false);

  const panelRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const el = panelRef.current;
    if (!el) return;

    const handleTransitionEnd = () => {
      if (!isVisible) setVisiblePanel(null);
    };

    el.addEventListener("transitionend", handleTransitionEnd);
    return () => el.removeEventListener("transitionend", handleTransitionEnd);
  }, [isVisible]);

  useEffect(() => {
    const handleShow = (panel: PanelData | null) => {
      if (!panel) {
        setFadeState("fade-out");
        setIsVisible(false);
        return;
      }

      if (!isVisible) {
        setVisiblePanel(panel);
        setFadeState("fade-in");
        setIsVisible(true);
        return;
      }

      setFadeState("fade-out");
      setIsVisible(false);
      requestAnimationFrame(() => {
        setVisiblePanel(panel);
        setFadeState("fade-in");
        setIsVisible(true);
      });
    };

    EventBus.on(UIEvent.ShowPanelCalled, handleShow);
    return () => {
      EventBus.off(UIEvent.ShowPanelCalled, handleShow);
    };
  }, [isVisible]);

  const toggleHeight = useCallback(() => setIsCollapsed(prev => !prev), []);
  const InternalComponent = visiblePanel && PanelTypeComponentMap[visiblePanel.panelType];
  const shouldShowActions = visiblePanel?.actionsImpl?.length;

  return (
    <div className={`selection-panel ${isVisible ? "open" : ""} ${isCollapsed ? "collapsed" : ""}`}>
      <div ref={panelRef} className={`selection-panel-content ${fadeState}`}>
        {visiblePanel && (
          <div className="selection-panel-bg" style={{ backgroundImage: `url(${visiblePanel.imagePath})` }}>
            <div className="selection-panel-header" onClick={toggleHeight}>
              <h2><span className="text-bg">{visiblePanel.title}</span></h2>
              <p><span className="text-bg">{visiblePanel.description}</span></p>
            </div>

            <div className="selection-panel-body">
              {InternalComponent && !!visiblePanel.panelTypeData && (
                <InternalComponent data={visiblePanel.panelTypeData} collapsed={isCollapsed} />
              )}
            </div>
            <button
              className="selection-panel-close"
              onClick={() => EventBus.emit(GameEvent.SelectionChanged, -1)}
            >
              
            </button>
          </div>
        )}
      </div>

      {shouldShowActions && (
        <div className="selection-panel-actions">
          {visiblePanel!.actionsImpl!.map((action, index) => (
            <ActionButton key={index} action={action} />
          ))}
        </div>
      )}
    </div>
  );
};


// ---

.character-panel-expanded {
  display: flex;
  flex-direction: column;
  padding: 8px 12px;
  height: 100%;
  justify-content: flex-end;
}

// ---

import { CharacterScheduleIconType } from "../../../../game/display/game/data_panel/character/characterPanelReducer";
import { DisplayableBuffData } from "../../../../game/display/game/data_panel/character/deriveBuffs";
import { CharacterAction } from "../../../../game/logic/action-intent/actionIntentData";
import { ScheduleBarView } from "./schedule/ScheduleBarView";
import { CollapsedStatusAndBuffsView } from "./status_info/CollapsedStatusAndBuffsView";
import { StatusOrBuffView } from "./status_info/StatusOrBuffView";
import "./CharacterPanelDataView.css";

interface CharacterPanelUIData {
  currentStatusText: string;
  currentPerformedAction: CharacterAction;
  currentScheduleIndex: number;
  currentScheduleText: string; 
  scheduleIconTypes: CharacterScheduleIconType[];
  activeBuffs?: DisplayableBuffData[];
}

const scheduleBarIcons: Record<CharacterScheduleIconType, string> = {
  [CharacterScheduleIconType.HARVEST]: "assets/icons/axe_icon.png",
  [CharacterScheduleIconType.SLEEP]: "assets/icons/sleep_icon.png",
  [CharacterScheduleIconType.STUDY]: "assets/icons/book_icon.png",
  [CharacterScheduleIconType.REST]: "assets/icons/relax_icon.png",
  [CharacterScheduleIconType.BUILD]: "assets/icons/build_icon.png", 
  [CharacterScheduleIconType.NONE]: "assets/icons/idle_icon.png", 
};

const performedActionIcons: Record<CharacterAction, string> = {
  [CharacterAction.IDLE]: "assets/icons/idle_icon.png",
  [CharacterAction.WALKING]: "assets/icons/walk_icon.png",
  [CharacterAction.CHOPPING]: "assets/icons/axe_icon.png",
  [CharacterAction.BUILDING]: "assets/icons/build_icon.png",
  [CharacterAction.STUDYING]: "assets/icons/book_icon.png",
  [CharacterAction.SLEEPING]: "assets/icons/sleep_icon.png",
  [CharacterAction.STROLLING]: "assets/icons/walk_icon.png", 
  [CharacterAction.RELAXING]: "assets/icons/relax_icon.png",
  [CharacterAction.NONE]: "assets/icons/idle_icon.png",
};

export const CharacterPanelDataView: React.FC<{
  data: CharacterPanelUIData;
  collapsed: boolean;
}> = ({ data, collapsed }) => {
  if (!data) {
    return null;
  }
  
  const currentActionIcon = performedActionIcons[data.currentPerformedAction] || "assets/icons/idle_icon.png";
  const currentHourScheduleIconType = data.scheduleIconTypes[data.currentScheduleIndex] || CharacterScheduleIconType.NONE;
  const currentScheduleDisplayIcon = scheduleBarIcons[currentHourScheduleIconType];

  if (collapsed) {
    return (
      <CollapsedStatusAndBuffsView
        scheduleText={data.currentScheduleText}
        scheduleIconPath={currentScheduleDisplayIcon}
        actionText={data.currentPerformedAction.toString()}
        actionIconPath={currentActionIcon}
        activeBuffs={data.activeBuffs}
    /> 
    );
  }

  return (
    <div className="character-panel-expanded">
      <StatusOrBuffView
        statusText={data.currentStatusText}
        currentPerformedAction={data.currentPerformedAction}
        scheduleText={data.currentScheduleText}
        scheduleIconSrc={currentScheduleDisplayIcon} 
        activeBuffs={data.activeBuffs}
      />
      <ScheduleBarView 
        scheduleIconTypes={data.scheduleIconTypes} 
        currentScheduleIndex={data.currentScheduleIndex} 
      />
    </div>
  );
};

// ---

/* src/ui/selection/character/ScheduleBarView.css (example path) */

.schedule-bar-wrapper {
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 6px;
    padding: 8px;
    margin-bottom: 4px; /* Retained from CharacterPanelDataView.css */
    margin-right: 20px; /* Retained from CharacterPanelDataView.css, adjust if needed */
    background-color: rgba(0, 0, 0, 0.1); /* Optional: slight background for the wrapper */
  }
  
  .schedule-bar {
    display: flex;
    justify-content: space-evenly;
    align-items: center;
    width: 100%;
  }
  
  .schedule-slot { /* Renamed from .slot to be more specific */
    width: 32px;
    height: 32px;
    border: 2px solid rgba(255, 255, 255, 0.2);
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 4px;
  }
  
  .schedule-slot.active {
    border-color: white;
    box-shadow: 0 0 5px rgba(255, 255, 255, 0.7); /* Optional: slight glow for active slot */
  }
  
  .schedule-slot-icon { /* Renamed from .slot-icon */
    width: 100%;
    height: 100%;
    padding: 2px; /* Optional: if icons need a little breathing room */
    box-sizing: border-box;
    object-fit: contain;
  }

// ---

import React from "react";
import "./ScheduleBarView.css";
import { CharacterScheduleIconType } from "../../../../../game/display/game/data_panel/character/characterPanelReducer";

interface ScheduleBarViewProps {
  scheduleIconTypes: CharacterScheduleIconType[];
  currentScheduleIndex: number;
}

// Icons for the schedule bar, using CharacterScheduleIconType
const scheduleBarIcons: Record<CharacterScheduleIconType, string> = {
  [CharacterScheduleIconType.HARVEST]: "assets/icons/axe_icon.png",
  [CharacterScheduleIconType.SLEEP]: "assets/icons/sleep_icon.png",
  [CharacterScheduleIconType.STUDY]: "assets/icons/book_icon.png",
  [CharacterScheduleIconType.REST]: "assets/icons/relax_icon.png",
  [CharacterScheduleIconType.BUILD]: "assets/icons/build_icon.png",
  [CharacterScheduleIconType.NONE]: "assets/icons/idle_icon.png",
};

export const ScheduleBarView: React.FC<ScheduleBarViewProps> = ({
  scheduleIconTypes,
  currentScheduleIndex,
}) => {
  if (!scheduleIconTypes || scheduleIconTypes.length === 0) {
    return null; // Don't render if there's no schedule data
  }

  return (
    <div className="schedule-bar-wrapper">
      <div className="schedule-bar">
        {scheduleIconTypes.map((iconType, index) => {
          const scheduleIcon = scheduleBarIcons[iconType] || "assets/icons/idle_icon.png";
          // Derive text for title attribute from the enum key name
          const scheduleEntryText =
            (Object.keys(CharacterScheduleIconType) as Array<
              keyof typeof CharacterScheduleIconType
            >).find(
              (key) => CharacterScheduleIconType[key] === iconType
            ) || "Task";

          return (
            <div
              key={index}
              className={`schedule-slot ${
                index === currentScheduleIndex ? "active" : ""
              }`}
              title={scheduleEntryText}
            >
              <img
                src={scheduleIcon}
                alt={scheduleEntryText}
                className="schedule-slot-icon"
              />
            </div>
          );
        })}
      </div>
    </div>
  );
};

// ---

/* src/ui/selection/character/CollapsedStatusAndBuffsView.css (example path) */

.collapsed-status-buffs-view {
  position: absolute;
  top: 8px; /* Align with the top of where the close button is */
  /* Adjust 'right' to position it to the left of your close button */
  /* If close button is ~24-30px wide and at right: 8px, 
     then right: 40px (8px + ~24px_button + ~8px_gap) is a good start. */
  right: 40px; 
  display: flex;
  gap: 6px;
  align-items: center;
  z-index: 2; /* Ensure it's above other panel content if necessary, but usually sibling order handles this */
  padding: 2px; /* Small padding around the group of icons */
}

.collapsed-icon { /* Style for individual schedule/action icons */
  width: 24px;
  height: 24px;
  object-fit: contain;
  background-color: rgba(0, 0, 0, 0.6);
  border-radius: 4px;
  padding: 4px;
  box-sizing: border-box;
  display: flex; 
  align-items: center;
  justify-content: center;
}

.buff-summary { /* Style for the buff summary icon block */
  /* Inherits .collapsed-icon styles if also given that class */
  position: relative; 
}

.buff-summary-icon-image { /* The actual image within the buff summary block */
    width: 100%; /* Or a fixed size if preferred, e.g., 16px */
    height: 100%;
    object-fit: contain;
}

.buff-summary-count {
  position: absolute;
  bottom: -3px; /* Adjusted for better visibility */
  right: -3px;  /* Adjusted for better visibility */
  background-color: rgba(204, 0, 0, 0.9); /* Red, adjust as needed */
  color: white;
  font-size: 0.6rem; /* Smaller font for the count */
  font-weight: bold;
  border-radius: 50%;
  padding: 0px 3px; /* Horizontal padding */
  line-height: 1;   /* Tight line height */
  min-width: 8px;  /* Ensure even single digits have some background */
  text-align: center;
  pointer-events: none; /* So it doesn't interfere with tooltip on parent */
}

// ---

import React from "react";
import "./CollapsedStatusAndBuffsView.css";
import { DisplayableBuffData } from "../../../../../game/display/game/data_panel/character/deriveBuffs";
import { BuffView } from "../../../buffs/BuffView";

export interface CollapsedStatusAndBuffsViewProps {
  scheduleText: string;
  scheduleIconPath: string;
  actionText: string; // This would be data.currentPerformedAction.toString()
  actionIconPath: string;
  activeBuffs?: DisplayableBuffData[];
}

export const CollapsedStatusAndBuffsView: React.FC<CollapsedStatusAndBuffsViewProps> = ({
  scheduleText,
  scheduleIconPath,
  actionText,
  actionIconPath,
  activeBuffs,
}) => {
  return (
    <div className="collapsed-status-buffs-view">
      <img 
        className="collapsed-icon" 
        src={scheduleIconPath} 
        alt={scheduleText} 
        title={`Scheduled: ${scheduleText}`} 
      />
      <img 
        className="collapsed-icon" 
        src={actionIconPath} 
        alt={actionText} 
        title={`Action: ${actionText}`} 
      />
      {activeBuffs?.map(buffData => (
        <BuffView key={buffData.key} data={buffData} />
      ))}
    </div>
  );
};

// ---

/* src/ui/common/StatusInfoLine.css */
.status-info-line {
    display: flex;
    align-items: center;
    margin-block-start: unset;
    margin-block-end: unset;
    margin-bottom: 4px;
    padding: 0.2em 0.4em;
    border-radius: 4px;
    color: #fff;
    font-size: 1rem;
  }
  .status-info-line.text-bg {
      background-color: rgba(0, 0, 0, 0.6);
  }
  .status-label {
    margin-right: 0.5em;
    font-weight: normal; /* Changed from bold for less emphasis if preferred */
  }
  .status-text-value {
    flex-grow: 1;
    text-align: left;
  }
  .status-inline-icon {
    margin-left: 0.5em;
    width: 20px;
    height: 20px;
    object-fit: contain;
    vertical-align: middle;
  }
  .status-children-container {
    margin-left: 0.5em;
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    align-items: center; /* Align buff icons nicely */
  }

// ---

import React from "react";
import "./StatusInfoLine.css"; // Corresponding CSS file

export interface StatusInfoLineProps {
  label: string;
  text?: string | null;
  iconSrc?: string;
  iconAlt?: string;
  children?: React.ReactNode; 
}

export const StatusInfoLine: React.FC<StatusInfoLineProps> = ({
  label,
  text,
  iconSrc,
  iconAlt,
  children,
}) => {
  return (
    <div className="status-info-line text-bg">
      <div className="status-label">{label}</div>
      {text && <span className="status-text-value">{text}</span>}
      {iconSrc && <img className="status-inline-icon" src={iconSrc} alt={iconAlt || label} />}
      {children && <div className="status-children-container">{children}</div>}
    </div>
  );
};

// ---

import React from "react";
import { DisplayableBuffData } from "../../../../../game/display/game/data_panel/character/deriveBuffs";
import { CharacterAction } from "../../../../../game/logic/action-intent/actionIntentData";
import { BuffView } from "../../../buffs/BuffView";
import { StatusInfoLine } from "./StatusInfoLine";

// Icon map for performed actions - kept local to this component or could be imported from a shared consts file
const performedActionIcons: Record<CharacterAction, string> = {
  [CharacterAction.IDLE]: "assets/icons/wait_icon.png",
  [CharacterAction.WALKING]: "assets/icons/walk_icon.png",
  [CharacterAction.CHOPPING]: "assets/icons/axe_icon.png",
  [CharacterAction.BUILDING]: "assets/icons/build_icon.png",
  [CharacterAction.STUDYING]: "assets/icons/book_icon.png",
  [CharacterAction.SLEEPING]: "assets/icons/sleep_icon.png",
  [CharacterAction.STROLLING]: "assets/icons/walk_icon.png", // Strolling might share walk or have its own
  [CharacterAction.RELAXING]: "assets/icons/relax_icon.png",
  [CharacterAction.NONE]: "assets/icons/wait_icon.png", // Or a question mark icon
};

interface StatusOrBuffViewProps {
  statusText: string;
  currentPerformedAction: CharacterAction;
  scheduleText: string;
  scheduleIconSrc: string; // Pass the direct icon source for schedule
  activeBuffs?: DisplayableBuffData[];
}

export const StatusOrBuffView: React.FC<StatusOrBuffViewProps> = ({
  statusText,
  currentPerformedAction,
  scheduleText,
  scheduleIconSrc,
  activeBuffs,
}) => {
  const currentActionIcon = performedActionIcons[currentPerformedAction] || "assets/icons/idle_icon.png";

  return (
    <div className="status-buff-view-wrapper">
        {activeBuffs && activeBuffs.length > 0 && (
          <>{activeBuffs.map((buffData) => (
            <StatusInfoLine label={buffData.description}>
              <BuffView key={buffData.key} data={buffData} />
            </StatusInfoLine>
          ))}</>
      )}
      <StatusInfoLine 
        label="Status" 
        text={statusText} 
        iconSrc={currentActionIcon} 
        iconAlt={currentPerformedAction.toString()} 
      />
      <StatusInfoLine 
        label="Schedule" 
        text={scheduleText} 
        iconSrc={scheduleIconSrc} 
        iconAlt={scheduleText}
      />
    </div>
  );
};

// ---

.character-panel-collapsed {
    position: absolute;
    top: 8px;
    right: 40px;
    display: flex;
    gap: 6px;
    z-index: 2;
  }
  
  .character-panel-collapsed .icon {
    width: 24px;
    height: 24px;
    object-fit: contain;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
    color: white;
    font-size: 0.75rem;
  }
  
  .character-panel-expanded {
    display: flex;
    flex-direction: column;
    padding: 8px 12px;
    height: 100%;
    justify-content: flex-end;
  }
  
  .schedule-info {
    display: flex;
    flex-direction: column;
    gap: 6px;
    margin-bottom: 8px;
  }
  
  .schedule-line {
    display: flex;
    align-items: center;
    background-color: rgba(0, 0, 0, 0.6);
    border-radius: 4px;
    padding: 4px 8px;
    color: #fff;
    font-size: 1rem;
  }
  
  .label {
    flex: 1;
  }
  
  .inline-icon {
    margin-left: auto;
    width: 20px;
    height: 20px;
    object-fit: contain;
  }
  
  .schedule-bar-wrapper {
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 6px;
  }
  
  .schedule-bar {
    display: flex;
    justify-content: space-evenly;
    align-items: center;
    width: 100%;
  }
  
  .slot {
    width: 32px;
    height: 32px;
    border: 2px solid rgba(255, 255, 255, 0.2);
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 4px;
  }
  
  .slot.active {
    border-color: white;
  }
  
  .slot-icon {
    width: 100%;
    height: 100%;
    object-fit: contain;
  }
  
  .drops-info {
    display: flex;
    flex-direction: column;
    gap: 6px;
    margin-bottom: 8px;
  }
  
  .drop-line {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: rgba(0, 0, 0, 0.5);
    border-radius: 4px;
    padding: 4px 8px;
    color: #fff;
    font-size: 1rem;
  }
  
  .progress-line {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: rgba(0, 0, 0, 0.6);
    border-radius: 4px;
    padding: 4px 8px;
    color: #fff;
    font-size: 1rem;
  }
  
  .small-label {
    font-size: 0.75rem;
    color: white;
  }
  

// ---

import React from "react";
import "./TreePanelDataView.css";

interface DropEntry {
  type: string;
  amount: number;
}

interface TreePanelData {
  drops: DropEntry[];
  cutProgress: number;
  maxCutProgress: number;
}

const dropIcons: Record<string, string> = {
  wood: "assets/icons/wood_icon.png",
  food: "assets/icons/food_icon.png"
};

export const TreePanelDataView: React.FC<{
  data: TreePanelData;
  collapsed: boolean;
}> = ({ data, collapsed }) => {
  const { drops, cutProgress, maxCutProgress } = data;
  const isCutDown = cutProgress == 0;

  if (collapsed) {
    return (
      <div className="character-panel-collapsed">
        {drops.map((drop, index) => (
          <div key={index} className="icon">
            <img
              className="icon"
              src={dropIcons[drop.type] || ""}
              alt={drop.type}
            />
            <span className="small-label">{drop.amount}</span>
          </div>
        ))}
      </div>
    );
  }

  return (
    <div className="character-panel-expanded">
      <div className="drops-info">
        {drops.map((drop, index) => (
          <div key={index} className="drop-line">
            <img className="inline-icon" src={dropIcons[drop.type] || ""} alt={drop.type} />
            <span className="label">{drop.amount}</span>
          </div>
        ))}
      </div>
      <div className="progress-line">
        <span className="label">Chop Progress:</span>
        <span className="value">
          {isCutDown ? "CUT DOWN" : `${maxCutProgress-cutProgress} / ${maxCutProgress}`}
        </span>
      </div>
    </div>
  );
};


// ---

import { useEffect, useState } from "react";
import { EventBus } from "../../../game/EventBus";
import { GameEvent } from "../../../game/consts/GameEvent";
import { ToolType } from "../../../game/display/game/tools/GameTools";

export function useSelectedTool(): ToolType | null {
    const [selectedTool, setSelectedTool] = useState<ToolType | null>(null);

    useEffect(() => {
        const handle = (tool: ToolType) => {
            setSelectedTool(tool)
        };

        EventBus.on(GameEvent.ToolSelected, handle);
        return () => {
            EventBus.off(GameEvent.ToolSelected, handle);
        };
    }, []);

    return selectedTool;
}


// ---

import React, { useEffect, useState } from "react";
import { StoryEventPage, StoryOption } from "../../../game/logic/story/StoryEventTypes";
import { GameEvent } from "../../../game/consts/GameEvent";
import { EventBus } from "../../../game/EventBus";
import "./StoryEventUI.css";

export const StoryEventUI: React.FC = () => {
    const [page, setPage] = useState<StoryEventPage | null>(null);

    useEffect(() => {
        EventBus.on(GameEvent.StoryEventStarted, setPage);
        EventBus.on(GameEvent.StoryEventPageChanged, setPage);
        EventBus.on(GameEvent.StoryEventEnded, () => setPage(null));

        return () => {
            EventBus.off(GameEvent.StoryEventStarted, setPage);
            EventBus.off(GameEvent.StoryEventPageChanged, setPage);
            EventBus.off(GameEvent.StoryEventEnded, () => setPage(null));
        };
    }, []);

    if (!page) return null;

    return (
        <div className="story-event-ui" style={{ backgroundImage: `url(${page.imagePath})` }}>
            <div className="story-text">{page.text}</div>
            <div className="story-options">
                {page.options.map((opt, idx) => (
                    <button key={idx} onClick={() => EventBus.emit(GameEvent.StoryEventOptionChosen, opt)}>
                        {opt.label}
                    </button>
                ))}
            </div>
        </div>
    );
};


// ---

.time-controls {
    position: absolute;
    bottom: 20px;
    right: 20px;
    display: flex;
    flex-direction: column; /*  stack children vertically */
    align-items: flex-end;   /* keep buttons & text aligned right */
    gap: 8px;
    z-index: 100;
}

.time-button {
    font-size: 1.5rem;
    padding: 10px 16px;
    border: 2px solid #444;
    background: #f0f0f0;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.time-button.active {
    background: #ccf;
    border-color: #228;
    font-weight: bold;
}

.time-display {
    font-size: 1rem;
    margin-bottom: 6px;
    color: #333;
    text-align: right;
}

.time-buttons {
    display: flex;
    gap: 10px;
}

.time-raw-large {
    font-size: 1.25rem;
    font-weight: bold;
    color: #ffffff;
    text-align: right;
}

.time-raw {
    margin-top: 6px;
    font-size: 0.9rem;
    color: #666;
    text-align: right;
}


// ---

import React, { useCallback, useMemo } from "react";
import "./TimeControls.css";
import {useGameTime} from "./useGameTime.ts";
import {TimeSpeed} from "../../../game/logic/input/InputComponent.ts";
import {EventBus} from "../../../game/EventBus.ts";
import {GameEvent} from "../../../game/consts/GameEvent.ts";

const speeds: { label: string; value: TimeSpeed }[] = [
    { label: "", value: "paused" },
    { label: "", value: "normal" },
    { label: "", value: "fast" },
    { label: "", value: "veryfast" },
];


export const TimeControls: React.FC = () => {
    const { speed, hour, minute, day, semester } = useGameTime();

    const timeRaw = useMemo(() => {
        return `${Math.round(minute)}|${Math.round(hour)}|${Math.round(day)}|${Math.round(semester)}`;
    }, [minute, hour, day, semester]);

    const handleClick = useCallback(
        (newSpeed: TimeSpeed) => {
            if (newSpeed !== speed) {
                EventBus.emit(GameEvent.SetTimeSpeed, newSpeed);
            }
        },
        [speed]
    );

    return (
        <div className="time-controls">
            <div className="time-buttons">
                {speeds.map(({ label, value }) => (
                    <button
                        key={value}
                        className={`time-button ${speed === value ? "active" : ""}`}
                        onClick={() => handleClick(value)}
                    >
                        {label}
                    </button>
                ))}
            </div>
            <div className="time-raw-large">{timeRaw}</div>
        </div>
    );
};

// ---

import { useEffect, useState } from "react";
import {TimeSpeed} from "../../../game/logic/input/InputComponent.ts";
import {EventBus} from "../../../game/EventBus.ts";
import {GameEvent} from "../../../game/consts/GameEvent.ts";
import {TimeConfig} from "../../../game/config/TimeConfig.ts";

export interface GameTime {
    minute: number;
    hour: number;
    day: number;
    semester: number;
    speed: TimeSpeed;
}

export function useGameTime(): GameTime {
    const [time, setTime] = useState<GameTime>({
        minute: 0,
        hour: 0,
        day: 0,
        semester: 0,
        speed: "normal" as TimeSpeed,
    });

    useEffect(() => {
        EventBus.on(GameEvent.SetTimeSpeed, (speed: TimeSpeed) =>
            setTime(prev => ({ ...prev, speed }))
        );
        
        EventBus.on(GameEvent.SetTime, (time: number) =>
            setTime(prev => ({ ...prev, ...divideTime(time) }))
        );
    }, []);

    return time;
}


export function divideTime(totalMinutes: number): Partial<GameTime> {
    const minutesPerHour = TimeConfig.MinutesPerHour;
    const hoursPerDay = TimeConfig.HoursPerDay;
    const daysPerSemester = TimeConfig.DaysPerSemester;

    let minutes = totalMinutes;

    const semester = Math.floor(minutes / (daysPerSemester * hoursPerDay * minutesPerHour));
    minutes %= daysPerSemester * hoursPerDay * minutesPerHour;

    const day = Math.floor(minutes / (hoursPerDay * minutesPerHour));
    minutes %= hoursPerDay * minutesPerHour;

    const hour = Math.floor(minutes / minutesPerHour);
    minutes %= minutesPerHour;

    return {
        semester,
        day,
        hour,
        minute: minutes
    };
}


// ---

.weather-panel {
    background-color: rgba(255, 255, 255, 0.9);
    border: 2px solid #888;
    border-radius: 8px;
    padding: 12px 16px;
    width: 200px;
    font-family: sans-serif;
    font-size: 0.95rem;
    color: #333;
    box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
}

.weather-panel h3 {
    margin-top: 0;
    font-size: 1.1rem;
    margin-bottom: 8px;
}

.weather-row {
    display: flex;
    justify-content: space-between;
    margin-bottom: 4px;
}


// ---

import React from "react";
import { useWeather } from "./useWeather.ts";
import "./WeatherPanel.css";

export const WeatherPanel: React.FC = () => {
    const weather = useWeather();

    if (!weather) return null;

    return (
        <div className="weather-panel">
            <h3>Weather</h3>
            <div className="weather-row">
                <label> Wind Strength:</label>
                <span>{weather.windStrength.toFixed(2)}</span>
            </div>
            <div className="weather-row">
                <label> Wind Direction:</label>
                <span>{weather.windDirection === 1 ? "" : ""}</span>
            </div>
            <div className="weather-row">
                <label> Cloud Cover:</label>
                <span>{weather.cloudCover.toFixed(2)}</span>
            </div>
        </div>
    );
};


// ---

import { useEffect, useState } from "react";
import {WeatherComponent} from "../../../game/logic/weather/WeatherComponent.ts";
import {GameEvent} from "../../../game/consts/GameEvent.ts";
import {EventBus} from "../../../game/EventBus.ts";

export function useWeather(): WeatherComponent | null {
    const [weather, setWeather] = useState<WeatherComponent | null>(null);

    // @ts-ignore
    useEffect(() => {
        const handler = (payload: WeatherComponent) => {
            setWeather({ ...payload });
        };

        EventBus.on(GameEvent.SetWeather, handler);
        return () => EventBus.off(GameEvent.SetWeather, handler);
    }, []);

    return weather;
}


// ---

import React, { useRef } from 'react';

interface FileManagementUiProps {
    name: string;
    validExtensions: string[];
    save: (name: string) => void;
    onLoad: (e: ProgressEvent<FileReader>) => void;
    onNameChange: (newName: string) => void;
}

export function FileManagementUi({
                                     name,
                                     validExtensions,
                                     save,
                                     onLoad,
                                     onNameChange
                                 }: FileManagementUiProps) {
    const fileInputRef = useRef<HTMLInputElement>(null);

    const handleLoadClick = () => {
        fileInputRef.current?.click();
    };

    const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (!file) return;

        const ext = file.name.slice(file.name.lastIndexOf('.'));
        if (!validExtensions.includes(ext)) {
            alert(`Invalid file type: ${ext}`);
            return;
        }

        const reader = new FileReader();
        reader.onload = onLoad;
        reader.readAsText(file);
    };

    const handleSaveClick = () => {
        if (!name.trim()) {
            alert('Please enter a name.');
            return;
        }
        save(name.trim());
    };

    return (
        <div className="file-management-ui">
            <input
                type="text"
                placeholder="Name..."
                value={name}
                onChange={(e) => onNameChange(e.target.value)}
            />
            <div className="file-actions">
                <button onClick={handleSaveClick}> Save</button>
                <button onClick={handleLoadClick}> Load</button>
                <input
                    type="file"
                    accept={validExtensions.join(',')}
                    ref={fileInputRef}
                    style={{ display: 'none' }}
                    onChange={handleFileChange}
                />
            </div>
        </div>
    );
}


// ---

.sidebar {
    width: 60px;
    background-color: #2c2c2c;
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-top: 12px;
    box-shadow: 2px 0 4px rgba(0,0,0,0.1);
    pointer-events: all;
    box-sizing: border-box;
}

.sidebar-title {
    font-size: 14px;
    margin-bottom: 16px;
    text-align: center;
    font-weight: 600;
    letter-spacing: 0.05em;
}


.sidebar-buttons {
    display: flex;
    flex-direction: column;
    gap: 8px;
    width: 100%;
    height: 100%;
    padding: 0 4px;
}

.sidebar-button {
    background: none;
    border: none;
    color: white;
    width: 100%;
    padding: 8px 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    font-size: 12px;
    cursor: pointer;
    transition: background-color 0.2s;
    border-radius: 4px;
}

.sidebar-button:hover {
    background-color: #3c3c3c;
}

.sidebar-button.active {
    background-color: #4c4c8f;
}

.sidebar-icon {
    font-size: 20px;
    margin-bottom: 4px;
    width: 24px;
    height: 24px;
}

.sidebar-icon img {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

.undo-redo-controls {
    display: flex;
    flex-direction: column;
    gap: 6px;
    margin-top: auto; /* Push to bottom */
    padding-top: 12px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.undo-redo-controls button {
    background: none;
    border: 1px solid rgba(255, 255, 255, 0.15);
    color: white;
    font-size: 12px;
    padding: 6px;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.15s ease;
}

.undo-redo-controls button:hover {
    background: rgba(255, 255, 255, 0.1);
}


// ---

import React, { ReactNode } from 'react';
import './Sidebar.css';

interface SidebarProps {
    title: string;
    children: ReactNode;
}

export const Sidebar: React.FC<SidebarProps> = ({ title, children }) => {
    return (
        <aside className="sidebar">
            <h2 className="sidebar-title">{title}</h2>
            <div className="sidebar-buttons">
                {children}
            </div>
        </aside>
    );
};


// ---

import React from 'react';
import './Sidebar.css';

interface SidebarButtonProps {
    label: string;
    icon?: string; // Emoji or URL path
    isActive: boolean;
    onClick: () => void;
}

export const SidebarButton: React.FC<SidebarButtonProps> = ({ label, icon, isActive, onClick }) => {
    return (
        <button className={`sidebar-button ${isActive ? 'active' : ''}`} onClick={onClick}>
            {icon && (
                icon.startsWith('http') || icon.includes('/') ? (
                    <img src={icon} alt="" className="sidebar-icon" />
                ) : (
                    <span className="sidebar-icon">{icon}</span>
                )
            )}
            <span>{label}</span>
        </button>
    );
};


// ---

import React from 'react';
import {EventBus} from "../../../game/EventBus.ts";

export const UndoRedo: React.FC = () => {
    return (
        <div className="undo-redo-controls">
            <button onClick={() => EventBus.emit('editor-undo')}> Undo</button>
            <button onClick={() => EventBus.emit('editor-redo')}> Redo</button>
        </div>
    );
};


// ---

import React from 'react';
import {SpriteKey, SpriteLibrary} from "../../../game/display/setup/SpriteLibrary.ts";

interface Props {
    spriteKey: SpriteKey;
    selected: boolean;
    onClick: () => void;
}

export const PaletteEntry: React.FC<Props> = ({ spriteKey, selected, onClick }) => {
    const def = SpriteLibrary[spriteKey];
    
    const imageSrc = def.path ?? `assets/${spriteKey}.png`;

    return (
        <button className={`palette-entry ${selected ? 'selected' : ''}`} onClick={onClick}>
            <img src={imageSrc} alt={spriteKey} draggable={false} />
        </button>
    );
};

// ---

.sprite-palette {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(36px, 1fr));
    gap: 6px;
    padding: 8px;
    width: 100%;
    box-sizing: border-box;
}

.palette-entry {
    border: 1px solid transparent;
    background: none;
    padding: 2px;
    border-radius: 4px;
    cursor: pointer;
    width: 100%;
    aspect-ratio: 1 / 1;
    display: flex;
    align-items: center;
    justify-content: center;
}

.palette-entry.selected {
    border-color: white;
    background: rgba(255, 255, 255, 0.1);
}

.palette-entry img {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
}


// ---

import React from 'react';
import './SpritePalette.css';
import {PaletteEntry} from "./PaletteEntry.tsx";
import {SpriteKey} from "../../../game/display/setup/SpriteLibrary.ts";

interface SpritePaletteProps {
    spriteKeys: string[];
    onSelect: (key: SpriteKey) => void;
    selectedKey?: string;
}

export function SpritePalette({ spriteKeys, onSelect, selectedKey }: SpritePaletteProps) {
    return (
        <div className="sprite-palette">
            {spriteKeys.map((key) => (
                <PaletteEntry
                    key={key}
                    spriteKey={key as SpriteKey}
                    selected={selectedKey === key}
                    onClick={() => onSelect(key as SpriteKey)}
                />
            ))}
        </div>
    );
}


// ---

import React from 'react';
import {useActiveSceneType} from "./useActiveSceneType.ts";
import {GameContainer} from "../game/GameContainer.tsx";

export const UISwitcher: React.FC = () => {
    const sceneType = useActiveSceneType();

    switch (sceneType) {
        case 'editor':
            return <></>;
        case 'game':
            return <GameContainer />;
        default:
            return null; // or a <LoadingScreen /> or <ErrorFallback />
    }
};


// ---

import React from "react";

type SceneType = 'editor' | 'game';

const listeners = new Set<(type: SceneType) => void>();
let currentSceneType: SceneType = 'game';

export function setSceneType(type: SceneType) {
    currentSceneType = type;
    listeners.forEach(fn => fn(type));
}

export function useActiveSceneType(): SceneType {
    const [sceneType, setSceneTypeState] = React.useState(currentSceneType);

    // @ts-ignore
    React.useEffect(() => {
        const fn = (type: SceneType) => setSceneTypeState(type);
        listeners.add(fn);
        return () => listeners.delete(fn);
    }, []);

    return sceneType;
}


// ---

export function lerpColor(c1: number, c2: number, t: number): number {
    const r1 = (c1 >> 16) & 0xff;
    const g1 = (c1 >> 8) & 0xff;
    const b1 = c1 & 0xff;

    const r2 = (c2 >> 16) & 0xff;
    const g2 = (c2 >> 8) & 0xff;
    const b2 = c2 & 0xff;

    const r = Math.round(r1 + (r2 - r1) * t);
    const g = Math.round(g1 + (g2 - g1) * t);
    const b = Math.round(b1 + (b2 - b1) * t);

    return (r << 16) | (g << 8) | b;
}

// ---

export interface Pos {x:number; y:number}

export class MathUtils {
    static weightedRand(weightedValues: { [key: number]: number }): number {
        // Calculate the total weight
        let totalWeight = 0;
        for (let key in weightedValues) {
            totalWeight += weightedValues[key];
        }

        // Generate a random number in the range [0, totalWeight)
        let random = Math.random() * totalWeight;

        // Determine which key corresponds to the random number
        for (let key in weightedValues) {
            random -= weightedValues[key];
            if (random <= 0) {
                return parseInt(key);
            }
        }

        // Fallback, should theoretically never be reached
        return -1;
    }

    /**
     * Selects a random key from an object based on the numerical weights assigned to each key.
     *
     * @param weightedValues - An object where keys are the items to choose from (string)
     * and values are their corresponding weights (number).
     * @returns A randomly selected key (string) based on the provided weights.
     * Returns an empty string if the input object is empty or total weight is zero.
     */
    public static weightedRandString(weightedValues: { [key: string]: number }): string {
        let totalWeight = 0;

        // Calculate the sum of all weights
        for (const key in weightedValues) {
            // Ensure the property belongs to the object itself, not its prototype
            if (Object.prototype.hasOwnProperty.call(weightedValues, key)) {
                // Ensure weight is a positive number
                const weight = Math.max(0, weightedValues[key]);
                weightedValues[key] = weight; // Store the sanitized weight back
                totalWeight += weight;
            }
        }

        // Handle edge case: no items or zero total weight
        if (totalWeight <= 0) {
            console.warn("weightedRand called with empty or zero-weight items.");
            // Attempt to return the first key if any exist, otherwise empty string
            const keys = Object.keys(weightedValues);
            return keys.length > 0 ? keys[0] : '';
        }

        // Generate a random number between 0 (inclusive) and totalWeight (exclusive)
        let random = Math.random() * totalWeight;

        // Iterate through the items again to find the chosen one
        for (const key in weightedValues) {
            if (Object.prototype.hasOwnProperty.call(weightedValues, key)) {
                // If the random number falls within the current item's weight range
                if (random < weightedValues[key]) {
                    return key; // Return the key of the selected item
                }
                // Subtract the current item's weight from the random number
                random -= weightedValues[key];
            }
        }

        // Fallback: Should theoretically not be reached if totalWeight > 0
        // Return the last key as a safeguard
        const keys = Object.keys(weightedValues);
        console.warn("weightedRand fallback triggered.");
        return keys.length > 0 ? keys[keys.length - 1] : '';
    }
    
    static weightedRandIndex(weights:number[]): number {
        // Calculate the total weight
        let totalWeight = 0;
        for (let i = 0; i < weights.length; i++) {
            totalWeight += weights[i];
        }

        // Generate a random number in the range [0, totalWeight)
        let random = Math.random() * totalWeight;

        // Determine which key corresponds to the random number
        for (let i = 0; i < weights.length; i++) {
            random -= weights[i];
            if (random <= 0) {
                return i;
            }
        }

        // Fallback, should theoretically never be reached
        return -1;
    }

    static remapNoiseToUnit(value: number): number {
        return (value + 1) / 2;
    }

    static distance(pos1: Pos, pos2: Pos): number {
        // Simple Euclidean distance calculation
        return Math.sqrt(Math.pow(pos2.x - pos1.x, 2) + Math.pow(pos2.y - pos1.y, 2));
    }

    static normalize(pos: Pos): Pos {
        const length = Math.sqrt(pos.x * pos.x + pos.y * pos.y);
        if (length == 0) return { x: 0, y: 0 };
        return { x: pos.x / length, y: pos.y / length };
    }

    static multiply(pos: Pos, scalar: number): Pos {
        return { x: pos.x * scalar, y: pos.y * scalar };
    }

    static add(pos1: Pos, pos2: Pos): Pos {
        return { x: pos1.x + pos2.x, y: pos1.y + pos2.y };
    }

    static subtract(pos1: Pos, pos2: Pos): Pos {
        return { x: pos1.x - pos2.x, y: pos1.y - pos2.y };
    }

    static randomPointOnCircumference(position: Pos, radius: number): Pos {
        const angle = Math.random() * 2 * Math.PI;
        const x = position.x + radius * Math.cos(angle);
        const y = position.y + radius * Math.sin(angle);
        return { x, y };
    }

    static closestValue(position: Pos, values: Set<number>, positions: Map<number, Pos>): number | undefined {
        let closest = Number.MAX_VALUE;
        let target = undefined;

        values.forEach(value => {
            const pos = positions.get(value);
            if (!pos) {
                return;
            }
            const distance = MathUtils.distance(position, pos);
            if (distance < closest) {
                closest = distance;
                target = value;
            }
        });

        return target;
    }
}

// ---

export class SimplexNoise {
    private grad3 = [
        [1,1], [-1,1], [1,-1], [-1,-1],
        [1,0], [-1,0], [0,1], [0,-1],
    ];
    private grad3D = [
        [1,1,0], [-1,1,0], [1,-1,0], [-1,-1,0],
        [1,0,1], [-1,0,1], [1,0,-1], [-1,0,-1],
        [0,1,1], [0,-1,1], [0,1,-1], [0,-1,-1]
    ];

    private p: number[] = [];
    private perm: number[] = [];
    private dot3(g: number[], x: number, y: number, z: number): number {
        return g[0] * x + g[1] * y + g[2] * z;
    }

    constructor(seed: number = 0) {
        this.buildPermutationTable(seed);
    }

    private buildPermutationTable(seed: number) {
        this.p = new Array(256);
        for (let i = 0; i < 256; i++) {
            this.p[i] = i;
        }

        let random = this.xorshift(seed);
        for (let i = 255; i > 0; i--) {
            const n = Math.floor((random() * (i + 1)));
            [this.p[i], this.p[n]] = [this.p[n], this.p[i]];
        }

        this.perm = new Array(512);
        for (let i = 0; i < 512; i++) {
            this.perm[i] = this.p[i & 255];
        }
    }

    private xorshift(seed: number): () => number {
        let x = seed || 123456789;
        return function () {
            x ^= x << 13;
            x ^= x >> 17;
            x ^= x << 5;
            return (x >>> 0) / 0xFFFFFFFF;
        };
    }

    private dot(g: number[], x: number, y: number): number {
        return g[0] * x + g[1] * y;
    }

    public noise(xin: number, yin: number): number {
        const F2 = 0.5 * (Math.sqrt(3) - 1);
        const G2 = (3 - Math.sqrt(3)) / 6;

        let n0 = 0, n1 = 0, n2 = 0;

        const s = (xin + yin) * F2;
        const i = Math.floor(xin + s);
        const j = Math.floor(yin + s);

        const t = (i + j) * G2;
        const X0 = i - t;
        const Y0 = j - t;
        const x0 = xin - X0;
        const y0 = yin - Y0;

        let i1, j1;
        if (x0 > y0) {
            i1 = 1; j1 = 0;
        } else {
            i1 = 0; j1 = 1;
        }

        const x1 = x0 - i1 + G2;
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1 + 2 * G2;
        const y2 = y0 - 1 + 2 * G2;

        const ii = i & 255;
        const jj = j & 255;
        const gi0 = this.perm[ii + this.perm[jj]] % 8;
        const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 8;
        const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 8;

        let t0 = 0.5 - x0*x0 - y0*y0;
        if (t0 >= 0) {
            t0 *= t0;
            n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
        }

        let t1 = 0.5 - x1*x1 - y1*y1;
        if (t1 >= 0) {
            t1 *= t1;
            n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
        }

        let t2 = 0.5 - x2*x2 - y2*y2;
        if (t2 >= 0) {
            t2 *= t2;
            n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
        }

        return 70.0 * (n0 + n1 + n2); // Output range: [-1, 1]
    }

    public noise3D(xin: number, yin: number, zin: number): number {
        const F3 = 1 / 3;
        const G3 = 1 / 6;

        let n0 = 0, n1 = 0, n2 = 0, n3 = 0;

        const s = (xin + yin + zin) * F3;
        const i = Math.floor(xin + s);
        const j = Math.floor(yin + s);
        const k = Math.floor(zin + s);

        const t = (i + j + k) * G3;
        const X0 = i - t;
        const Y0 = j - t;
        const Z0 = k - t;

        const x0 = xin - X0;
        const y0 = yin - Y0;
        const z0 = zin - Z0;

        let i1 = 0, j1 = 0, k1 = 0;
        let i2 = 0, j2 = 0, k2 = 0;

        if (x0 >= y0) {
            if (y0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
            else if (x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
            else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
        } else {
            if (y0 < z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
            else if (x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
            else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
        }

        const x1 = x0 - i1 + G3;
        const y1 = y0 - j1 + G3;
        const z1 = z0 - k1 + G3;
        const x2 = x0 - i2 + 2 * G3;
        const y2 = y0 - j2 + 2 * G3;
        const z2 = z0 - k2 + 2 * G3;
        const x3 = x0 - 1 + 3 * G3;
        const y3 = y0 - 1 + 3 * G3;
        const z3 = z0 - 1 + 3 * G3;

        const ii = i & 255;
        const jj = j & 255;
        const kk = k & 255;

        const gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
        const gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
        const gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;
        const gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;

        let t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
        if (t0 < 0) n0 = 0;
        else {
            t0 *= t0;
            n0 = t0 * t0 * this.dot3(this.grad3D[gi0], x0, y0, z0);
        }

        let t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
        if (t1 < 0) n1 = 0;
        else {
            t1 *= t1;
            n1 = t1 * t1 * this.dot3(this.grad3D[gi1], x1, y1, z1);
        }

        let t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
        if (t2 < 0) n2 = 0;
        else {
            t2 *= t2;
            n2 = t2 * t2 * this.dot3(this.grad3D[gi2], x2, y2, z2);
        }

        let t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
        if (t3 < 0) n3 = 0;
        else {
            t3 *= t3;
            n3 = t3 * t3 * this.dot3(this.grad3D[gi3], x3, y3, z3);
        }

        return 32.0 * (n0 + n1 + n2 + n3); // Output range: ~[-1, 1]
    }

}


// ---

/// <reference types="vite/client" />
